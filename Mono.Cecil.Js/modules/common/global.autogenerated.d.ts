/** Auto generated by the Mono.Cecil.Js.TypingsGenerator tool **/

declare module dotnet {
	module Mono.Collections.Generic {
		class Collection<T> {
			Count: number;
			Item: any;
			Capacity: number;
			 constructor() ;
			 constructor(capacity: number) ;
			 constructor(items: any) ;
			 Add(item: T) : void;
			 Contains(item: T) : boolean;
			 IndexOf(item: T) : number;
			 Insert(index: number, item: T) : void;
			 RemoveAt(index: number) : void;
			 Remove(item: T) : boolean;
			 Clear() : void;
			 CopyTo(array: any, arrayIndex: number) : void;
			 ToArray() : any;
			 GetEnumerator() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ReadOnlyCollection<T> {
			 constructor(array: any) ;
			 constructor(collection: any) ;
			 Add(item: T) : void;
			 Contains(item: T) : boolean;
			 IndexOf(item: T) : number;
			 Insert(index: number, item: T) : void;
			 RemoveAt(index: number) : void;
			 Remove(item: T) : boolean;
			 Clear() : void;
			 CopyTo(array: any, arrayIndex: number) : void;
			 ToArray() : any;
			 GetEnumerator() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module System {
		class Action extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke() : void;
			 BeginInvoke(callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : void;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class AggregateException extends System.Exception {
			InnerExceptions: any;
			Message: string;
			 constructor() ;
			 constructor(message: string) ;
			 constructor(message: string, innerException: System.Exception) ;
			 constructor(innerExceptions: any) ;
			 constructor(innerExceptions: any) ;
			 constructor(message: string, innerExceptions: any) ;
			 constructor(message: string, innerExceptions: any) ;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 GetBaseException() : System.Exception;
			 Handle(predicate: any) : void;
			 Flatten() : System.AggregateException;
			 ToString() : string;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class Array {
			Length: number;
			LongLength: number;
			Rank: number;
			SyncRoot: any;
			IsReadOnly: boolean;
			IsFixedSize: boolean;
			IsSynchronized: boolean;
			 static Exists(array: any, match: any) : boolean;
			 static Fill(array: any, value: any) : void;
			 static Fill(array: any, value: any, startIndex: number, count: number) : void;
			 static Find(array: any, match: any) : any;
			 static FindAll(array: any, match: any) : any;
			 static FindIndex(array: any, match: any) : number;
			 static FindIndex(array: any, startIndex: number, match: any) : number;
			 static FindIndex(array: any, startIndex: number, count: number, match: any) : number;
			 static FindLast(array: any, match: any) : any;
			 static FindLastIndex(array: any, match: any) : number;
			 static FindLastIndex(array: any, startIndex: number, match: any) : number;
			 static FindLastIndex(array: any, startIndex: number, count: number, match: any) : number;
			 static ForEach(array: any, action: any) : void;
			 static IndexOf(array: System.Array, value: any) : number;
			 static IndexOf(array: System.Array, value: any, startIndex: number) : number;
			 static IndexOf(array: System.Array, value: any, startIndex: number, count: number) : number;
			 static IndexOf(array: any, value: any) : number;
			 static IndexOf(array: any, value: any, startIndex: number) : number;
			 static IndexOf(array: any, value: any, startIndex: number, count: number) : number;
			 static LastIndexOf(array: System.Array, value: any) : number;
			 static LastIndexOf(array: System.Array, value: any, startIndex: number) : number;
			 static LastIndexOf(array: System.Array, value: any, startIndex: number, count: number) : number;
			 static LastIndexOf(array: any, value: any) : number;
			 static LastIndexOf(array: any, value: any, startIndex: number) : number;
			 static LastIndexOf(array: any, value: any, startIndex: number, count: number) : number;
			 static Reverse(array: System.Array) : void;
			 static Reverse(array: System.Array, index: number, length: number) : void;
			 static Reverse(array: any) : void;
			 static Reverse(array: any, index: number, length: number) : void;
			 static Sort(array: System.Array) : void;
			 static Sort(keys: System.Array, items: System.Array) : void;
			 static Sort(array: System.Array, index: number, length: number) : void;
			 static Sort(keys: System.Array, items: System.Array, index: number, length: number) : void;
			 static Sort(array: System.Array, comparer: System.Collections.IComparer) : void;
			 static Sort(keys: System.Array, items: System.Array, comparer: System.Collections.IComparer) : void;
			 static Sort(array: System.Array, index: number, length: number, comparer: System.Collections.IComparer) : void;
			 static Sort(keys: System.Array, items: System.Array, index: number, length: number, comparer: System.Collections.IComparer) : void;
			 static Sort(array: any) : void;
			 static Sort(keys: any, items: any) : void;
			 static Sort(array: any, index: number, length: number) : void;
			 static Sort(keys: any, items: any, index: number, length: number) : void;
			 static Sort(array: any, comparer: any) : void;
			 static Sort(keys: any, items: any, comparer: any) : void;
			 static Sort(array: any, index: number, length: number, comparer: any) : void;
			 static Sort(keys: any, items: any, index: number, length: number, comparer: any) : void;
			 static Sort(array: any, comparison: any) : void;
			 static TrueForAll(array: any, match: any) : boolean;
			 GetEnumerator() : System.Collections.IEnumerator;
			 static CreateInstance(elementType: System.Type, length: number) : System.Array;
			 static CreateInstance(elementType: System.Type, length1: number, length2: number) : System.Array;
			 static CreateInstance(elementType: System.Type, length1: number, length2: number, length3: number) : System.Array;
			 static CreateInstance(elementType: System.Type, ...lengths: number[]) : System.Array;
			 static CreateInstance(elementType: System.Type, lengths: number[], lowerBounds: number[]) : System.Array;
			 static Copy(sourceArray: System.Array, destinationArray: System.Array, length: number) : void;
			 static Copy(sourceArray: System.Array, sourceIndex: number, destinationArray: System.Array, destinationIndex: number, length: number) : void;
			 static ConstrainedCopy(sourceArray: System.Array, sourceIndex: number, destinationArray: System.Array, destinationIndex: number, length: number) : void;
			 static Clear(array: System.Array, index: number, length: number) : void;
			 GetValue(...indices: number[]) : any;
			 GetValue(index: number) : any;
			 GetValue(index1: number, index2: number) : any;
			 GetValue(index1: number, index2: number, index3: number) : any;
			 SetValue(value: any, index: number) : void;
			 SetValue(value: any, index1: number, index2: number) : void;
			 SetValue(value: any, index1: number, index2: number, index3: number) : void;
			 SetValue(value: any, ...indices: number[]) : void;
			 GetLength(dimension: number) : number;
			 GetUpperBound(dimension: number) : number;
			 GetLowerBound(dimension: number) : number;
			 Initialize() : void;
			 static AsReadOnly(array: any) : any;
			 static Resize(array: any, newSize: number) : void;
			 static CreateInstance(elementType: System.Type, ...lengths: number[]) : System.Array;
			 static Copy(sourceArray: System.Array, destinationArray: System.Array, length: number) : void;
			 static Copy(sourceArray: System.Array, sourceIndex: number, destinationArray: System.Array, destinationIndex: number, length: number) : void;
			 GetValue(index: number) : any;
			 GetValue(index1: number, index2: number) : any;
			 GetValue(index1: number, index2: number, index3: number) : any;
			 GetValue(...indices: number[]) : any;
			 SetValue(value: any, index: number) : void;
			 SetValue(value: any, index1: number, index2: number) : void;
			 SetValue(value: any, index1: number, index2: number, index3: number) : void;
			 SetValue(value: any, ...indices: number[]) : void;
			 GetLongLength(dimension: number) : number;
			 Clone() : any;
			 static BinarySearch(array: System.Array, value: any) : number;
			 static BinarySearch(array: System.Array, index: number, length: number, value: any) : number;
			 static BinarySearch(array: System.Array, value: any, comparer: System.Collections.IComparer) : number;
			 static BinarySearch(array: System.Array, index: number, length: number, value: any, comparer: System.Collections.IComparer) : number;
			 static BinarySearch(array: any, value: any) : number;
			 static BinarySearch(array: any, value: any, comparer: any) : number;
			 static BinarySearch(array: any, index: number, length: number, value: any) : number;
			 static BinarySearch(array: any, index: number, length: number, value: any, comparer: any) : number;
			 static ConvertAll(array: any, converter: any) : any;
			 CopyTo(array: System.Array, index: number) : void;
			 CopyTo(array: System.Array, index: number) : void;
			 static Empty() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class AsyncCallback extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(ar: System.IAsyncResult) : void;
			 BeginInvoke(ar: System.IAsyncResult, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : void;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		abstract class Attribute {
			TypeId: any;
			 static GetCustomAttributes(element: System.Reflection.MemberInfo, type: System.Type) : any;
			 static GetCustomAttributes(element: System.Reflection.MemberInfo, type: System.Type, inherit: boolean) : any;
			 static GetCustomAttributes(element: System.Reflection.MemberInfo) : any;
			 static GetCustomAttributes(element: System.Reflection.MemberInfo, inherit: boolean) : any;
			 static IsDefined(element: System.Reflection.MemberInfo, attributeType: System.Type) : boolean;
			 static IsDefined(element: System.Reflection.MemberInfo, attributeType: System.Type, inherit: boolean) : boolean;
			 static GetCustomAttribute(element: System.Reflection.MemberInfo, attributeType: System.Type) : System.Attribute;
			 static GetCustomAttribute(element: System.Reflection.MemberInfo, attributeType: System.Type, inherit: boolean) : System.Attribute;
			 static GetCustomAttributes(element: System.Reflection.ParameterInfo) : any;
			 static GetCustomAttributes(element: System.Reflection.ParameterInfo, attributeType: System.Type) : any;
			 static GetCustomAttributes(element: System.Reflection.ParameterInfo, attributeType: System.Type, inherit: boolean) : any;
			 static GetCustomAttributes(element: System.Reflection.ParameterInfo, inherit: boolean) : any;
			 static IsDefined(element: System.Reflection.ParameterInfo, attributeType: System.Type) : boolean;
			 static IsDefined(element: System.Reflection.ParameterInfo, attributeType: System.Type, inherit: boolean) : boolean;
			 static GetCustomAttribute(element: System.Reflection.ParameterInfo, attributeType: System.Type) : System.Attribute;
			 static GetCustomAttribute(element: System.Reflection.ParameterInfo, attributeType: System.Type, inherit: boolean) : System.Attribute;
			 static GetCustomAttributes(element: System.Reflection.Module, attributeType: System.Type) : any;
			 static GetCustomAttributes(element: System.Reflection.Module) : any;
			 static GetCustomAttributes(element: System.Reflection.Module, inherit: boolean) : any;
			 static GetCustomAttributes(element: System.Reflection.Module, attributeType: System.Type, inherit: boolean) : any;
			 static IsDefined(element: System.Reflection.Module, attributeType: System.Type) : boolean;
			 static IsDefined(element: System.Reflection.Module, attributeType: System.Type, inherit: boolean) : boolean;
			 static GetCustomAttribute(element: System.Reflection.Module, attributeType: System.Type) : System.Attribute;
			 static GetCustomAttribute(element: System.Reflection.Module, attributeType: System.Type, inherit: boolean) : System.Attribute;
			 static GetCustomAttributes(element: System.Reflection.Assembly, attributeType: System.Type) : any;
			 static GetCustomAttributes(element: System.Reflection.Assembly, attributeType: System.Type, inherit: boolean) : any;
			 static GetCustomAttributes(element: System.Reflection.Assembly) : any;
			 static GetCustomAttributes(element: System.Reflection.Assembly, inherit: boolean) : any;
			 static IsDefined(element: System.Reflection.Assembly, attributeType: System.Type) : boolean;
			 static IsDefined(element: System.Reflection.Assembly, attributeType: System.Type, inherit: boolean) : boolean;
			 static GetCustomAttribute(element: System.Reflection.Assembly, attributeType: System.Type) : System.Attribute;
			 static GetCustomAttribute(element: System.Reflection.Assembly, attributeType: System.Type, inherit: boolean) : System.Attribute;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class Boolean extends System.ValueType {
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any) : boolean;
			 Equals(obj: any) : boolean;
			 Equals(obj: boolean) : boolean;
			 CompareTo(obj: any) : number;
			 CompareTo(value: boolean) : number;
			 static Parse(value: string) : boolean;
			 static Parse(value: any) : boolean;
			 static TryParse(value: string, result: any) : boolean;
			 static TryParse(value: any, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class Byte extends System.ValueType {
			 CompareTo(value: any) : number;
			 CompareTo(value: System.Byte) : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: System.Byte) : boolean;
			 GetHashCode() : number;
			 static Parse(s: string) : System.Byte;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : System.Byte;
			 static Parse(s: string, provider: System.IFormatProvider) : System.Byte;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : System.Byte;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : System.Byte;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 ToString() : string;
			 ToString(format: string) : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class Char extends System.ValueType {
			 static IsControl(s: string, index: number) : boolean;
			 static IsDigit(s: string, index: number) : boolean;
			 static IsLetter(s: string, index: number) : boolean;
			 static IsLetterOrDigit(s: string, index: number) : boolean;
			 static IsLower(s: string, index: number) : boolean;
			 static IsNumber(c: number) : boolean;
			 static IsNumber(s: string, index: number) : boolean;
			 static IsPunctuation(s: string, index: number) : boolean;
			 static IsSeparator(c: number) : boolean;
			 static IsSeparator(s: string, index: number) : boolean;
			 static IsSurrogate(c: number) : boolean;
			 static IsSurrogate(s: string, index: number) : boolean;
			 static IsSymbol(c: number) : boolean;
			 static IsSymbol(s: string, index: number) : boolean;
			 static IsUpper(s: string, index: number) : boolean;
			 static IsWhiteSpace(s: string, index: number) : boolean;
			 static GetUnicodeCategory(c: number) : System.Globalization.UnicodeCategory;
			 static GetUnicodeCategory(s: string, index: number) : System.Globalization.UnicodeCategory;
			 static GetNumericValue(c: number) : System.Double;
			 static GetNumericValue(s: string, index: number) : System.Double;
			 static IsHighSurrogate(c: number) : boolean;
			 static IsHighSurrogate(s: string, index: number) : boolean;
			 static IsLowSurrogate(c: number) : boolean;
			 static IsLowSurrogate(s: string, index: number) : boolean;
			 static IsSurrogatePair(s: string, index: number) : boolean;
			 static IsSurrogatePair(highSurrogate: number, lowSurrogate: number) : boolean;
			 static ConvertFromUtf32(utf32: number) : string;
			 static ConvertToUtf32(highSurrogate: number, lowSurrogate: number) : number;
			 static ConvertToUtf32(s: string, index: number) : number;
			 GetHashCode() : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: number) : boolean;
			 CompareTo(value: any) : number;
			 CompareTo(value: number) : number;
			 ToString() : string;
			 ToString(provider: System.IFormatProvider) : string;
			 static ToString(c: number) : string;
			 static Parse(s: string) : number;
			 static TryParse(s: string, result: any) : boolean;
			 static IsDigit(c: number) : boolean;
			 static IsLetter(c: number) : boolean;
			 static IsWhiteSpace(c: number) : boolean;
			 static IsUpper(c: number) : boolean;
			 static IsLower(c: number) : boolean;
			 static IsPunctuation(c: number) : boolean;
			 static IsLetterOrDigit(c: number) : boolean;
			 static ToUpper(c: number, culture: System.Globalization.CultureInfo) : number;
			 static ToUpper(c: number) : number;
			 static ToUpperInvariant(c: number) : number;
			 static ToLower(c: number, culture: System.Globalization.CultureInfo) : number;
			 static ToLower(c: number) : number;
			 static ToLowerInvariant(c: number) : number;
			 GetTypeCode() : System.TypeCode;
			 static IsControl(c: number) : boolean;
			 GetType() : System.Type;
		}
		class CharEnumerator {
			Current: number;
			 Clone() : any;
			 MoveNext() : boolean;
			 Dispose() : void;
			 Reset() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class Console {
			 static WriteLine(format: string, arg0: any, arg1: any) : void;
			 static WriteLine(format: string, arg0: any, arg1: any, arg2: any) : void;
			 static WriteLine(format: string, ...arg: any) : void;
			 static Write(format: string, arg0: any) : void;
			 static Write(format: string, arg0: any, arg1: any) : void;
			 static Write(format: string, arg0: any, arg1: any, arg2: any) : void;
			 static Write(format: string, ...arg: any) : void;
			 static Write(value: boolean) : void;
			 static Write(value: number) : void;
			 static Write(buffer: number[]) : void;
			 static Write(buffer: number[], index: number, count: number) : void;
			 static Write(value: System.Double) : void;
			 static Write(value: number) : void;
			 static Write(value: number) : void;
			 static Write(value: number) : void;
			 static Write(value: System.UInt32) : void;
			 static Write(value: number) : void;
			 static Write(value: System.UInt64) : void;
			 static Write(value: any) : void;
			 static Write(value: string) : void;
			 static ReadKey() : System.ConsoleKeyInfo;
			 static ReadKey(intercept: boolean) : System.ConsoleKeyInfo;
			 static ResetColor() : void;
			 static SetBufferSize(width: number, height: number) : void;
			 static SetWindowPosition(left: number, top: number) : void;
			 static SetWindowSize(width: number, height: number) : void;
			 static Beep() : void;
			 static Beep(frequency: number, duration: number) : void;
			 static MoveBufferArea(sourceLeft: number, sourceTop: number, sourceWidth: number, sourceHeight: number, targetLeft: number, targetTop: number) : void;
			 static MoveBufferArea(sourceLeft: number, sourceTop: number, sourceWidth: number, sourceHeight: number, targetLeft: number, targetTop: number, sourceChar: number, sourceForeColor: System.ConsoleColor, sourceBackColor: System.ConsoleColor) : void;
			 static Clear() : void;
			 static SetCursorPosition(left: number, top: number) : void;
			 static add_CancelKeyPress(value: System.ConsoleCancelEventHandler) : void;
			 static remove_CancelKeyPress(value: System.ConsoleCancelEventHandler) : void;
			 static OpenStandardInput() : System.IO.Stream;
			 static OpenStandardInput(bufferSize: number) : System.IO.Stream;
			 static OpenStandardOutput() : System.IO.Stream;
			 static OpenStandardOutput(bufferSize: number) : System.IO.Stream;
			 static OpenStandardError() : System.IO.Stream;
			 static OpenStandardError(bufferSize: number) : System.IO.Stream;
			 static SetIn(newIn: System.IO.TextReader) : void;
			 static SetOut(newOut: System.IO.TextWriter) : void;
			 static SetError(newError: System.IO.TextWriter) : void;
			 static Read() : number;
			 static ReadLine() : string;
			 static WriteLine() : void;
			 static WriteLine(value: boolean) : void;
			 static WriteLine(value: number) : void;
			 static WriteLine(buffer: number[]) : void;
			 static WriteLine(buffer: number[], index: number, count: number) : void;
			 static WriteLine(value: number) : void;
			 static WriteLine(value: System.Double) : void;
			 static WriteLine(value: number) : void;
			 static WriteLine(value: number) : void;
			 static WriteLine(value: System.UInt32) : void;
			 static WriteLine(value: number) : void;
			 static WriteLine(value: System.UInt64) : void;
			 static WriteLine(value: any) : void;
			 static WriteLine(value: string) : void;
			 static WriteLine(format: string, arg0: any) : void;
			 static GetType() : System.Type;
			 static ToString() : string;
			 static Equals(obj: any) : boolean;
			 static GetHashCode() : number;
			static CancelKeyPress: { connect: (callback: (sender: any, e: System.ConsoleCancelEventArgs) => void) => {disconnect: () => void} };
		}
		class ConsoleCancelEventArgs extends System.EventArgs {
			Cancel: boolean;
			SpecialKey: System.ConsoleSpecialKey;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ConsoleCancelEventHandler extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(sender: any, e: System.ConsoleCancelEventArgs) : void;
			 BeginInvoke(sender: any, e: System.ConsoleCancelEventArgs, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : void;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		enum ConsoleColor {
			Black = 0,
			DarkBlue = 1,
			DarkGreen = 2,
			DarkCyan = 3,
			DarkRed = 4,
			DarkMagenta = 5,
			DarkYellow = 6,
			Gray = 7,
			DarkGray = 8,
			Blue = 9,
			Green = 10,
			Cyan = 11,
			Red = 12,
			Magenta = 13,
			Yellow = 14,
			White = 15,
		}
		enum ConsoleKey {
			Backspace = 8,
			Tab = 9,
			Clear = 12,
			Enter = 13,
			Pause = 19,
			Escape = 27,
			Spacebar = 32,
			PageUp = 33,
			PageDown = 34,
			End = 35,
			Home = 36,
			LeftArrow = 37,
			UpArrow = 38,
			RightArrow = 39,
			DownArrow = 40,
			Select = 41,
			Print = 42,
			Execute = 43,
			PrintScreen = 44,
			Insert = 45,
			Delete = 46,
			Help = 47,
			D0 = 48,
			D1 = 49,
			D2 = 50,
			D3 = 51,
			D4 = 52,
			D5 = 53,
			D6 = 54,
			D7 = 55,
			D8 = 56,
			D9 = 57,
			A = 65,
			B = 66,
			C = 67,
			D = 68,
			E = 69,
			F = 70,
			G = 71,
			H = 72,
			I = 73,
			J = 74,
			K = 75,
			L = 76,
			M = 77,
			N = 78,
			O = 79,
			P = 80,
			Q = 81,
			R = 82,
			S = 83,
			T = 84,
			U = 85,
			V = 86,
			W = 87,
			X = 88,
			Y = 89,
			Z = 90,
			LeftWindows = 91,
			RightWindows = 92,
			Applications = 93,
			Sleep = 95,
			NumPad0 = 96,
			NumPad1 = 97,
			NumPad2 = 98,
			NumPad3 = 99,
			NumPad4 = 100,
			NumPad5 = 101,
			NumPad6 = 102,
			NumPad7 = 103,
			NumPad8 = 104,
			NumPad9 = 105,
			Multiply = 106,
			Add = 107,
			Separator = 108,
			Subtract = 109,
			Decimal = 110,
			Divide = 111,
			F1 = 112,
			F2 = 113,
			F3 = 114,
			F4 = 115,
			F5 = 116,
			F6 = 117,
			F7 = 118,
			F8 = 119,
			F9 = 120,
			F10 = 121,
			F11 = 122,
			F12 = 123,
			F13 = 124,
			F14 = 125,
			F15 = 126,
			F16 = 127,
			F17 = 128,
			F18 = 129,
			F19 = 130,
			F20 = 131,
			F21 = 132,
			F22 = 133,
			F23 = 134,
			F24 = 135,
			BrowserBack = 166,
			BrowserForward = 167,
			BrowserRefresh = 168,
			BrowserStop = 169,
			BrowserSearch = 170,
			BrowserFavorites = 171,
			BrowserHome = 172,
			VolumeMute = 173,
			VolumeDown = 174,
			VolumeUp = 175,
			MediaNext = 176,
			MediaPrevious = 177,
			MediaStop = 178,
			MediaPlay = 179,
			LaunchMail = 180,
			LaunchMediaSelect = 181,
			LaunchApp1 = 182,
			LaunchApp2 = 183,
			Oem1 = 186,
			OemPlus = 187,
			OemComma = 188,
			OemMinus = 189,
			OemPeriod = 190,
			Oem2 = 191,
			Oem3 = 192,
			Oem4 = 219,
			Oem5 = 220,
			Oem6 = 221,
			Oem7 = 222,
			Oem8 = 223,
			Oem102 = 226,
			Process = 229,
			Packet = 231,
			Attention = 246,
			CrSel = 247,
			ExSel = 248,
			EraseEndOfFile = 249,
			Play = 250,
			Zoom = 251,
			NoName = 252,
			Pa1 = 253,
			OemClear = 254,
		}
		class ConsoleKeyInfo extends System.ValueType {
			KeyChar: number;
			Key: System.ConsoleKey;
			Modifiers: System.ConsoleModifiers;
			 constructor(keyChar: number, key: System.ConsoleKey, shift: boolean, alt: boolean, control: boolean) ;
			 Equals(value: any) : boolean;
			 Equals(obj: System.ConsoleKeyInfo) : boolean;
			 static op_Equality(a: System.ConsoleKeyInfo, b: System.ConsoleKeyInfo) : boolean;
			 static op_Inequality(a: System.ConsoleKeyInfo, b: System.ConsoleKeyInfo) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		/** Flags */
		enum ConsoleModifiers {
			Alt = 1,
			Shift = 2,
			Control = 4,
		}
		enum ConsoleSpecialKey {
			ControlC = 0,
			ControlBreak = 1,
		}
		class DateTime extends System.ValueType {
			Date: System.DateTime;
			Day: number;
			DayOfWeek: System.DayOfWeek;
			DayOfYear: number;
			Hour: number;
			Kind: System.DateTimeKind;
			Millisecond: number;
			Minute: number;
			Month: number;
			Second: number;
			Ticks: number;
			TimeOfDay: System.TimeSpan;
			Year: number;
			 constructor(ticks: number) ;
			 constructor(ticks: number, kind: System.DateTimeKind) ;
			 constructor(year: number, month: number, day: number) ;
			 constructor(year: number, month: number, day: number, calendar: System.Globalization.Calendar) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, kind: System.DateTimeKind) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, calendar: System.Globalization.Calendar) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, kind: System.DateTimeKind) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: System.Globalization.Calendar) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: System.Globalization.Calendar, kind: System.DateTimeKind) ;
			 static ParseExact(s: any, format: any, provider: System.IFormatProvider, style?: System.Globalization.DateTimeStyles) : System.DateTime;
			 static ParseExact(s: string, formats: string[], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles) : System.DateTime;
			 static ParseExact(s: any, formats: string[], provider: System.IFormatProvider, style?: System.Globalization.DateTimeStyles) : System.DateTime;
			 Subtract(value: System.DateTime) : System.TimeSpan;
			 Subtract(value: System.TimeSpan) : System.DateTime;
			 ToOADate() : System.Double;
			 ToFileTime() : number;
			 ToFileTimeUtc() : number;
			 ToLocalTime() : System.DateTime;
			 ToLongDateString() : string;
			 ToLongTimeString() : string;
			 ToShortDateString() : string;
			 ToShortTimeString() : string;
			 ToString() : string;
			 ToString(format: string) : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 ToUniversalTime() : System.DateTime;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, provider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParse(s: any, provider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParseExact(s: string, format: string, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParseExact(s: any, format: any, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParseExact(s: string, formats: string[], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParseExact(s: any, formats: string[], provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static op_Addition(d: System.DateTime, t: System.TimeSpan) : System.DateTime;
			 static op_Subtraction(d: System.DateTime, t: System.TimeSpan) : System.DateTime;
			 static op_Subtraction(d1: System.DateTime, d2: System.DateTime) : System.TimeSpan;
			 static op_Equality(d1: System.DateTime, d2: System.DateTime) : boolean;
			 static op_Inequality(d1: System.DateTime, d2: System.DateTime) : boolean;
			 static op_LessThan(t1: System.DateTime, t2: System.DateTime) : boolean;
			 static op_LessThanOrEqual(t1: System.DateTime, t2: System.DateTime) : boolean;
			 static op_GreaterThan(t1: System.DateTime, t2: System.DateTime) : boolean;
			 static op_GreaterThanOrEqual(t1: System.DateTime, t2: System.DateTime) : boolean;
			 GetDateTimeFormats() : string[];
			 GetDateTimeFormats(provider: System.IFormatProvider) : string[];
			 GetDateTimeFormats(format: number) : string[];
			 GetDateTimeFormats(format: number, provider: System.IFormatProvider) : string[];
			 GetTypeCode() : System.TypeCode;
			 Add(value: System.TimeSpan) : System.DateTime;
			 AddDays(value: System.Double) : System.DateTime;
			 AddHours(value: System.Double) : System.DateTime;
			 AddMilliseconds(value: System.Double) : System.DateTime;
			 AddMinutes(value: System.Double) : System.DateTime;
			 AddMonths(months: number) : System.DateTime;
			 AddSeconds(value: System.Double) : System.DateTime;
			 AddTicks(value: number) : System.DateTime;
			 AddYears(value: number) : System.DateTime;
			 static Compare(t1: System.DateTime, t2: System.DateTime) : number;
			 CompareTo(value: any) : number;
			 CompareTo(value: System.DateTime) : number;
			 static DaysInMonth(year: number, month: number) : number;
			 Equals(value: any) : boolean;
			 Equals(value: System.DateTime) : boolean;
			 static Equals(t1: System.DateTime, t2: System.DateTime) : boolean;
			 static FromBinary(dateData: number) : System.DateTime;
			 static FromFileTime(fileTime: number) : System.DateTime;
			 static FromFileTimeUtc(fileTime: number) : System.DateTime;
			 static FromOADate(d: System.Double) : System.DateTime;
			 IsDaylightSavingTime() : boolean;
			 static SpecifyKind(value: System.DateTime, kind: System.DateTimeKind) : System.DateTime;
			 ToBinary() : number;
			 GetHashCode() : number;
			 static IsLeapYear(year: number) : boolean;
			 static Parse(s: string) : System.DateTime;
			 static Parse(s: string, provider: System.IFormatProvider) : System.DateTime;
			 static Parse(s: string, provider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles) : System.DateTime;
			 static Parse(s: any, provider?: System.IFormatProvider, styles?: System.Globalization.DateTimeStyles) : System.DateTime;
			 static ParseExact(s: string, format: string, provider: System.IFormatProvider) : System.DateTime;
			 static ParseExact(s: string, format: string, provider: System.IFormatProvider, style: System.Globalization.DateTimeStyles) : System.DateTime;
			 GetType() : System.Type;
		}
		enum DateTimeKind {
			Unspecified = 0,
			Utc = 1,
			Local = 2,
		}
		class DateTimeOffset extends System.ValueType {
			DateTime: System.DateTime;
			UtcDateTime: System.DateTime;
			LocalDateTime: System.DateTime;
			Date: System.DateTime;
			Day: number;
			DayOfWeek: System.DayOfWeek;
			DayOfYear: number;
			Hour: number;
			Millisecond: number;
			Minute: number;
			Month: number;
			Offset: System.TimeSpan;
			Second: number;
			Ticks: number;
			UtcTicks: number;
			TimeOfDay: System.TimeSpan;
			Year: number;
			 constructor(ticks: number, offset: System.TimeSpan) ;
			 constructor(dateTime: System.DateTime) ;
			 constructor(dateTime: System.DateTime, offset: System.TimeSpan) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, offset: System.TimeSpan) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, offset: System.TimeSpan) ;
			 constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: System.Globalization.Calendar, offset: System.TimeSpan) ;
			 static TryParse(input: any, result: any) : boolean;
			 static TryParse(input: string, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParse(input: any, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParseExact(input: string, format: string, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParseExact(input: any, format: any, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParseExact(input: string, formats: string[], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static TryParseExact(input: any, formats: string[], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles, result: any) : boolean;
			 static op_Implicit(dateTime: System.DateTime) : System.DateTimeOffset;
			 static op_Addition(dateTimeOffset: System.DateTimeOffset, timeSpan: System.TimeSpan) : System.DateTimeOffset;
			 static op_Subtraction(dateTimeOffset: System.DateTimeOffset, timeSpan: System.TimeSpan) : System.DateTimeOffset;
			 static op_Subtraction(left: System.DateTimeOffset, right: System.DateTimeOffset) : System.TimeSpan;
			 static op_Equality(left: System.DateTimeOffset, right: System.DateTimeOffset) : boolean;
			 static op_Inequality(left: System.DateTimeOffset, right: System.DateTimeOffset) : boolean;
			 static op_LessThan(left: System.DateTimeOffset, right: System.DateTimeOffset) : boolean;
			 static op_LessThanOrEqual(left: System.DateTimeOffset, right: System.DateTimeOffset) : boolean;
			 static op_GreaterThan(left: System.DateTimeOffset, right: System.DateTimeOffset) : boolean;
			 static op_GreaterThanOrEqual(left: System.DateTimeOffset, right: System.DateTimeOffset) : boolean;
			 ToOffset(offset: System.TimeSpan) : System.DateTimeOffset;
			 Add(timeSpan: System.TimeSpan) : System.DateTimeOffset;
			 AddDays(days: System.Double) : System.DateTimeOffset;
			 AddHours(hours: System.Double) : System.DateTimeOffset;
			 AddMilliseconds(milliseconds: System.Double) : System.DateTimeOffset;
			 AddMinutes(minutes: System.Double) : System.DateTimeOffset;
			 AddMonths(months: number) : System.DateTimeOffset;
			 AddSeconds(seconds: System.Double) : System.DateTimeOffset;
			 AddTicks(ticks: number) : System.DateTimeOffset;
			 AddYears(years: number) : System.DateTimeOffset;
			 static Compare(first: System.DateTimeOffset, second: System.DateTimeOffset) : number;
			 CompareTo(other: System.DateTimeOffset) : number;
			 Equals(obj: any) : boolean;
			 Equals(other: System.DateTimeOffset) : boolean;
			 EqualsExact(other: System.DateTimeOffset) : boolean;
			 static Equals(first: System.DateTimeOffset, second: System.DateTimeOffset) : boolean;
			 static FromFileTime(fileTime: number) : System.DateTimeOffset;
			 static FromUnixTimeSeconds(seconds: number) : System.DateTimeOffset;
			 static FromUnixTimeMilliseconds(milliseconds: number) : System.DateTimeOffset;
			 GetHashCode() : number;
			 static Parse(input: string) : System.DateTimeOffset;
			 static Parse(input: string, formatProvider: System.IFormatProvider) : System.DateTimeOffset;
			 static Parse(input: string, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles) : System.DateTimeOffset;
			 static Parse(input: any, formatProvider?: System.IFormatProvider, styles?: System.Globalization.DateTimeStyles) : System.DateTimeOffset;
			 static ParseExact(input: string, format: string, formatProvider: System.IFormatProvider) : System.DateTimeOffset;
			 static ParseExact(input: string, format: string, formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles) : System.DateTimeOffset;
			 static ParseExact(input: any, format: any, formatProvider: System.IFormatProvider, styles?: System.Globalization.DateTimeStyles) : System.DateTimeOffset;
			 static ParseExact(input: string, formats: string[], formatProvider: System.IFormatProvider, styles: System.Globalization.DateTimeStyles) : System.DateTimeOffset;
			 static ParseExact(input: any, formats: string[], formatProvider: System.IFormatProvider, styles?: System.Globalization.DateTimeStyles) : System.DateTimeOffset;
			 Subtract(value: System.DateTimeOffset) : System.TimeSpan;
			 Subtract(value: System.TimeSpan) : System.DateTimeOffset;
			 ToFileTime() : number;
			 ToUnixTimeSeconds() : number;
			 ToUnixTimeMilliseconds() : number;
			 ToLocalTime() : System.DateTimeOffset;
			 ToString() : string;
			 ToString(format: string) : string;
			 ToString(formatProvider: System.IFormatProvider) : string;
			 ToString(format: string, formatProvider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, formatProvider?: System.IFormatProvider) : boolean;
			 ToUniversalTime() : System.DateTimeOffset;
			 static TryParse(input: string, result: any) : boolean;
			 GetType() : System.Type;
		}
		enum DayOfWeek {
			Sunday = 0,
			Monday = 1,
			Tuesday = 2,
			Wednesday = 3,
			Thursday = 4,
			Friday = 5,
			Saturday = 6,
		}
		class Decimal extends System.ValueType {
			 constructor(value: number) ;
			 constructor(value: System.UInt32) ;
			 constructor(value: number) ;
			 constructor(value: System.UInt64) ;
			 constructor(value: number) ;
			 constructor(value: System.Double) ;
			 constructor(bits: number[]) ;
			 constructor(bits: any) ;
			 constructor(lo: number, mid: number, hi: number, isNegative: boolean, scale: System.Byte) ;
			 static op_Implicit(value: System.UInt32) : number;
			 static op_Implicit(value: number) : number;
			 static op_Implicit(value: System.UInt64) : number;
			 static op_Explicit(value: number) : number;
			 static op_Explicit(value: System.Double) : number;
			 static op_Explicit(value: number) : System.Byte;
			 static op_Explicit(value: number) : System.SByte;
			 static op_Explicit(value: number) : number;
			 static op_Explicit(value: number) : number;
			 static op_Explicit(value: number) : System.UInt16;
			 static op_Explicit(value: number) : number;
			 static op_Explicit(value: number) : System.UInt32;
			 static op_Explicit(value: number) : number;
			 static op_Explicit(value: number) : System.UInt64;
			 static op_Explicit(value: number) : number;
			 static op_Explicit(value: number) : System.Double;
			 static op_UnaryPlus(d: number) : number;
			 static op_UnaryNegation(d: number) : number;
			 static op_Increment(d: number) : number;
			 static op_Decrement(d: number) : number;
			 static op_Addition(d1: number, d2: number) : number;
			 static op_Subtraction(d1: number, d2: number) : number;
			 static op_Multiply(d1: number, d2: number) : number;
			 static op_Division(d1: number, d2: number) : number;
			 static op_Modulus(d1: number, d2: number) : number;
			 static op_Equality(d1: number, d2: number) : boolean;
			 static op_Inequality(d1: number, d2: number) : boolean;
			 static op_LessThan(d1: number, d2: number) : boolean;
			 static op_LessThanOrEqual(d1: number, d2: number) : boolean;
			 static op_GreaterThan(d1: number, d2: number) : boolean;
			 static op_GreaterThanOrEqual(d1: number, d2: number) : boolean;
			 GetTypeCode() : System.TypeCode;
			 static FromOACurrency(cy: number) : number;
			 static ToOACurrency(value: number) : number;
			 static Add(d1: number, d2: number) : number;
			 static Ceiling(d: number) : number;
			 static Compare(d1: number, d2: number) : number;
			 CompareTo(value: any) : number;
			 CompareTo(value: number) : number;
			 static Divide(d1: number, d2: number) : number;
			 Equals(value: any) : boolean;
			 Equals(value: number) : boolean;
			 GetHashCode() : number;
			 static Equals(d1: number, d2: number) : boolean;
			 static Floor(d: number) : number;
			 ToString() : string;
			 ToString(format: string) : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : number;
			 static Parse(s: string, provider: System.IFormatProvider) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : number;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : number;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static GetBits(d: number) : number[];
			 static GetBits(d: number, destination: any) : number;
			 static TryGetBits(d: number, destination: any, valuesWritten: any) : boolean;
			 static Remainder(d1: number, d2: number) : number;
			 static Multiply(d1: number, d2: number) : number;
			 static Negate(d: number) : number;
			 static Round(d: number) : number;
			 static Round(d: number, decimals: number) : number;
			 static Round(d: number, mode: System.MidpointRounding) : number;
			 static Round(d: number, decimals: number, mode: System.MidpointRounding) : number;
			 static Subtract(d1: number, d2: number) : number;
			 static ToByte(value: number) : System.Byte;
			 static ToSByte(value: number) : System.SByte;
			 static ToInt16(value: number) : number;
			 static ToDouble(d: number) : System.Double;
			 static ToInt32(d: number) : number;
			 static ToInt64(d: number) : number;
			 static ToUInt16(value: number) : System.UInt16;
			 static ToUInt32(d: number) : System.UInt32;
			 static ToUInt64(d: number) : System.UInt64;
			 static ToSingle(d: number) : number;
			 static Truncate(d: number) : number;
			 static op_Implicit(value: System.Byte) : number;
			 static op_Implicit(value: System.SByte) : number;
			 static op_Implicit(value: number) : number;
			 static op_Implicit(value: System.UInt16) : number;
			 static op_Implicit(value: number) : number;
			 static op_Implicit(value: number) : number;
			 GetType() : System.Type;
		}
		abstract class Delegate {
			Target: any;
			Method: System.Reflection.MethodInfo;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static CreateDelegate(type: System.Type, target: any, method: string, ignoreCase: boolean, throwOnBindFailure: boolean) : System.Delegate;
			 static CreateDelegate(type: System.Type, target: System.Type, method: string, ignoreCase: boolean, throwOnBindFailure: boolean) : System.Delegate;
			 static CreateDelegate(type: System.Type, method: System.Reflection.MethodInfo, throwOnBindFailure: boolean) : System.Delegate;
			 static CreateDelegate(type: System.Type, firstArgument: any, method: System.Reflection.MethodInfo, throwOnBindFailure: boolean) : System.Delegate;
			 Clone() : any;
			 static Combine(a: System.Delegate, b: System.Delegate) : System.Delegate;
			 static Combine(...delegates: any) : System.Delegate;
			 static CreateDelegate(type: System.Type, firstArgument: any, method: System.Reflection.MethodInfo) : System.Delegate;
			 static CreateDelegate(type: System.Type, method: System.Reflection.MethodInfo) : System.Delegate;
			 static CreateDelegate(type: System.Type, target: any, method: string) : System.Delegate;
			 static CreateDelegate(type: System.Type, target: any, method: string, ignoreCase: boolean) : System.Delegate;
			 static CreateDelegate(type: System.Type, target: System.Type, method: string) : System.Delegate;
			 static CreateDelegate(type: System.Type, target: System.Type, method: string, ignoreCase: boolean) : System.Delegate;
			 GetInvocationList() : any;
			 DynamicInvoke(...args: any) : any;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 static Remove(source: System.Delegate, value: System.Delegate) : System.Delegate;
			 static RemoveAll(source: System.Delegate, value: System.Delegate) : System.Delegate;
			 static op_Equality(d1: System.Delegate, d2: System.Delegate) : boolean;
			 static op_Inequality(d1: System.Delegate, d2: System.Delegate) : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class Double extends System.ValueType {
			 static IsFinite(d: System.Double) : boolean;
			 static IsInfinity(d: System.Double) : boolean;
			 static IsNaN(d: System.Double) : boolean;
			 static IsNegative(d: System.Double) : boolean;
			 static IsNegativeInfinity(d: System.Double) : boolean;
			 static IsNormal(d: System.Double) : boolean;
			 static IsPositiveInfinity(d: System.Double) : boolean;
			 static IsSubnormal(d: System.Double) : boolean;
			 CompareTo(value: any) : number;
			 CompareTo(value: System.Double) : number;
			 Equals(obj: any) : boolean;
			 static op_Equality(left: System.Double, right: System.Double) : boolean;
			 static op_Inequality(left: System.Double, right: System.Double) : boolean;
			 static op_LessThan(left: System.Double, right: System.Double) : boolean;
			 static op_GreaterThan(left: System.Double, right: System.Double) : boolean;
			 static op_LessThanOrEqual(left: System.Double, right: System.Double) : boolean;
			 static op_GreaterThanOrEqual(left: System.Double, right: System.Double) : boolean;
			 Equals(obj: System.Double) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(format: string) : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : System.Double;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : System.Double;
			 static Parse(s: string, provider: System.IFormatProvider) : System.Double;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : System.Double;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : System.Double;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		abstract class Enum extends System.ValueType {
			 Equals(obj: any) : boolean;
			 HasFlag(flag: System.Enum) : boolean;
			 static GetName(enumType: System.Type, value: any) : string;
			 static GetNames(enumType: System.Type) : string[];
			 static GetUnderlyingType(enumType: System.Type) : System.Type;
			 static GetValues(enumType: System.Type) : System.Array;
			 static IsDefined(enumType: System.Type, value: any) : boolean;
			 static Parse(enumType: System.Type, value: string) : any;
			 static Parse(enumType: System.Type, value: string, ignoreCase: boolean) : any;
			 static Parse(value: string) : any;
			 static Parse(value: string, ignoreCase: boolean) : any;
			 static TryParse(enumType: System.Type, value: string, result: any) : boolean;
			 static TryParse(enumType: System.Type, value: string, ignoreCase: boolean, result: any) : boolean;
			 static TryParse(value: string, result: any) : boolean;
			 static TryParse(value: string, ignoreCase: boolean, result: any) : boolean;
			 static ToObject(enumType: System.Type, value: any) : any;
			 static Format(enumType: System.Type, value: any, format: string) : string;
			 GetHashCode() : number;
			 ToString() : string;
			 CompareTo(target: any) : number;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 ToString(format: string) : string;
			 ToString(provider: System.IFormatProvider) : string;
			 GetTypeCode() : System.TypeCode;
			 static ToObject(enumType: System.Type, value: System.SByte) : any;
			 static ToObject(enumType: System.Type, value: number) : any;
			 static ToObject(enumType: System.Type, value: number) : any;
			 static ToObject(enumType: System.Type, value: System.Byte) : any;
			 static ToObject(enumType: System.Type, value: System.UInt16) : any;
			 static ToObject(enumType: System.Type, value: System.UInt32) : any;
			 static ToObject(enumType: System.Type, value: number) : any;
			 static ToObject(enumType: System.Type, value: System.UInt64) : any;
			 GetType() : System.Type;
		}
		class EventArgs {
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class Exception {
			TargetSite: System.Reflection.MethodBase;
			StackTrace: string;
			Message: string;
			Data: System.Collections.IDictionary;
			InnerException: System.Exception;
			HelpLink: string;
			Source: string;
			HResult: number;
			 constructor() ;
			 constructor(message: string) ;
			 constructor(message: string, innerException: System.Exception) ;
			 GetBaseException() : System.Exception;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 ToString() : string;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class Guid extends System.ValueType {
			 constructor(b: any) ;
			 constructor(b: any) ;
			 constructor(a: System.UInt32, b: System.UInt16, c: System.UInt16, d: System.Byte, e: System.Byte, f: System.Byte, g: System.Byte, h: System.Byte, i: System.Byte, j: System.Byte, k: System.Byte) ;
			 constructor(a: number, b: number, c: number, d: any) ;
			 constructor(a: number, b: number, c: number, d: System.Byte, e: System.Byte, f: System.Byte, g: System.Byte, h: System.Byte, i: System.Byte, j: System.Byte, k: System.Byte) ;
			 constructor(g: string) ;
			 static Parse(input: string) : System.Guid;
			 static Parse(input: any) : System.Guid;
			 static TryParse(input: string, result: any) : boolean;
			 static TryParse(input: any, result: any) : boolean;
			 static ParseExact(input: string, format: string) : System.Guid;
			 static ParseExact(input: any, format: any) : System.Guid;
			 static TryParseExact(input: string, format: string, result: any) : boolean;
			 static TryParseExact(input: any, format: any, result: any) : boolean;
			 ToByteArray() : any;
			 TryWriteBytes(destination: any) : boolean;
			 ToString() : string;
			 GetHashCode() : number;
			 Equals(o: any) : boolean;
			 Equals(g: System.Guid) : boolean;
			 CompareTo(value: any) : number;
			 CompareTo(value: System.Guid) : number;
			 static op_Equality(a: System.Guid, b: System.Guid) : boolean;
			 static op_Inequality(a: System.Guid, b: System.Guid) : boolean;
			 ToString(format: string) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any) : boolean;
			 static NewGuid() : System.Guid;
			 GetType() : System.Type;
		}
		interface IAsyncResult {
			IsCompleted: boolean;
			AsyncWaitHandle: System.Threading.WaitHandle;
			AsyncState: any;
			CompletedSynchronously: boolean;
		}
		interface IDisposable {
			 Dispose() : void;
		}
		interface IFormatProvider {
			 GetFormat(formatType: System.Type) : any;
		}
		class Int16 extends System.ValueType {
			 CompareTo(value: any) : number;
			 CompareTo(value: number) : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: number) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : number;
			 static Parse(s: string, provider: System.IFormatProvider) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : number;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : number;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class Int32 extends System.ValueType {
			 CompareTo(value: any) : number;
			 CompareTo(value: number) : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: number) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(format: string) : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : number;
			 static Parse(s: string, provider: System.IFormatProvider) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : number;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : number;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class Int64 extends System.ValueType {
			 CompareTo(value: any) : number;
			 CompareTo(value: number) : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: number) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : number;
			 static Parse(s: string, provider: System.IFormatProvider) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : number;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : number;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class IntPtr extends System.ValueType {
			 constructor(value: number) ;
			 constructor(value: number) ;
			 constructor(value: any) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToInt32() : number;
			 ToInt64() : number;
			 static op_Explicit(value: number) : System.IntPtr;
			 static op_Explicit(value: number) : System.IntPtr;
			 static op_Explicit(value: any) : System.IntPtr;
			 static op_Explicit(value: System.IntPtr) : any;
			 static op_Explicit(value: System.IntPtr) : number;
			 static op_Explicit(value: System.IntPtr) : number;
			 static op_Equality(value1: System.IntPtr, value2: System.IntPtr) : boolean;
			 static op_Inequality(value1: System.IntPtr, value2: System.IntPtr) : boolean;
			 static Add(pointer: System.IntPtr, offset: number) : System.IntPtr;
			 static op_Addition(pointer: System.IntPtr, offset: number) : System.IntPtr;
			 static Subtract(pointer: System.IntPtr, offset: number) : System.IntPtr;
			 static op_Subtraction(pointer: System.IntPtr, offset: number) : System.IntPtr;
			 ToPointer() : any;
			 CompareTo(value: any) : number;
			 CompareTo(value: System.IntPtr) : number;
			 Equals(other: System.IntPtr) : boolean;
			 ToString() : string;
			 ToString(format: string) : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 static Parse(s: string) : System.IntPtr;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : System.IntPtr;
			 static Parse(s: string, provider: System.IFormatProvider) : System.IntPtr;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : System.IntPtr;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetType() : System.Type;
		}
		class InvalidOperationException extends System.SystemException {
			 constructor() ;
			 constructor(message: string) ;
			 constructor(message: string, innerException: System.Exception) ;
			 GetBaseException() : System.Exception;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 ToString() : string;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class MarshalByRefObject {
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum MidpointRounding {
			ToEven = 0,
			AwayFromZero = 1,
			ToZero = 2,
			ToNegativeInfinity = 3,
			ToPositiveInfinity = 4,
		}
		class ModuleHandle extends System.ValueType {
			MDStreamVersion: number;
			 GetHashCode() : number;
			 Equals(obj: any) : boolean;
			 Equals(handle: System.ModuleHandle) : boolean;
			 static op_Equality(left: System.ModuleHandle, right: System.ModuleHandle) : boolean;
			 static op_Inequality(left: System.ModuleHandle, right: System.ModuleHandle) : boolean;
			 GetRuntimeTypeHandleFromMetadataToken(typeToken: number) : System.RuntimeTypeHandle;
			 ResolveTypeHandle(typeToken: number) : System.RuntimeTypeHandle;
			 ResolveTypeHandle(typeToken: number, typeInstantiationContext: any, methodInstantiationContext: any) : System.RuntimeTypeHandle;
			 GetRuntimeMethodHandleFromMetadataToken(methodToken: number) : System.RuntimeMethodHandle;
			 ResolveMethodHandle(methodToken: number) : System.RuntimeMethodHandle;
			 ResolveMethodHandle(methodToken: number, typeInstantiationContext: any, methodInstantiationContext: any) : System.RuntimeMethodHandle;
			 GetRuntimeFieldHandleFromMetadataToken(fieldToken: number) : System.RuntimeFieldHandle;
			 ResolveFieldHandle(fieldToken: number) : System.RuntimeFieldHandle;
			 ResolveFieldHandle(fieldToken: number, typeInstantiationContext: any, methodInstantiationContext: any) : System.RuntimeFieldHandle;
			 ToString() : string;
			 GetType() : System.Type;
		}
		abstract class MulticastDelegate extends System.Delegate {
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 static op_Equality(d1: System.MulticastDelegate, d2: System.MulticastDelegate) : boolean;
			 static op_Inequality(d1: System.MulticastDelegate, d2: System.MulticastDelegate) : boolean;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class ResolveEventArgs extends System.EventArgs {
			Name: string;
			RequestingAssembly: System.Reflection.Assembly;
			 constructor(name: string) ;
			 constructor(name: string, requestingAssembly: System.Reflection.Assembly) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class RuntimeFieldHandle extends System.ValueType {
			Value: System.IntPtr;
			 GetHashCode() : number;
			 Equals(obj: any) : boolean;
			 Equals(handle: System.RuntimeFieldHandle) : boolean;
			 static op_Equality(left: System.RuntimeFieldHandle, right: System.RuntimeFieldHandle) : boolean;
			 static op_Inequality(left: System.RuntimeFieldHandle, right: System.RuntimeFieldHandle) : boolean;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class RuntimeMethodHandle extends System.ValueType {
			Value: System.IntPtr;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 GetHashCode() : number;
			 Equals(obj: any) : boolean;
			 static op_Equality(left: System.RuntimeMethodHandle, right: System.RuntimeMethodHandle) : boolean;
			 static op_Inequality(left: System.RuntimeMethodHandle, right: System.RuntimeMethodHandle) : boolean;
			 Equals(handle: System.RuntimeMethodHandle) : boolean;
			 GetFunctionPointer() : System.IntPtr;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class RuntimeTypeHandle extends System.ValueType {
			Value: System.IntPtr;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 static op_Equality(left: System.RuntimeTypeHandle, right: any) : boolean;
			 static op_Equality(left: any, right: System.RuntimeTypeHandle) : boolean;
			 static op_Inequality(left: System.RuntimeTypeHandle, right: any) : boolean;
			 static op_Inequality(left: any, right: System.RuntimeTypeHandle) : boolean;
			 GetHashCode() : number;
			 Equals(obj: any) : boolean;
			 Equals(handle: System.RuntimeTypeHandle) : boolean;
			 GetModuleHandle() : System.ModuleHandle;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class SByte extends System.ValueType {
			 CompareTo(obj: any) : number;
			 CompareTo(value: System.SByte) : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: System.SByte) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(format: string) : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : System.SByte;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : System.SByte;
			 static Parse(s: string, provider: System.IFormatProvider) : System.SByte;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : System.SByte;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : System.SByte;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class Single extends System.ValueType {
			 static IsFinite(f: number) : boolean;
			 static IsInfinity(f: number) : boolean;
			 static IsNaN(f: number) : boolean;
			 static IsNegative(f: number) : boolean;
			 static IsNegativeInfinity(f: number) : boolean;
			 static IsNormal(f: number) : boolean;
			 static IsPositiveInfinity(f: number) : boolean;
			 static IsSubnormal(f: number) : boolean;
			 CompareTo(value: any) : number;
			 CompareTo(value: number) : number;
			 static op_Equality(left: number, right: number) : boolean;
			 static op_Inequality(left: number, right: number) : boolean;
			 static op_LessThan(left: number, right: number) : boolean;
			 static op_GreaterThan(left: number, right: number) : boolean;
			 static op_LessThanOrEqual(left: number, right: number) : boolean;
			 static op_GreaterThanOrEqual(left: number, right: number) : boolean;
			 Equals(obj: any) : boolean;
			 Equals(obj: number) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : number;
			 static Parse(s: string, provider: System.IFormatProvider) : number;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : number;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : number;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class String {
			Chars: number;
			Length: number;
			 constructor(value: number[]) ;
			 constructor(value: number[], startIndex: number, length: number) ;
			 constructor(value: any) ;
			 constructor(value: any, startIndex: number, length: number) ;
			 constructor(value: any) ;
			 constructor(value: any, startIndex: number, length: number) ;
			 constructor(value: any, startIndex: number, length: number, enc: System.Text.Encoding) ;
			 constructor(c: number, count: number) ;
			 constructor(value: any) ;
			 Replace(oldChar: number, newChar: number) : string;
			 Replace(oldValue: string, newValue: string) : string;
			 Split(separator: number, options?: System.StringSplitOptions) : string[];
			 Split(separator: number, count: number, options?: System.StringSplitOptions) : string[];
			 Split(...separator: number[]) : string[];
			 Split(separator: number[], count: number) : string[];
			 Split(separator: number[], options: System.StringSplitOptions) : string[];
			 Split(separator: number[], count: number, options: System.StringSplitOptions) : string[];
			 Split(separator: string, options?: System.StringSplitOptions) : string[];
			 Split(separator: string, count: number, options?: System.StringSplitOptions) : string[];
			 Split(separator: string[], options: System.StringSplitOptions) : string[];
			 Split(separator: string[], count: number, options: System.StringSplitOptions) : string[];
			 Substring(startIndex: number) : string;
			 Substring(startIndex: number, length: number) : string;
			 ToLower() : string;
			 ToLower(culture: System.Globalization.CultureInfo) : string;
			 ToLowerInvariant() : string;
			 ToUpper() : string;
			 ToUpper(culture: System.Globalization.CultureInfo) : string;
			 ToUpperInvariant() : string;
			 Trim() : string;
			 Trim(trimChar: number) : string;
			 Trim(...trimChars: number[]) : string;
			 TrimStart() : string;
			 TrimStart(trimChar: number) : string;
			 TrimStart(...trimChars: number[]) : string;
			 TrimEnd() : string;
			 TrimEnd(trimChar: number) : string;
			 TrimEnd(...trimChars: number[]) : string;
			 Contains(value: string) : boolean;
			 Contains(value: string, comparisonType: System.StringComparison) : boolean;
			 Contains(value: number) : boolean;
			 Contains(value: number, comparisonType: System.StringComparison) : boolean;
			 IndexOf(value: number) : number;
			 IndexOf(value: number, startIndex: number) : number;
			 IndexOf(value: number, comparisonType: System.StringComparison) : number;
			 IndexOf(value: number, startIndex: number, count: number) : number;
			 IndexOfAny(anyOf: number[]) : number;
			 IndexOfAny(anyOf: number[], startIndex: number) : number;
			 IndexOfAny(anyOf: number[], startIndex: number, count: number) : number;
			 IndexOf(value: string) : number;
			 IndexOf(value: string, startIndex: number) : number;
			 IndexOf(value: string, startIndex: number, count: number) : number;
			 IndexOf(value: string, comparisonType: System.StringComparison) : number;
			 IndexOf(value: string, startIndex: number, comparisonType: System.StringComparison) : number;
			 IndexOf(value: string, startIndex: number, count: number, comparisonType: System.StringComparison) : number;
			 LastIndexOf(value: number) : number;
			 LastIndexOf(value: number, startIndex: number) : number;
			 LastIndexOf(value: number, startIndex: number, count: number) : number;
			 LastIndexOfAny(anyOf: number[]) : number;
			 LastIndexOfAny(anyOf: number[], startIndex: number) : number;
			 LastIndexOfAny(anyOf: number[], startIndex: number, count: number) : number;
			 LastIndexOf(value: string) : number;
			 LastIndexOf(value: string, startIndex: number) : number;
			 LastIndexOf(value: string, startIndex: number, count: number) : number;
			 LastIndexOf(value: string, comparisonType: System.StringComparison) : number;
			 LastIndexOf(value: string, startIndex: number, comparisonType: System.StringComparison) : number;
			 LastIndexOf(value: string, startIndex: number, count: number, comparisonType: System.StringComparison) : number;
			 ToString() : string;
			 ToString(provider: System.IFormatProvider) : string;
			 GetEnumerator() : System.CharEnumerator;
			 EnumerateRunes() : System.Text.StringRuneEnumerator;
			 GetTypeCode() : System.TypeCode;
			 IsNormalized() : boolean;
			 IsNormalized(normalizationForm: System.Text.NormalizationForm) : boolean;
			 Normalize() : string;
			 Normalize(normalizationForm: System.Text.NormalizationForm) : string;
			 static Concat(arg0: any) : string;
			 static Concat(arg0: any, arg1: any) : string;
			 static Concat(arg0: any, arg1: any, arg2: any) : string;
			 static Concat(...args: any) : string;
			 static Concat(values: any) : string;
			 static Concat(values: any) : string;
			 static Concat(str0: string, str1: string) : string;
			 static Concat(str0: string, str1: string, str2: string) : string;
			 static Concat(str0: string, str1: string, str2: string, str3: string) : string;
			 static Concat(str0: any, str1: any) : string;
			 static Concat(str0: any, str1: any, str2: any) : string;
			 static Concat(str0: any, str1: any, str2: any, str3: any) : string;
			 static Concat(...values: string[]) : string;
			 static Format(format: string, arg0: any) : string;
			 static Format(format: string, arg0: any, arg1: any) : string;
			 static Format(format: string, arg0: any, arg1: any, arg2: any) : string;
			 static Format(format: string, ...args: any) : string;
			 static Format(provider: System.IFormatProvider, format: string, arg0: any) : string;
			 static Format(provider: System.IFormatProvider, format: string, arg0: any, arg1: any) : string;
			 static Format(provider: System.IFormatProvider, format: string, arg0: any, arg1: any, arg2: any) : string;
			 static Format(provider: System.IFormatProvider, format: string, ...args: any) : string;
			 Insert(startIndex: number, value: string) : string;
			 static Join(separator: number, ...value: string[]) : string;
			 static Join(separator: number, ...values: any) : string;
			 static Join(separator: number, values: any) : string;
			 static Join(separator: number, value: string[], startIndex: number, count: number) : string;
			 static Join(separator: string, ...value: string[]) : string;
			 static Join(separator: string, ...values: any) : string;
			 static Join(separator: string, values: any) : string;
			 static Join(separator: string, values: any) : string;
			 static Join(separator: string, value: string[], startIndex: number, count: number) : string;
			 PadLeft(totalWidth: number) : string;
			 PadLeft(totalWidth: number, paddingChar: number) : string;
			 PadRight(totalWidth: number) : string;
			 PadRight(totalWidth: number, paddingChar: number) : string;
			 Remove(startIndex: number, count: number) : string;
			 Remove(startIndex: number) : string;
			 Replace(oldValue: string, newValue: string, ignoreCase: boolean, culture: System.Globalization.CultureInfo) : string;
			 Replace(oldValue: string, newValue: string, comparisonType: System.StringComparison) : string;
			 static Intern(str: string) : string;
			 static IsInterned(str: string) : string;
			 static Compare(strA: string, strB: string) : number;
			 static Compare(strA: string, strB: string, ignoreCase: boolean) : number;
			 static Compare(strA: string, strB: string, comparisonType: System.StringComparison) : number;
			 static Compare(strA: string, strB: string, culture: System.Globalization.CultureInfo, options: System.Globalization.CompareOptions) : number;
			 static Compare(strA: string, strB: string, ignoreCase: boolean, culture: System.Globalization.CultureInfo) : number;
			 static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number) : number;
			 static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, ignoreCase: boolean) : number;
			 static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, ignoreCase: boolean, culture: System.Globalization.CultureInfo) : number;
			 static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, culture: System.Globalization.CultureInfo, options: System.Globalization.CompareOptions) : number;
			 static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, comparisonType: System.StringComparison) : number;
			 static CompareOrdinal(strA: string, strB: string) : number;
			 static CompareOrdinal(strA: string, indexA: number, strB: string, indexB: number, length: number) : number;
			 CompareTo(value: any) : number;
			 CompareTo(strB: string) : number;
			 EndsWith(value: string) : boolean;
			 EndsWith(value: string, comparisonType: System.StringComparison) : boolean;
			 EndsWith(value: string, ignoreCase: boolean, culture: System.Globalization.CultureInfo) : boolean;
			 EndsWith(value: number) : boolean;
			 Equals(obj: any) : boolean;
			 Equals(value: string) : boolean;
			 Equals(value: string, comparisonType: System.StringComparison) : boolean;
			 static Equals(a: string, b: string) : boolean;
			 static Equals(a: string, b: string, comparisonType: System.StringComparison) : boolean;
			 static op_Equality(a: string, b: string) : boolean;
			 static op_Inequality(a: string, b: string) : boolean;
			 GetHashCode() : number;
			 GetHashCode(comparisonType: System.StringComparison) : number;
			 static GetHashCode(value: any) : number;
			 static GetHashCode(value: any, comparisonType: System.StringComparison) : number;
			 StartsWith(value: string) : boolean;
			 StartsWith(value: string, comparisonType: System.StringComparison) : boolean;
			 StartsWith(value: string, ignoreCase: boolean, culture: System.Globalization.CultureInfo) : boolean;
			 StartsWith(value: number) : boolean;
			 static Create(length: number, state: any, action: any) : string;
			 static op_Implicit(value: string) : any;
			 Clone() : any;
			 static Copy(str: string) : string;
			 CopyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number) : void;
			 ToCharArray() : number[];
			 ToCharArray(startIndex: number, length: number) : number[];
			 static IsNullOrEmpty(value: string) : boolean;
			 static IsNullOrWhiteSpace(value: string) : boolean;
			 GetPinnableReference() : any;
			 GetType() : System.Type;
		}
		enum StringComparison {
			CurrentCulture = 0,
			CurrentCultureIgnoreCase = 1,
			InvariantCulture = 2,
			InvariantCultureIgnoreCase = 3,
			Ordinal = 4,
			OrdinalIgnoreCase = 5,
		}
		/** Flags */
		enum StringSplitOptions {
			None = 0,
			RemoveEmptyEntries = 1,
		}
		class SystemException extends System.Exception {
			 constructor() ;
			 constructor(message: string) ;
			 constructor(message: string, innerException: System.Exception) ;
			 GetBaseException() : System.Exception;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 ToString() : string;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class TimeSpan extends System.ValueType {
			Ticks: number;
			Days: number;
			Hours: number;
			Milliseconds: number;
			Minutes: number;
			Seconds: number;
			TotalDays: System.Double;
			TotalHours: System.Double;
			TotalMilliseconds: System.Double;
			TotalMinutes: System.Double;
			TotalSeconds: System.Double;
			 constructor(ticks: number) ;
			 constructor(hours: number, minutes: number, seconds: number) ;
			 constructor(days: number, hours: number, minutes: number, seconds: number) ;
			 constructor(days: number, hours: number, minutes: number, seconds: number, milliseconds: number) ;
			 Add(ts: System.TimeSpan) : System.TimeSpan;
			 static Compare(t1: System.TimeSpan, t2: System.TimeSpan) : number;
			 CompareTo(value: any) : number;
			 CompareTo(value: System.TimeSpan) : number;
			 static FromDays(value: System.Double) : System.TimeSpan;
			 Duration() : System.TimeSpan;
			 Equals(value: any) : boolean;
			 Equals(obj: System.TimeSpan) : boolean;
			 static Equals(t1: System.TimeSpan, t2: System.TimeSpan) : boolean;
			 GetHashCode() : number;
			 static FromHours(value: System.Double) : System.TimeSpan;
			 static FromMilliseconds(value: System.Double) : System.TimeSpan;
			 static FromMinutes(value: System.Double) : System.TimeSpan;
			 Negate() : System.TimeSpan;
			 static FromSeconds(value: System.Double) : System.TimeSpan;
			 Subtract(ts: System.TimeSpan) : System.TimeSpan;
			 Multiply(factor: System.Double) : System.TimeSpan;
			 Divide(divisor: System.Double) : System.TimeSpan;
			 Divide(ts: System.TimeSpan) : System.Double;
			 static FromTicks(value: number) : System.TimeSpan;
			 static Parse(s: string) : System.TimeSpan;
			 static Parse(input: string, formatProvider: System.IFormatProvider) : System.TimeSpan;
			 static Parse(input: any, formatProvider?: System.IFormatProvider) : System.TimeSpan;
			 static ParseExact(input: string, format: string, formatProvider: System.IFormatProvider) : System.TimeSpan;
			 static ParseExact(input: string, formats: string[], formatProvider: System.IFormatProvider) : System.TimeSpan;
			 static ParseExact(input: string, format: string, formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles) : System.TimeSpan;
			 static ParseExact(input: any, format: any, formatProvider: System.IFormatProvider, styles?: System.Globalization.TimeSpanStyles) : System.TimeSpan;
			 static ParseExact(input: string, formats: string[], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles) : System.TimeSpan;
			 static ParseExact(input: any, formats: string[], formatProvider: System.IFormatProvider, styles?: System.Globalization.TimeSpanStyles) : System.TimeSpan;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(input: string, formatProvider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(input: any, formatProvider: System.IFormatProvider, result: any) : boolean;
			 static TryParseExact(input: string, format: string, formatProvider: System.IFormatProvider, result: any) : boolean;
			 static TryParseExact(input: any, format: any, formatProvider: System.IFormatProvider, result: any) : boolean;
			 static TryParseExact(input: string, formats: string[], formatProvider: System.IFormatProvider, result: any) : boolean;
			 static TryParseExact(input: any, formats: string[], formatProvider: System.IFormatProvider, result: any) : boolean;
			 static TryParseExact(input: string, format: string, formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles, result: any) : boolean;
			 static TryParseExact(input: any, format: any, formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles, result: any) : boolean;
			 static TryParseExact(input: string, formats: string[], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles, result: any) : boolean;
			 static TryParseExact(input: any, formats: string[], formatProvider: System.IFormatProvider, styles: System.Globalization.TimeSpanStyles, result: any) : boolean;
			 ToString() : string;
			 ToString(format: string) : string;
			 ToString(format: string, formatProvider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, formatProvider?: System.IFormatProvider) : boolean;
			 static op_UnaryNegation(t: System.TimeSpan) : System.TimeSpan;
			 static op_Subtraction(t1: System.TimeSpan, t2: System.TimeSpan) : System.TimeSpan;
			 static op_UnaryPlus(t: System.TimeSpan) : System.TimeSpan;
			 static op_Addition(t1: System.TimeSpan, t2: System.TimeSpan) : System.TimeSpan;
			 static op_Multiply(timeSpan: System.TimeSpan, factor: System.Double) : System.TimeSpan;
			 static op_Multiply(factor: System.Double, timeSpan: System.TimeSpan) : System.TimeSpan;
			 static op_Division(timeSpan: System.TimeSpan, divisor: System.Double) : System.TimeSpan;
			 static op_Division(t1: System.TimeSpan, t2: System.TimeSpan) : System.Double;
			 static op_Equality(t1: System.TimeSpan, t2: System.TimeSpan) : boolean;
			 static op_Inequality(t1: System.TimeSpan, t2: System.TimeSpan) : boolean;
			 static op_LessThan(t1: System.TimeSpan, t2: System.TimeSpan) : boolean;
			 static op_LessThanOrEqual(t1: System.TimeSpan, t2: System.TimeSpan) : boolean;
			 static op_GreaterThan(t1: System.TimeSpan, t2: System.TimeSpan) : boolean;
			 static op_GreaterThanOrEqual(t1: System.TimeSpan, t2: System.TimeSpan) : boolean;
			 GetType() : System.Type;
		}
		abstract class Type extends System.Reflection.MemberInfo {
			IsInterface: boolean;
			MemberType: System.Reflection.MemberTypes;
			Namespace: string;
			AssemblyQualifiedName: string;
			FullName: string;
			Assembly: System.Reflection.Assembly;
			Module: System.Reflection.Module;
			IsNested: boolean;
			DeclaringType: System.Type;
			DeclaringMethod: System.Reflection.MethodBase;
			ReflectedType: System.Type;
			UnderlyingSystemType: System.Type;
			IsTypeDefinition: boolean;
			IsArray: boolean;
			IsByRef: boolean;
			IsPointer: boolean;
			IsConstructedGenericType: boolean;
			IsGenericParameter: boolean;
			IsGenericTypeParameter: boolean;
			IsGenericMethodParameter: boolean;
			IsGenericType: boolean;
			IsGenericTypeDefinition: boolean;
			IsSZArray: boolean;
			IsVariableBoundArray: boolean;
			IsByRefLike: boolean;
			HasElementType: boolean;
			GenericTypeArguments: any;
			GenericParameterPosition: number;
			GenericParameterAttributes: System.Reflection.GenericParameterAttributes;
			Attributes: System.Reflection.TypeAttributes;
			IsAbstract: boolean;
			IsImport: boolean;
			IsSealed: boolean;
			IsSpecialName: boolean;
			IsClass: boolean;
			IsNestedAssembly: boolean;
			IsNestedFamANDAssem: boolean;
			IsNestedFamily: boolean;
			IsNestedFamORAssem: boolean;
			IsNestedPrivate: boolean;
			IsNestedPublic: boolean;
			IsNotPublic: boolean;
			IsPublic: boolean;
			IsAutoLayout: boolean;
			IsExplicitLayout: boolean;
			IsLayoutSequential: boolean;
			IsAnsiClass: boolean;
			IsAutoClass: boolean;
			IsUnicodeClass: boolean;
			IsCOMObject: boolean;
			IsContextful: boolean;
			IsEnum: boolean;
			IsMarshalByRef: boolean;
			IsPrimitive: boolean;
			IsValueType: boolean;
			IsSignatureType: boolean;
			IsSecurityCritical: boolean;
			IsSecuritySafeCritical: boolean;
			IsSecurityTransparent: boolean;
			StructLayoutAttribute: System.Runtime.InteropServices.StructLayoutAttribute;
			TypeInitializer: System.Reflection.ConstructorInfo;
			TypeHandle: System.RuntimeTypeHandle;
			GUID: System.Guid;
			BaseType: System.Type;
			IsSerializable: boolean;
			ContainsGenericParameters: boolean;
			IsVisible: boolean;
			 GetEvent(name: string) : System.Reflection.EventInfo;
			 GetEvent(name: string, bindingAttr: System.Reflection.BindingFlags) : System.Reflection.EventInfo;
			 GetEvents() : any;
			 GetEvents(bindingAttr: System.Reflection.BindingFlags) : any;
			 GetField(name: string) : System.Reflection.FieldInfo;
			 GetField(name: string, bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo;
			 GetFields() : any;
			 GetFields(bindingAttr: System.Reflection.BindingFlags) : any;
			 GetMember(name: string) : any;
			 GetMember(name: string, bindingAttr: System.Reflection.BindingFlags) : any;
			 GetMember(name: string, type: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags) : any;
			 GetMembers() : any;
			 GetMembers(bindingAttr: System.Reflection.BindingFlags) : any;
			 GetMethod(name: string) : System.Reflection.MethodInfo;
			 GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags) : System.Reflection.MethodInfo;
			 GetMethod(name: string, types: any) : System.Reflection.MethodInfo;
			 GetMethod(name: string, types: any, modifiers: any) : System.Reflection.MethodInfo;
			 GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: any, modifiers: any) : System.Reflection.MethodInfo;
			 GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: any, modifiers: any) : System.Reflection.MethodInfo;
			 GetMethod(name: string, genericParameterCount: number, types: any) : System.Reflection.MethodInfo;
			 GetMethod(name: string, genericParameterCount: number, types: any, modifiers: any) : System.Reflection.MethodInfo;
			 GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: any, modifiers: any) : System.Reflection.MethodInfo;
			 GetMethod(name: string, genericParameterCount: number, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: any, modifiers: any) : System.Reflection.MethodInfo;
			 GetMethods() : any;
			 GetMethods(bindingAttr: System.Reflection.BindingFlags) : any;
			 GetNestedType(name: string) : System.Type;
			 GetNestedType(name: string, bindingAttr: System.Reflection.BindingFlags) : System.Type;
			 GetNestedTypes() : any;
			 GetNestedTypes(bindingAttr: System.Reflection.BindingFlags) : any;
			 GetProperty(name: string) : System.Reflection.PropertyInfo;
			 GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags) : System.Reflection.PropertyInfo;
			 GetProperty(name: string, returnType: System.Type) : System.Reflection.PropertyInfo;
			 GetProperty(name: string, types: any) : System.Reflection.PropertyInfo;
			 GetProperty(name: string, returnType: System.Type, types: any) : System.Reflection.PropertyInfo;
			 GetProperty(name: string, returnType: System.Type, types: any, modifiers: any) : System.Reflection.PropertyInfo;
			 GetProperty(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, returnType: System.Type, types: any, modifiers: any) : System.Reflection.PropertyInfo;
			 GetProperties() : any;
			 GetProperties(bindingAttr: System.Reflection.BindingFlags) : any;
			 GetDefaultMembers() : any;
			 static GetTypeHandle(o: any) : System.RuntimeTypeHandle;
			 static GetTypeArray(args: any) : any;
			 static GetTypeCode(type: System.Type) : System.TypeCode;
			 static GetTypeFromCLSID(clsid: System.Guid) : System.Type;
			 static GetTypeFromCLSID(clsid: System.Guid, throwOnError: boolean) : System.Type;
			 static GetTypeFromCLSID(clsid: System.Guid, server: string) : System.Type;
			 static GetTypeFromProgID(progID: string) : System.Type;
			 static GetTypeFromProgID(progID: string, throwOnError: boolean) : System.Type;
			 static GetTypeFromProgID(progID: string, server: string) : System.Type;
			 InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any) : any;
			 InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any, culture: System.Globalization.CultureInfo) : any;
			 InvokeMember(name: string, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, target: any, args: any, modifiers: any, culture: System.Globalization.CultureInfo, namedParameters: string[]) : any;
			 GetInterface(name: string) : System.Type;
			 GetInterface(name: string, ignoreCase: boolean) : System.Type;
			 GetInterfaces() : any;
			 GetInterfaceMap(interfaceType: System.Type) : System.Reflection.InterfaceMapping;
			 IsInstanceOfType(o: any) : boolean;
			 IsEquivalentTo(other: System.Type) : boolean;
			 GetEnumUnderlyingType() : System.Type;
			 GetEnumValues() : System.Array;
			 MakeArrayType() : System.Type;
			 MakeArrayType(rank: number) : System.Type;
			 MakeByRefType() : System.Type;
			 MakeGenericType(...typeArguments: any) : System.Type;
			 MakePointerType() : System.Type;
			 static MakeGenericSignatureType(genericTypeDefinition: System.Type, ...typeArguments: any) : System.Type;
			 static MakeGenericMethodParameter(position: number) : System.Type;
			 ToString() : string;
			 Equals(o: any) : boolean;
			 GetHashCode() : number;
			 Equals(o: System.Type) : boolean;
			 static ReflectionOnlyGetType(typeName: string, throwIfNotFound: boolean, ignoreCase: boolean) : System.Type;
			 IsEnumDefined(value: any) : boolean;
			 GetEnumName(value: any) : string;
			 GetEnumNames() : string[];
			 FindInterfaces(filter: System.Reflection.TypeFilter, filterCriteria: any) : any;
			 FindMembers(memberType: System.Reflection.MemberTypes, bindingAttr: System.Reflection.BindingFlags, filter: System.Reflection.MemberFilter, filterCriteria: any) : any;
			 IsSubclassOf(c: System.Type) : boolean;
			 IsAssignableFrom(c: System.Type) : boolean;
			 static GetType(typeName: string, throwOnError: boolean, ignoreCase: boolean) : System.Type;
			 static GetType(typeName: string, throwOnError: boolean) : System.Type;
			 static GetType(typeName: string) : System.Type;
			 static GetType(typeName: string, assemblyResolver: any, typeResolver: any) : System.Type;
			 static GetType(typeName: string, assemblyResolver: any, typeResolver: any, throwOnError: boolean) : System.Type;
			 static GetType(typeName: string, assemblyResolver: any, typeResolver: any, throwOnError: boolean, ignoreCase: boolean) : System.Type;
			 static GetTypeFromProgID(progID: string, server: string, throwOnError: boolean) : System.Type;
			 static GetTypeFromCLSID(clsid: System.Guid, server: string, throwOnError: boolean) : System.Type;
			 static GetTypeFromHandle(handle: System.RuntimeTypeHandle) : System.Type;
			 static op_Equality(left: System.Type, right: System.Type) : boolean;
			 static op_Inequality(left: System.Type, right: System.Type) : boolean;
			 GetType() : System.Type;
			 GetElementType() : System.Type;
			 GetArrayRank() : number;
			 GetGenericTypeDefinition() : System.Type;
			 GetGenericArguments() : any;
			 GetGenericParameterConstraints() : any;
			 GetConstructor(types: any) : System.Reflection.ConstructorInfo;
			 GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, types: any, modifiers: any) : System.Reflection.ConstructorInfo;
			 GetConstructor(bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: any, modifiers: any) : System.Reflection.ConstructorInfo;
			 GetConstructors() : any;
			 GetConstructors(bindingAttr: System.Reflection.BindingFlags) : any;
			 HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo) : boolean;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetCustomAttributesData() : any;
			 GetType() : System.Type;
		}
		enum TypeCode {
			Empty = 0,
			Object = 1,
			DBNull = 2,
			Boolean = 3,
			Char = 4,
			SByte = 5,
			Byte = 6,
			Int16 = 7,
			UInt16 = 8,
			Int32 = 9,
			UInt32 = 10,
			Int64 = 11,
			UInt64 = 12,
			Single = 13,
			Double = 14,
			Decimal = 15,
			DateTime = 16,
			String = 18,
		}
		class TypedReference extends System.ValueType {
			 static MakeTypedReference(target: any, flds: any) : System.TypedReference;
			 GetHashCode() : number;
			 Equals(o: any) : boolean;
			 static ToObject(value: System.TypedReference) : any;
			 static GetTargetType(value: System.TypedReference) : System.Type;
			 static TargetTypeToken(value: System.TypedReference) : System.RuntimeTypeHandle;
			 static SetTypedReference(target: System.TypedReference, value: any) : void;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class UInt16 extends System.ValueType {
			 CompareTo(value: any) : number;
			 CompareTo(value: System.UInt16) : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: System.UInt16) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : System.UInt16;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : System.UInt16;
			 static Parse(s: string, provider: System.IFormatProvider) : System.UInt16;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : System.UInt16;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : System.UInt16;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class UInt32 extends System.ValueType {
			 CompareTo(value: any) : number;
			 CompareTo(value: System.UInt32) : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: System.UInt32) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : System.UInt32;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : System.UInt32;
			 static Parse(s: string, provider: System.IFormatProvider) : System.UInt32;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : System.UInt32;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : System.UInt32;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class UInt64 extends System.ValueType {
			 CompareTo(value: any) : number;
			 CompareTo(value: System.UInt64) : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: System.UInt64) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(provider: System.IFormatProvider) : string;
			 ToString(format: string) : string;
			 ToString(format: string, provider: System.IFormatProvider) : string;
			 TryFormat(destination: any, charsWritten: any, format?: any, provider?: System.IFormatProvider) : boolean;
			 static Parse(s: string) : System.UInt64;
			 static Parse(s: string, style: System.Globalization.NumberStyles) : System.UInt64;
			 static Parse(s: string, provider: System.IFormatProvider) : System.UInt64;
			 static Parse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider) : System.UInt64;
			 static Parse(s: any, style?: System.Globalization.NumberStyles, provider?: System.IFormatProvider) : System.UInt64;
			 static TryParse(s: string, result: any) : boolean;
			 static TryParse(s: any, result: any) : boolean;
			 static TryParse(s: string, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 static TryParse(s: any, style: System.Globalization.NumberStyles, provider: System.IFormatProvider, result: any) : boolean;
			 GetTypeCode() : System.TypeCode;
			 GetType() : System.Type;
		}
		class Uri {
			AbsolutePath: string;
			AbsoluteUri: string;
			LocalPath: string;
			Authority: string;
			HostNameType: System.UriHostNameType;
			IsDefaultPort: boolean;
			IsFile: boolean;
			IsLoopback: boolean;
			PathAndQuery: string;
			Segments: string[];
			IsUnc: boolean;
			Host: string;
			Port: number;
			Query: string;
			Fragment: string;
			Scheme: string;
			OriginalString: string;
			DnsSafeHost: string;
			IdnHost: string;
			IsAbsoluteUri: boolean;
			UserEscaped: boolean;
			UserInfo: string;
			 constructor(uriString: string) ;
			 constructor(uriString: string, dontEscape: boolean) ;
			 constructor(baseUri: System.Uri, relativeUri: string, dontEscape: boolean) ;
			 constructor(uriString: string, uriKind: System.UriKind) ;
			 constructor(baseUri: System.Uri, relativeUri: string) ;
			 constructor(baseUri: System.Uri, relativeUri: System.Uri) ;
			 MakeRelative(toUri: System.Uri) : string;
			 static TryCreate(uriString: string, uriKind: System.UriKind, result: any) : boolean;
			 static TryCreate(baseUri: System.Uri, relativeUri: string, result: any) : boolean;
			 static TryCreate(baseUri: System.Uri, relativeUri: System.Uri, result: any) : boolean;
			 GetComponents(components: System.UriComponents, format: System.UriFormat) : string;
			 static Compare(uri1: System.Uri, uri2: System.Uri, partsToCompare: System.UriComponents, compareFormat: System.UriFormat, comparisonType: System.StringComparison) : number;
			 IsWellFormedOriginalString() : boolean;
			 static IsWellFormedUriString(uriString: string, uriKind: System.UriKind) : boolean;
			 static UnescapeDataString(stringToUnescape: string) : string;
			 static EscapeUriString(stringToEscape: string) : string;
			 static EscapeDataString(stringToEscape: string) : string;
			 IsBaseOf(uri: System.Uri) : boolean;
			 static CheckHostName(name: string) : System.UriHostNameType;
			 GetLeftPart(part: System.UriPartial) : string;
			 static HexEscape(character: number) : string;
			 static HexUnescape(pattern: string, index: any) : number;
			 static IsHexEncoding(pattern: string, index: number) : boolean;
			 static CheckSchemeName(schemeName: string) : boolean;
			 static IsHexDigit(character: number) : boolean;
			 static FromHex(digit: number) : number;
			 GetHashCode() : number;
			 ToString() : string;
			 static op_Equality(uri1: System.Uri, uri2: System.Uri) : boolean;
			 static op_Inequality(uri1: System.Uri, uri2: System.Uri) : boolean;
			 Equals(comparand: any) : boolean;
			 MakeRelativeUri(uri: System.Uri) : System.Uri;
			 GetType() : System.Type;
		}
		/** Flags */
		enum UriComponents {
			Scheme = 1,
			UserInfo = 2,
			Host = 4,
			Port = 8,
			Path = 16,
			Query = 32,
			Fragment = 64,
			StrongPort = 128,
			NormalizedHost = 256,
			KeepDelimiter = 1073741824,
			SerializationInfoString = -2147483648,
			AbsoluteUri = 127,
			HostAndPort = 132,
			StrongAuthority = 134,
			SchemeAndServer = 13,
			HttpRequestUrl = 61,
			PathAndQuery = 48,
		}
		enum UriFormat {
			UriEscaped = 1,
			Unescaped = 2,
			SafeUnescaped = 3,
		}
		enum UriHostNameType {
			Unknown = 0,
			Basic = 1,
			Dns = 2,
			IPv4 = 3,
			IPv6 = 4,
		}
		enum UriKind {
			RelativeOrAbsolute = 0,
			Absolute = 1,
			Relative = 2,
		}
		enum UriPartial {
			Scheme = 0,
			Authority = 1,
			Path = 2,
			Query = 3,
		}
		abstract class ValueType {
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class Version {
			Major: number;
			Minor: number;
			Build: number;
			Revision: number;
			MajorRevision: number;
			MinorRevision: number;
			 constructor(major: number, minor: number, build: number, revision: number) ;
			 constructor(major: number, minor: number, build: number) ;
			 constructor(major: number, minor: number) ;
			 constructor(version: string) ;
			 constructor() ;
			 Clone() : any;
			 CompareTo(version: any) : number;
			 CompareTo(value: System.Version) : number;
			 Equals(obj: any) : boolean;
			 Equals(obj: System.Version) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToString(fieldCount: number) : string;
			 TryFormat(destination: any, charsWritten: any) : boolean;
			 TryFormat(destination: any, fieldCount: number, charsWritten: any) : boolean;
			 static Parse(input: string) : System.Version;
			 static Parse(input: any) : System.Version;
			 static TryParse(input: string, result: any) : boolean;
			 static TryParse(input: any, result: any) : boolean;
			 static op_Equality(v1: System.Version, v2: System.Version) : boolean;
			 static op_Inequality(v1: System.Version, v2: System.Version) : boolean;
			 static op_LessThan(v1: System.Version, v2: System.Version) : boolean;
			 static op_LessThanOrEqual(v1: System.Version, v2: System.Version) : boolean;
			 static op_GreaterThan(v1: System.Version, v2: System.Version) : boolean;
			 static op_GreaterThanOrEqual(v1: System.Version, v2: System.Version) : boolean;
			 GetType() : System.Type;
		}
		class Void extends System.ValueType {
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
	}
	module System.Globalization {
		abstract class Calendar {
			MinSupportedDateTime: System.DateTime;
			MaxSupportedDateTime: System.DateTime;
			AlgorithmType: System.Globalization.CalendarAlgorithmType;
			IsReadOnly: boolean;
			Eras: number[];
			TwoDigitYearMax: number;
			 Clone() : any;
			 static ReadOnly(calendar: System.Globalization.Calendar) : System.Globalization.Calendar;
			 AddMilliseconds(time: System.DateTime, milliseconds: System.Double) : System.DateTime;
			 AddDays(time: System.DateTime, days: number) : System.DateTime;
			 AddHours(time: System.DateTime, hours: number) : System.DateTime;
			 AddMinutes(time: System.DateTime, minutes: number) : System.DateTime;
			 AddMonths(time: System.DateTime, months: number) : System.DateTime;
			 AddSeconds(time: System.DateTime, seconds: number) : System.DateTime;
			 AddWeeks(time: System.DateTime, weeks: number) : System.DateTime;
			 AddYears(time: System.DateTime, years: number) : System.DateTime;
			 GetDayOfMonth(time: System.DateTime) : number;
			 GetDayOfWeek(time: System.DateTime) : System.DayOfWeek;
			 GetDayOfYear(time: System.DateTime) : number;
			 GetDaysInMonth(year: number, month: number) : number;
			 GetDaysInMonth(year: number, month: number, era: number) : number;
			 GetDaysInYear(year: number) : number;
			 GetDaysInYear(year: number, era: number) : number;
			 GetEra(time: System.DateTime) : number;
			 GetHour(time: System.DateTime) : number;
			 GetMilliseconds(time: System.DateTime) : System.Double;
			 GetMinute(time: System.DateTime) : number;
			 GetMonth(time: System.DateTime) : number;
			 GetMonthsInYear(year: number) : number;
			 GetMonthsInYear(year: number, era: number) : number;
			 GetSecond(time: System.DateTime) : number;
			 GetWeekOfYear(time: System.DateTime, rule: System.Globalization.CalendarWeekRule, firstDayOfWeek: System.DayOfWeek) : number;
			 GetYear(time: System.DateTime) : number;
			 IsLeapDay(year: number, month: number, day: number) : boolean;
			 IsLeapDay(year: number, month: number, day: number, era: number) : boolean;
			 IsLeapMonth(year: number, month: number) : boolean;
			 IsLeapMonth(year: number, month: number, era: number) : boolean;
			 GetLeapMonth(year: number) : number;
			 GetLeapMonth(year: number, era: number) : number;
			 IsLeapYear(year: number) : boolean;
			 IsLeapYear(year: number, era: number) : boolean;
			 ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number) : System.DateTime;
			 ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number) : System.DateTime;
			 ToFourDigitYear(year: number) : number;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum CalendarAlgorithmType {
			Unknown = 0,
			SolarCalendar = 1,
			LunarCalendar = 2,
			LunisolarCalendar = 3,
		}
		enum CalendarWeekRule {
			FirstDay = 0,
			FirstFullWeek = 1,
			FirstFourDayWeek = 2,
		}
		class CompareInfo {
			Name: string;
			Version: System.Globalization.SortVersion;
			LCID: number;
			 ToString() : string;
			 static GetCompareInfo(culture: number, assembly: System.Reflection.Assembly) : System.Globalization.CompareInfo;
			 static GetCompareInfo(name: string, assembly: System.Reflection.Assembly) : System.Globalization.CompareInfo;
			 static GetCompareInfo(culture: number) : System.Globalization.CompareInfo;
			 static GetCompareInfo(name: string) : System.Globalization.CompareInfo;
			 static IsSortable(ch: number) : boolean;
			 static IsSortable(text: string) : boolean;
			 static IsSortable(text: any) : boolean;
			 static IsSortable(value: System.Text.Rune) : boolean;
			 Compare(string1: string, string2: string) : number;
			 Compare(string1: string, string2: string, options: System.Globalization.CompareOptions) : number;
			 Compare(string1: string, offset1: number, length1: number, string2: string, offset2: number, length2: number) : number;
			 Compare(string1: string, offset1: number, string2: string, offset2: number, options: System.Globalization.CompareOptions) : number;
			 Compare(string1: string, offset1: number, string2: string, offset2: number) : number;
			 Compare(string1: string, offset1: number, length1: number, string2: string, offset2: number, length2: number, options: System.Globalization.CompareOptions) : number;
			 Compare(string1: any, string2: any, options?: System.Globalization.CompareOptions) : number;
			 IsPrefix(source: string, prefix: string, options: System.Globalization.CompareOptions) : boolean;
			 IsPrefix(source: any, prefix: any, options?: System.Globalization.CompareOptions) : boolean;
			 IsPrefix(source: string, prefix: string) : boolean;
			 IsSuffix(source: string, suffix: string, options: System.Globalization.CompareOptions) : boolean;
			 IsSuffix(source: any, suffix: any, options?: System.Globalization.CompareOptions) : boolean;
			 IsSuffix(source: string, suffix: string) : boolean;
			 IndexOf(source: string, value: number) : number;
			 IndexOf(source: string, value: string) : number;
			 IndexOf(source: string, value: number, options: System.Globalization.CompareOptions) : number;
			 IndexOf(source: string, value: string, options: System.Globalization.CompareOptions) : number;
			 IndexOf(source: string, value: number, startIndex: number) : number;
			 IndexOf(source: string, value: string, startIndex: number) : number;
			 IndexOf(source: string, value: number, startIndex: number, options: System.Globalization.CompareOptions) : number;
			 IndexOf(source: string, value: string, startIndex: number, options: System.Globalization.CompareOptions) : number;
			 IndexOf(source: string, value: number, startIndex: number, count: number) : number;
			 IndexOf(source: string, value: string, startIndex: number, count: number) : number;
			 IndexOf(source: string, value: number, startIndex: number, count: number, options: System.Globalization.CompareOptions) : number;
			 IndexOf(source: string, value: string, startIndex: number, count: number, options: System.Globalization.CompareOptions) : number;
			 IndexOf(source: any, value: any, options?: System.Globalization.CompareOptions) : number;
			 IndexOf(source: any, value: System.Text.Rune, options?: System.Globalization.CompareOptions) : number;
			 LastIndexOf(source: string, value: number) : number;
			 LastIndexOf(source: string, value: string) : number;
			 LastIndexOf(source: string, value: number, options: System.Globalization.CompareOptions) : number;
			 LastIndexOf(source: string, value: string, options: System.Globalization.CompareOptions) : number;
			 LastIndexOf(source: string, value: number, startIndex: number) : number;
			 LastIndexOf(source: string, value: string, startIndex: number) : number;
			 LastIndexOf(source: string, value: number, startIndex: number, options: System.Globalization.CompareOptions) : number;
			 LastIndexOf(source: string, value: string, startIndex: number, options: System.Globalization.CompareOptions) : number;
			 LastIndexOf(source: string, value: number, startIndex: number, count: number) : number;
			 LastIndexOf(source: string, value: string, startIndex: number, count: number) : number;
			 LastIndexOf(source: string, value: number, startIndex: number, count: number, options: System.Globalization.CompareOptions) : number;
			 LastIndexOf(source: string, value: string, startIndex: number, count: number, options: System.Globalization.CompareOptions) : number;
			 LastIndexOf(source: any, value: any, options?: System.Globalization.CompareOptions) : number;
			 LastIndexOf(source: any, value: System.Text.Rune, options?: System.Globalization.CompareOptions) : number;
			 GetSortKey(source: string, options: System.Globalization.CompareOptions) : System.Globalization.SortKey;
			 GetSortKey(source: string) : System.Globalization.SortKey;
			 GetSortKey(source: any, destination: any, options?: System.Globalization.CompareOptions) : number;
			 GetSortKeyLength(source: any, options?: System.Globalization.CompareOptions) : number;
			 Equals(value: any) : boolean;
			 GetHashCode() : number;
			 GetHashCode(source: string, options: System.Globalization.CompareOptions) : number;
			 GetHashCode(source: any, options: System.Globalization.CompareOptions) : number;
			 GetType() : System.Type;
		}
		/** Flags */
		enum CompareOptions {
			None = 0,
			IgnoreCase = 1,
			IgnoreNonSpace = 2,
			IgnoreSymbols = 4,
			IgnoreKanaType = 8,
			IgnoreWidth = 16,
			OrdinalIgnoreCase = 268435456,
			StringSort = 536870912,
			Ordinal = 1073741824,
		}
		class CultureInfo {
			Parent: System.Globalization.CultureInfo;
			LCID: number;
			KeyboardLayoutId: number;
			Name: string;
			IetfLanguageTag: string;
			DisplayName: string;
			NativeName: string;
			EnglishName: string;
			TwoLetterISOLanguageName: string;
			ThreeLetterISOLanguageName: string;
			ThreeLetterWindowsLanguageName: string;
			CompareInfo: System.Globalization.CompareInfo;
			TextInfo: System.Globalization.TextInfo;
			IsNeutralCulture: boolean;
			CultureTypes: System.Globalization.CultureTypes;
			NumberFormat: System.Globalization.NumberFormatInfo;
			DateTimeFormat: System.Globalization.DateTimeFormatInfo;
			Calendar: System.Globalization.Calendar;
			OptionalCalendars: any;
			UseUserOverride: boolean;
			IsReadOnly: boolean;
			 constructor(name: string) ;
			 constructor(name: string, useUserOverride: boolean) ;
			 constructor(culture: number) ;
			 constructor(culture: number, useUserOverride: boolean) ;
			 static CreateSpecificCulture(name: string) : System.Globalization.CultureInfo;
			 static GetCultures(types: System.Globalization.CultureTypes) : any;
			 Equals(value: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetFormat(formatType: System.Type) : any;
			 ClearCachedData() : void;
			 GetConsoleFallbackUICulture() : System.Globalization.CultureInfo;
			 Clone() : any;
			 static ReadOnly(ci: System.Globalization.CultureInfo) : System.Globalization.CultureInfo;
			 static GetCultureInfo(culture: number) : System.Globalization.CultureInfo;
			 static GetCultureInfo(name: string) : System.Globalization.CultureInfo;
			 static GetCultureInfo(name: string, altName: string) : System.Globalization.CultureInfo;
			 static GetCultureInfo(name: string, predefinedOnly: boolean) : System.Globalization.CultureInfo;
			 static GetCultureInfoByIetfLanguageTag(name: string) : System.Globalization.CultureInfo;
			 GetType() : System.Type;
		}
		/** Flags */
		enum CultureTypes {
			NeutralCultures = 1,
			SpecificCultures = 2,
			InstalledWin32Cultures = 4,
			AllCultures = 7,
			UserCustomCulture = 8,
			ReplacementCultures = 16,
			WindowsOnlyCultures = 32,
			FrameworkCultures = 64,
		}
		class DateTimeFormatInfo {
			AMDesignator: string;
			Calendar: System.Globalization.Calendar;
			DateSeparator: string;
			FirstDayOfWeek: System.DayOfWeek;
			CalendarWeekRule: System.Globalization.CalendarWeekRule;
			FullDateTimePattern: string;
			LongDatePattern: string;
			LongTimePattern: string;
			MonthDayPattern: string;
			PMDesignator: string;
			RFC1123Pattern: string;
			ShortDatePattern: string;
			ShortTimePattern: string;
			SortableDateTimePattern: string;
			TimeSeparator: string;
			UniversalSortableDateTimePattern: string;
			YearMonthPattern: string;
			AbbreviatedDayNames: string[];
			ShortestDayNames: string[];
			DayNames: string[];
			AbbreviatedMonthNames: string[];
			MonthNames: string[];
			IsReadOnly: boolean;
			NativeCalendarName: string;
			AbbreviatedMonthGenitiveNames: string[];
			MonthGenitiveNames: string[];
			 constructor() ;
			 GetAllDateTimePatterns() : string[];
			 GetAllDateTimePatterns(format: number) : string[];
			 GetDayName(dayofweek: System.DayOfWeek) : string;
			 GetAbbreviatedMonthName(month: number) : string;
			 GetMonthName(month: number) : string;
			 static ReadOnly(dtfi: System.Globalization.DateTimeFormatInfo) : System.Globalization.DateTimeFormatInfo;
			 SetAllDateTimePatterns(patterns: string[], format: number) : void;
			 static GetInstance(provider: System.IFormatProvider) : System.Globalization.DateTimeFormatInfo;
			 GetFormat(formatType: System.Type) : any;
			 Clone() : any;
			 GetEra(eraName: string) : number;
			 GetEraName(era: number) : string;
			 GetAbbreviatedEraName(era: number) : string;
			 GetAbbreviatedDayName(dayofweek: System.DayOfWeek) : string;
			 GetShortestDayName(dayOfWeek: System.DayOfWeek) : string;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum DateTimeStyles {
			None = 0,
			AllowLeadingWhite = 1,
			AllowTrailingWhite = 2,
			AllowInnerWhite = 4,
			AllowWhiteSpaces = 7,
			NoCurrentDateDefault = 8,
			AdjustToUniversal = 16,
			AssumeLocal = 32,
			AssumeUniversal = 64,
			RoundtripKind = 128,
		}
		enum DigitShapes {
			Context = 0,
			None = 1,
			NativeNational = 2,
		}
		class NumberFormatInfo {
			CurrencyDecimalDigits: number;
			CurrencyDecimalSeparator: string;
			IsReadOnly: boolean;
			CurrencyGroupSizes: number[];
			NumberGroupSizes: number[];
			PercentGroupSizes: number[];
			CurrencyGroupSeparator: string;
			CurrencySymbol: string;
			NaNSymbol: string;
			CurrencyNegativePattern: number;
			NumberNegativePattern: number;
			PercentPositivePattern: number;
			PercentNegativePattern: number;
			NegativeInfinitySymbol: string;
			NegativeSign: string;
			NumberDecimalDigits: number;
			NumberDecimalSeparator: string;
			NumberGroupSeparator: string;
			CurrencyPositivePattern: number;
			PositiveInfinitySymbol: string;
			PositiveSign: string;
			PercentDecimalDigits: number;
			PercentDecimalSeparator: string;
			PercentGroupSeparator: string;
			PercentSymbol: string;
			PerMilleSymbol: string;
			NativeDigits: string[];
			DigitSubstitution: System.Globalization.DigitShapes;
			 constructor() ;
			 static GetInstance(formatProvider: System.IFormatProvider) : System.Globalization.NumberFormatInfo;
			 Clone() : any;
			 GetFormat(formatType: System.Type) : any;
			 static ReadOnly(nfi: System.Globalization.NumberFormatInfo) : System.Globalization.NumberFormatInfo;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum NumberStyles {
			None = 0,
			AllowLeadingWhite = 1,
			AllowTrailingWhite = 2,
			AllowLeadingSign = 4,
			AllowTrailingSign = 8,
			AllowParentheses = 16,
			AllowDecimalPoint = 32,
			AllowThousands = 64,
			AllowExponent = 128,
			AllowCurrencySymbol = 256,
			AllowHexSpecifier = 512,
			Integer = 7,
			HexNumber = 515,
			Number = 111,
			Float = 167,
			Currency = 383,
			Any = 511,
		}
		class SortKey {
			OriginalString: string;
			KeyData: any;
			 static Compare(sortkey1: System.Globalization.SortKey, sortkey2: System.Globalization.SortKey) : number;
			 Equals(value: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class SortVersion {
			FullVersion: number;
			SortId: System.Guid;
			 constructor(fullVersion: number, sortId: System.Guid) ;
			 Equals(obj: any) : boolean;
			 Equals(other: System.Globalization.SortVersion) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Globalization.SortVersion, right: System.Globalization.SortVersion) : boolean;
			 static op_Inequality(left: System.Globalization.SortVersion, right: System.Globalization.SortVersion) : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class TextInfo {
			ANSICodePage: number;
			OEMCodePage: number;
			MacCodePage: number;
			EBCDICCodePage: number;
			LCID: number;
			CultureName: string;
			IsReadOnly: boolean;
			ListSeparator: string;
			IsRightToLeft: boolean;
			 Clone() : any;
			 static ReadOnly(textInfo: System.Globalization.TextInfo) : System.Globalization.TextInfo;
			 ToLower(c: number) : number;
			 ToLower(str: string) : string;
			 ToUpper(c: number) : number;
			 ToUpper(str: string) : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 ToTitleCase(str: string) : string;
			 GetType() : System.Type;
		}
		/** Flags */
		enum TimeSpanStyles {
			None = 0,
			AssumeNegative = 1,
		}
		enum UnicodeCategory {
			UppercaseLetter = 0,
			LowercaseLetter = 1,
			TitlecaseLetter = 2,
			ModifierLetter = 3,
			OtherLetter = 4,
			NonSpacingMark = 5,
			SpacingCombiningMark = 6,
			EnclosingMark = 7,
			DecimalDigitNumber = 8,
			LetterNumber = 9,
			OtherNumber = 10,
			SpaceSeparator = 11,
			LineSeparator = 12,
			ParagraphSeparator = 13,
			Control = 14,
			Format = 15,
			Surrogate = 16,
			PrivateUse = 17,
			ConnectorPunctuation = 18,
			DashPunctuation = 19,
			OpenPunctuation = 20,
			ClosePunctuation = 21,
			InitialQuotePunctuation = 22,
			FinalQuotePunctuation = 23,
			OtherPunctuation = 24,
			MathSymbol = 25,
			CurrencySymbol = 26,
			ModifierSymbol = 27,
			OtherSymbol = 28,
			OtherNotAssigned = 29,
		}
	}
	module System.Reflection {
		abstract class Assembly {
			DefinedTypes: any;
			ExportedTypes: any;
			CodeBase: string;
			EntryPoint: System.Reflection.MethodInfo;
			FullName: string;
			ImageRuntimeVersion: string;
			IsDynamic: boolean;
			Location: string;
			ReflectionOnly: boolean;
			IsCollectible: boolean;
			IsFullyTrusted: boolean;
			CustomAttributes: any;
			EscapedCodeBase: string;
			ManifestModule: System.Reflection.Module;
			Modules: any;
			GlobalAssemblyCache: boolean;
			HostContext: number;
			SecurityRuleSet: System.Security.SecurityRuleSet;
			 static Load(assemblyString: string) : System.Reflection.Assembly;
			 static LoadWithPartialName(partialName: string) : System.Reflection.Assembly;
			 static Load(assemblyRef: System.Reflection.AssemblyName) : System.Reflection.Assembly;
			 static GetExecutingAssembly() : System.Reflection.Assembly;
			 static GetCallingAssembly() : System.Reflection.Assembly;
			 GetTypes() : any;
			 GetExportedTypes() : any;
			 GetForwardedTypes() : any;
			 GetManifestResourceInfo(resourceName: string) : System.Reflection.ManifestResourceInfo;
			 GetManifestResourceNames() : string[];
			 GetManifestResourceStream(name: string) : System.IO.Stream;
			 GetManifestResourceStream(type: System.Type, name: string) : System.IO.Stream;
			 GetName() : System.Reflection.AssemblyName;
			 GetName(copiedName: boolean) : System.Reflection.AssemblyName;
			 GetType(name: string) : System.Type;
			 GetType(name: string, throwOnError: boolean) : System.Type;
			 GetType(name: string, throwOnError: boolean, ignoreCase: boolean) : System.Type;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributesData() : any;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 CreateInstance(typeName: string) : any;
			 CreateInstance(typeName: string, ignoreCase: boolean) : any;
			 CreateInstance(typeName: string, ignoreCase: boolean, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, args: any, culture: System.Globalization.CultureInfo, activationAttributes: any) : any;
			 add_ModuleResolve(value: System.Reflection.ModuleResolveEventHandler) : void;
			 remove_ModuleResolve(value: System.Reflection.ModuleResolveEventHandler) : void;
			 GetModule(name: string) : System.Reflection.Module;
			 GetModules() : any;
			 GetModules(getResourceModules: boolean) : any;
			 GetLoadedModules() : any;
			 GetLoadedModules(getResourceModules: boolean) : any;
			 GetReferencedAssemblies() : any;
			 GetSatelliteAssembly(culture: System.Globalization.CultureInfo) : System.Reflection.Assembly;
			 GetSatelliteAssembly(culture: System.Globalization.CultureInfo, version: System.Version) : System.Reflection.Assembly;
			 GetFile(name: string) : System.IO.FileStream;
			 GetFiles() : any;
			 GetFiles(getResourceModules: boolean) : any;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 ToString() : string;
			 Equals(o: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Reflection.Assembly, right: System.Reflection.Assembly) : boolean;
			 static op_Inequality(left: System.Reflection.Assembly, right: System.Reflection.Assembly) : boolean;
			 static CreateQualifiedName(assemblyName: string, typeName: string) : string;
			 static GetAssembly(type: System.Type) : System.Reflection.Assembly;
			 static GetEntryAssembly() : System.Reflection.Assembly;
			 static Load(rawAssembly: any) : System.Reflection.Assembly;
			 static Load(rawAssembly: any, rawSymbolStore: any) : System.Reflection.Assembly;
			 static LoadFile(path: string) : System.Reflection.Assembly;
			 static LoadFrom(assemblyFile: string) : System.Reflection.Assembly;
			 static LoadFrom(assemblyFile: string, hashValue: any, hashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm) : System.Reflection.Assembly;
			 static UnsafeLoadFrom(assemblyFile: string) : System.Reflection.Assembly;
			 LoadModule(moduleName: string, rawModule: any) : System.Reflection.Module;
			 LoadModule(moduleName: string, rawModule: any, rawSymbolStore: any) : System.Reflection.Module;
			 static ReflectionOnlyLoad(rawAssembly: any) : System.Reflection.Assembly;
			 static ReflectionOnlyLoad(assemblyString: string) : System.Reflection.Assembly;
			 static ReflectionOnlyLoadFrom(assemblyFile: string) : System.Reflection.Assembly;
			 GetType() : System.Type;
			ModuleResolve: { connect: (callback: (sender: any, e: System.ResolveEventArgs) => System.Reflection.Module) => {disconnect: () => void} };
		}
		enum AssemblyContentType {
			Default = 0,
			WindowsRuntime = 1,
		}
		class AssemblyName {
			Name: string;
			Version: System.Version;
			CultureInfo: System.Globalization.CultureInfo;
			CultureName: string;
			CodeBase: string;
			EscapedCodeBase: string;
			ProcessorArchitecture: System.Reflection.ProcessorArchitecture;
			ContentType: System.Reflection.AssemblyContentType;
			Flags: System.Reflection.AssemblyNameFlags;
			HashAlgorithm: System.Configuration.Assemblies.AssemblyHashAlgorithm;
			VersionCompatibility: System.Configuration.Assemblies.AssemblyVersionCompatibility;
			KeyPair: System.Reflection.StrongNameKeyPair;
			FullName: string;
			 constructor() ;
			 constructor(assemblyName: string) ;
			 Clone() : any;
			 static GetAssemblyName(assemblyFile: string) : System.Reflection.AssemblyName;
			 GetPublicKey() : any;
			 SetPublicKey(publicKey: any) : void;
			 GetPublicKeyToken() : any;
			 SetPublicKeyToken(publicKeyToken: any) : void;
			 ToString() : string;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 OnDeserialization(sender: any) : void;
			 static ReferenceMatchesDefinition(reference: System.Reflection.AssemblyName, definition: System.Reflection.AssemblyName) : boolean;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum AssemblyNameFlags {
			None = 0,
			PublicKey = 1,
			EnableJITcompileOptimizer = 16384,
			EnableJITcompileTracking = 32768,
			Retargetable = 256,
		}
		abstract class Binder {
			 BindToField(bindingAttr: System.Reflection.BindingFlags, match: any, value: any, culture: System.Globalization.CultureInfo) : System.Reflection.FieldInfo;
			 BindToMethod(bindingAttr: System.Reflection.BindingFlags, match: any, args: any, modifiers: any, culture: System.Globalization.CultureInfo, names: string[], state: any) : System.Reflection.MethodBase;
			 ChangeType(value: any, type: System.Type, culture: System.Globalization.CultureInfo) : any;
			 ReorderArgumentArray(args: any, state: any) : void;
			 SelectMethod(bindingAttr: System.Reflection.BindingFlags, match: any, types: any, modifiers: any) : System.Reflection.MethodBase;
			 SelectProperty(bindingAttr: System.Reflection.BindingFlags, match: any, returnType: System.Type, indexes: any, modifiers: any) : System.Reflection.PropertyInfo;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum BindingFlags {
			Default = 0,
			IgnoreCase = 1,
			DeclaredOnly = 2,
			Instance = 4,
			Static = 8,
			Public = 16,
			NonPublic = 32,
			FlattenHierarchy = 64,
			InvokeMethod = 256,
			CreateInstance = 512,
			GetField = 1024,
			SetField = 2048,
			GetProperty = 4096,
			SetProperty = 8192,
			PutDispProperty = 16384,
			PutRefDispProperty = 32768,
			ExactBinding = 65536,
			SuppressChangeType = 131072,
			OptionalParamBinding = 262144,
			IgnoreReturn = 16777216,
			DoNotWrapExceptions = 33554432,
		}
		/** Flags */
		enum CallingConventions {
			Standard = 1,
			VarArgs = 2,
			Any = 3,
			HasThis = 32,
			ExplicitThis = 64,
		}
		abstract class ConstructorInfo extends System.Reflection.MethodBase {
			MemberType: System.Reflection.MemberTypes;
			 Invoke(parameters: any) : any;
			 Invoke(invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any, culture: System.Globalization.CultureInfo) : any;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Reflection.ConstructorInfo, right: System.Reflection.ConstructorInfo) : boolean;
			 static op_Inequality(left: System.Reflection.ConstructorInfo, right: System.Reflection.ConstructorInfo) : boolean;
			 GetParameters() : any;
			 GetMethodImplementationFlags() : System.Reflection.MethodImplAttributes;
			 GetMethodBody() : System.Reflection.MethodBody;
			 GetGenericArguments() : any;
			 Invoke(obj: any, parameters: any) : any;
			 Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any, culture: System.Globalization.CultureInfo) : any;
			 HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo) : boolean;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetCustomAttributesData() : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		/** Flags */
		enum EventAttributes {
			None = 0,
			SpecialName = 512,
			RTSpecialName = 1024,
			ReservedMask = 1024,
		}
		abstract class EventInfo extends System.Reflection.MemberInfo {
			MemberType: System.Reflection.MemberTypes;
			Attributes: System.Reflection.EventAttributes;
			IsSpecialName: boolean;
			AddMethod: System.Reflection.MethodInfo;
			RemoveMethod: System.Reflection.MethodInfo;
			RaiseMethod: System.Reflection.MethodInfo;
			IsMulticast: boolean;
			EventHandlerType: System.Type;
			 GetOtherMethods() : any;
			 GetOtherMethods(nonPublic: boolean) : any;
			 GetAddMethod() : System.Reflection.MethodInfo;
			 GetRemoveMethod() : System.Reflection.MethodInfo;
			 GetRaiseMethod() : System.Reflection.MethodInfo;
			 GetAddMethod(nonPublic: boolean) : System.Reflection.MethodInfo;
			 GetRemoveMethod(nonPublic: boolean) : System.Reflection.MethodInfo;
			 GetRaiseMethod(nonPublic: boolean) : System.Reflection.MethodInfo;
			 AddEventHandler(target: any, handler: System.Delegate) : void;
			 RemoveEventHandler(target: any, handler: System.Delegate) : void;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Reflection.EventInfo, right: System.Reflection.EventInfo) : boolean;
			 static op_Inequality(left: System.Reflection.EventInfo, right: System.Reflection.EventInfo) : boolean;
			 HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo) : boolean;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetCustomAttributesData() : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		/** Flags */
		enum FieldAttributes {
			FieldAccessMask = 7,
			PrivateScope = 0,
			Private = 1,
			FamANDAssem = 2,
			Assembly = 3,
			Family = 4,
			FamORAssem = 5,
			Public = 6,
			Static = 16,
			InitOnly = 32,
			Literal = 64,
			NotSerialized = 128,
			SpecialName = 512,
			PinvokeImpl = 8192,
			RTSpecialName = 1024,
			HasFieldMarshal = 4096,
			HasDefault = 32768,
			HasFieldRVA = 256,
			ReservedMask = 38144,
		}
		abstract class FieldInfo extends System.Reflection.MemberInfo {
			MemberType: System.Reflection.MemberTypes;
			Attributes: System.Reflection.FieldAttributes;
			FieldType: System.Type;
			IsInitOnly: boolean;
			IsLiteral: boolean;
			IsNotSerialized: boolean;
			IsPinvokeImpl: boolean;
			IsSpecialName: boolean;
			IsStatic: boolean;
			IsAssembly: boolean;
			IsFamily: boolean;
			IsFamilyAndAssembly: boolean;
			IsFamilyOrAssembly: boolean;
			IsPrivate: boolean;
			IsPublic: boolean;
			IsSecurityCritical: boolean;
			IsSecuritySafeCritical: boolean;
			IsSecurityTransparent: boolean;
			FieldHandle: System.RuntimeFieldHandle;
			 static GetFieldFromHandle(handle: System.RuntimeFieldHandle) : System.Reflection.FieldInfo;
			 static GetFieldFromHandle(handle: System.RuntimeFieldHandle, declaringType: System.RuntimeTypeHandle) : System.Reflection.FieldInfo;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Reflection.FieldInfo, right: System.Reflection.FieldInfo) : boolean;
			 static op_Inequality(left: System.Reflection.FieldInfo, right: System.Reflection.FieldInfo) : boolean;
			 GetValue(obj: any) : any;
			 SetValue(obj: any, value: any) : void;
			 SetValue(obj: any, value: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, culture: System.Globalization.CultureInfo) : void;
			 SetValueDirect(obj: System.TypedReference, value: any) : void;
			 GetValueDirect(obj: System.TypedReference) : any;
			 GetRawConstantValue() : any;
			 GetOptionalCustomModifiers() : any;
			 GetRequiredCustomModifiers() : any;
			 HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo) : boolean;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetCustomAttributesData() : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		/** Flags */
		enum GenericParameterAttributes {
			None = 0,
			VarianceMask = 3,
			Covariant = 1,
			Contravariant = 2,
			SpecialConstraintMask = 28,
			ReferenceTypeConstraint = 4,
			NotNullableValueTypeConstraint = 8,
			DefaultConstructorConstraint = 16,
		}
		interface ICustomAttributeProvider {
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
		}
		class InterfaceMapping extends System.ValueType {
			TargetType: System.Type;
			InterfaceType: System.Type;
			TargetMethods: any;
			InterfaceMethods: any;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class ManifestResourceInfo {
			ReferencedAssembly: System.Reflection.Assembly;
			FileName: string;
			ResourceLocation: System.Reflection.ResourceLocation;
			 constructor(containingAssembly: System.Reflection.Assembly, containingFileName: string, resourceLocation: System.Reflection.ResourceLocation) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class MemberFilter extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(m: System.Reflection.MemberInfo, filterCriteria: any) : boolean;
			 BeginInvoke(m: System.Reflection.MemberInfo, filterCriteria: any, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : boolean;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		abstract class MemberInfo {
			MemberType: System.Reflection.MemberTypes;
			Name: string;
			DeclaringType: System.Type;
			ReflectedType: System.Type;
			Module: System.Reflection.Module;
			CustomAttributes: any;
			IsCollectible: boolean;
			MetadataToken: number;
			 HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo) : boolean;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetCustomAttributesData() : any;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Reflection.MemberInfo, right: System.Reflection.MemberInfo) : boolean;
			 static op_Inequality(left: System.Reflection.MemberInfo, right: System.Reflection.MemberInfo) : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		/** Flags */
		enum MemberTypes {
			Constructor = 1,
			Event = 2,
			Field = 4,
			Method = 8,
			Property = 16,
			TypeInfo = 32,
			Custom = 64,
			NestedType = 128,
			All = 191,
		}
		/** Flags */
		enum MethodAttributes {
			MemberAccessMask = 7,
			PrivateScope = 0,
			Private = 1,
			FamANDAssem = 2,
			Assembly = 3,
			Family = 4,
			FamORAssem = 5,
			Public = 6,
			Static = 16,
			Final = 32,
			Virtual = 64,
			HideBySig = 128,
			CheckAccessOnOverride = 512,
			VtableLayoutMask = 256,
			ReuseSlot = 0,
			NewSlot = 256,
			Abstract = 1024,
			SpecialName = 2048,
			PinvokeImpl = 8192,
			UnmanagedExport = 8,
			RTSpecialName = 4096,
			HasSecurity = 16384,
			RequireSecObject = 32768,
			ReservedMask = 53248,
		}
		abstract class MethodBase extends System.Reflection.MemberInfo {
			Attributes: System.Reflection.MethodAttributes;
			MethodImplementationFlags: System.Reflection.MethodImplAttributes;
			CallingConvention: System.Reflection.CallingConventions;
			IsAbstract: boolean;
			IsConstructor: boolean;
			IsFinal: boolean;
			IsHideBySig: boolean;
			IsSpecialName: boolean;
			IsStatic: boolean;
			IsVirtual: boolean;
			IsAssembly: boolean;
			IsFamily: boolean;
			IsFamilyAndAssembly: boolean;
			IsFamilyOrAssembly: boolean;
			IsPrivate: boolean;
			IsPublic: boolean;
			IsConstructedGenericMethod: boolean;
			IsGenericMethod: boolean;
			IsGenericMethodDefinition: boolean;
			ContainsGenericParameters: boolean;
			MethodHandle: System.RuntimeMethodHandle;
			IsSecurityCritical: boolean;
			IsSecuritySafeCritical: boolean;
			IsSecurityTransparent: boolean;
			 static GetMethodFromHandle(handle: System.RuntimeMethodHandle) : System.Reflection.MethodBase;
			 static GetMethodFromHandle(handle: System.RuntimeMethodHandle, declaringType: System.RuntimeTypeHandle) : System.Reflection.MethodBase;
			 static GetCurrentMethod() : System.Reflection.MethodBase;
			 GetParameters() : any;
			 GetMethodImplementationFlags() : System.Reflection.MethodImplAttributes;
			 GetMethodBody() : System.Reflection.MethodBody;
			 GetGenericArguments() : any;
			 Invoke(obj: any, parameters: any) : any;
			 Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any, culture: System.Globalization.CultureInfo) : any;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Reflection.MethodBase, right: System.Reflection.MethodBase) : boolean;
			 static op_Inequality(left: System.Reflection.MethodBase, right: System.Reflection.MethodBase) : boolean;
			 HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo) : boolean;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetCustomAttributesData() : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MethodBody {
			LocalSignatureMetadataToken: number;
			LocalVariables: any;
			MaxStackSize: number;
			InitLocals: boolean;
			ExceptionHandlingClauses: any;
			 GetILAsByteArray() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum MethodImplAttributes {
			CodeTypeMask = 3,
			IL = 0,
			Native = 1,
			OPTIL = 2,
			Runtime = 3,
			ManagedMask = 4,
			Unmanaged = 4,
			Managed = 0,
			ForwardRef = 16,
			PreserveSig = 128,
			InternalCall = 4096,
			Synchronized = 32,
			NoInlining = 8,
			AggressiveInlining = 256,
			NoOptimization = 64,
			AggressiveOptimization = 512,
			MaxMethodImplVal = 65535,
		}
		abstract class MethodInfo extends System.Reflection.MethodBase {
			MemberType: System.Reflection.MemberTypes;
			ReturnParameter: System.Reflection.ParameterInfo;
			ReturnType: System.Type;
			ReturnTypeCustomAttributes: System.Reflection.ICustomAttributeProvider;
			 GetGenericArguments() : any;
			 GetGenericMethodDefinition() : System.Reflection.MethodInfo;
			 MakeGenericMethod(...typeArguments: any) : System.Reflection.MethodInfo;
			 GetBaseDefinition() : System.Reflection.MethodInfo;
			 CreateDelegate(delegateType: System.Type) : System.Delegate;
			 CreateDelegate(delegateType: System.Type, target: any) : System.Delegate;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Reflection.MethodInfo, right: System.Reflection.MethodInfo) : boolean;
			 static op_Inequality(left: System.Reflection.MethodInfo, right: System.Reflection.MethodInfo) : boolean;
			 GetParameters() : any;
			 GetMethodImplementationFlags() : System.Reflection.MethodImplAttributes;
			 GetMethodBody() : System.Reflection.MethodBody;
			 Invoke(obj: any, parameters: any) : any;
			 Invoke(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, parameters: any, culture: System.Globalization.CultureInfo) : any;
			 HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo) : boolean;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetCustomAttributesData() : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		abstract class Module {
			Assembly: System.Reflection.Assembly;
			FullyQualifiedName: string;
			Name: string;
			MDStreamVersion: number;
			ModuleVersionId: System.Guid;
			ScopeName: string;
			ModuleHandle: System.ModuleHandle;
			CustomAttributes: any;
			MetadataToken: number;
			 GetPEKind(peKind: any, machine: any) : void;
			 IsResource() : boolean;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributesData() : any;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetMethod(name: string) : System.Reflection.MethodInfo;
			 GetMethod(name: string, types: any) : System.Reflection.MethodInfo;
			 GetMethod(name: string, bindingAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, callConvention: System.Reflection.CallingConventions, types: any, modifiers: any) : System.Reflection.MethodInfo;
			 GetMethods() : any;
			 GetMethods(bindingFlags: System.Reflection.BindingFlags) : any;
			 GetField(name: string) : System.Reflection.FieldInfo;
			 GetField(name: string, bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo;
			 GetFields() : any;
			 GetFields(bindingFlags: System.Reflection.BindingFlags) : any;
			 GetTypes() : any;
			 GetType(className: string) : System.Type;
			 GetType(className: string, ignoreCase: boolean) : System.Type;
			 GetType(className: string, throwOnError: boolean, ignoreCase: boolean) : System.Type;
			 FindTypes(filter: System.Reflection.TypeFilter, filterCriteria: any) : any;
			 ResolveField(metadataToken: number) : System.Reflection.FieldInfo;
			 ResolveField(metadataToken: number, genericTypeArguments: any, genericMethodArguments: any) : System.Reflection.FieldInfo;
			 ResolveMember(metadataToken: number) : System.Reflection.MemberInfo;
			 ResolveMember(metadataToken: number, genericTypeArguments: any, genericMethodArguments: any) : System.Reflection.MemberInfo;
			 ResolveMethod(metadataToken: number) : System.Reflection.MethodBase;
			 ResolveMethod(metadataToken: number, genericTypeArguments: any, genericMethodArguments: any) : System.Reflection.MethodBase;
			 ResolveSignature(metadataToken: number) : any;
			 ResolveString(metadataToken: number) : string;
			 ResolveType(metadataToken: number) : System.Type;
			 ResolveType(metadataToken: number, genericTypeArguments: any, genericMethodArguments: any) : System.Type;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(o: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Reflection.Module, right: System.Reflection.Module) : boolean;
			 static op_Inequality(left: System.Reflection.Module, right: System.Reflection.Module) : boolean;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class ModuleResolveEventHandler extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(sender: any, e: System.ResolveEventArgs) : System.Reflection.Module;
			 BeginInvoke(sender: any, e: System.ResolveEventArgs, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : System.Reflection.Module;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		/** Flags */
		enum ParameterAttributes {
			None = 0,
			In = 1,
			Out = 2,
			Lcid = 4,
			Retval = 8,
			Optional = 16,
			HasDefault = 4096,
			HasFieldMarshal = 8192,
			Reserved3 = 16384,
			Reserved4 = 32768,
			ReservedMask = 61440,
		}
		class ParameterInfo {
			Attributes: System.Reflection.ParameterAttributes;
			Member: System.Reflection.MemberInfo;
			Name: string;
			ParameterType: System.Type;
			Position: number;
			IsIn: boolean;
			IsLcid: boolean;
			IsOptional: boolean;
			IsOut: boolean;
			IsRetval: boolean;
			DefaultValue: any;
			RawDefaultValue: any;
			HasDefaultValue: boolean;
			CustomAttributes: any;
			MetadataToken: number;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributesData() : any;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetOptionalCustomModifiers() : any;
			 GetRequiredCustomModifiers() : any;
			 GetRealObject(context: System.Runtime.Serialization.StreamingContext) : any;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum ProcessorArchitecture {
			None = 0,
			MSIL = 1,
			X86 = 2,
			IA64 = 3,
			Amd64 = 4,
			Arm = 5,
		}
		/** Flags */
		enum PropertyAttributes {
			None = 0,
			SpecialName = 512,
			RTSpecialName = 1024,
			HasDefault = 4096,
			Reserved2 = 8192,
			Reserved3 = 16384,
			Reserved4 = 32768,
			ReservedMask = 62464,
		}
		abstract class PropertyInfo extends System.Reflection.MemberInfo {
			MemberType: System.Reflection.MemberTypes;
			PropertyType: System.Type;
			Attributes: System.Reflection.PropertyAttributes;
			IsSpecialName: boolean;
			CanRead: boolean;
			CanWrite: boolean;
			GetMethod: System.Reflection.MethodInfo;
			SetMethod: System.Reflection.MethodInfo;
			 GetIndexParameters() : any;
			 GetAccessors() : any;
			 GetAccessors(nonPublic: boolean) : any;
			 GetGetMethod() : System.Reflection.MethodInfo;
			 GetGetMethod(nonPublic: boolean) : System.Reflection.MethodInfo;
			 GetSetMethod() : System.Reflection.MethodInfo;
			 GetSetMethod(nonPublic: boolean) : System.Reflection.MethodInfo;
			 GetOptionalCustomModifiers() : any;
			 GetRequiredCustomModifiers() : any;
			 GetValue(obj: any) : any;
			 GetValue(obj: any, index: any) : any;
			 GetValue(obj: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, index: any, culture: System.Globalization.CultureInfo) : any;
			 GetConstantValue() : any;
			 GetRawConstantValue() : any;
			 SetValue(obj: any, value: any) : void;
			 SetValue(obj: any, value: any, index: any) : void;
			 SetValue(obj: any, value: any, invokeAttr: System.Reflection.BindingFlags, binder: System.Reflection.Binder, index: any, culture: System.Globalization.CultureInfo) : void;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Reflection.PropertyInfo, right: System.Reflection.PropertyInfo) : boolean;
			 static op_Inequality(left: System.Reflection.PropertyInfo, right: System.Reflection.PropertyInfo) : boolean;
			 HasSameMetadataDefinitionAs(other: System.Reflection.MemberInfo) : boolean;
			 IsDefined(attributeType: System.Type, inherit: boolean) : boolean;
			 GetCustomAttributes(inherit: boolean) : any;
			 GetCustomAttributes(attributeType: System.Type, inherit: boolean) : any;
			 GetCustomAttributesData() : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		/** Flags */
		enum ResourceLocation {
			ContainedInAnotherAssembly = 2,
			ContainedInManifestFile = 4,
			Embedded = 1,
		}
		class StrongNameKeyPair {
			PublicKey: any;
			 constructor(keyPairFile: System.IO.FileStream) ;
			 constructor(keyPairArray: any) ;
			 constructor(keyPairContainer: string) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum TypeAttributes {
			VisibilityMask = 7,
			NotPublic = 0,
			Public = 1,
			NestedPublic = 2,
			NestedPrivate = 3,
			NestedFamily = 4,
			NestedAssembly = 5,
			NestedFamANDAssem = 6,
			NestedFamORAssem = 7,
			LayoutMask = 24,
			AutoLayout = 0,
			SequentialLayout = 8,
			ExplicitLayout = 16,
			ClassSemanticsMask = 32,
			Class = 0,
			Interface = 32,
			Abstract = 128,
			Sealed = 256,
			SpecialName = 1024,
			Import = 4096,
			Serializable = 8192,
			WindowsRuntime = 16384,
			StringFormatMask = 196608,
			AnsiClass = 0,
			UnicodeClass = 65536,
			AutoClass = 131072,
			CustomFormatClass = 196608,
			CustomFormatMask = 12582912,
			BeforeFieldInit = 1048576,
			RTSpecialName = 2048,
			HasSecurity = 262144,
			ReservedMask = 264192,
		}
		class TypeFilter extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(m: System.Type, filterCriteria: any) : boolean;
			 BeginInvoke(m: System.Type, filterCriteria: any, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : boolean;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
	}
	module System.Text {
		abstract class Decoder {
			Fallback: System.Text.DecoderFallback;
			FallbackBuffer: System.Text.DecoderFallbackBuffer;
			 Reset() : void;
			 GetCharCount(bytes: any, index: number, count: number) : number;
			 GetCharCount(bytes: any, index: number, count: number, flush: boolean) : number;
			 GetCharCount(bytes: any, count: number, flush: boolean) : number;
			 GetCharCount(bytes: any, flush: boolean) : number;
			 GetChars(bytes: any, byteIndex: number, byteCount: number, chars: number[], charIndex: number) : number;
			 GetChars(bytes: any, byteIndex: number, byteCount: number, chars: number[], charIndex: number, flush: boolean) : number;
			 GetChars(bytes: any, byteCount: number, chars: any, charCount: number, flush: boolean) : number;
			 GetChars(bytes: any, chars: any, flush: boolean) : number;
			 Convert(bytes: any, byteIndex: number, byteCount: number, chars: number[], charIndex: number, charCount: number, flush: boolean, bytesUsed: any, charsUsed: any, completed: any) : void;
			 Convert(bytes: any, byteCount: number, chars: any, charCount: number, flush: boolean, bytesUsed: any, charsUsed: any, completed: any) : void;
			 Convert(bytes: any, chars: any, flush: boolean, bytesUsed: any, charsUsed: any, completed: any) : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class DecoderFallback {
			MaxCharCount: number;
			 CreateFallbackBuffer() : System.Text.DecoderFallbackBuffer;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class DecoderFallbackBuffer {
			Remaining: number;
			 Fallback(bytesUnknown: any, index: number) : boolean;
			 GetNextChar() : number;
			 MovePrevious() : boolean;
			 Reset() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class Encoder {
			Fallback: System.Text.EncoderFallback;
			FallbackBuffer: System.Text.EncoderFallbackBuffer;
			 Reset() : void;
			 GetByteCount(chars: number[], index: number, count: number, flush: boolean) : number;
			 GetByteCount(chars: any, count: number, flush: boolean) : number;
			 GetByteCount(chars: any, flush: boolean) : number;
			 GetBytes(chars: number[], charIndex: number, charCount: number, bytes: any, byteIndex: number, flush: boolean) : number;
			 GetBytes(chars: any, charCount: number, bytes: any, byteCount: number, flush: boolean) : number;
			 GetBytes(chars: any, bytes: any, flush: boolean) : number;
			 Convert(chars: number[], charIndex: number, charCount: number, bytes: any, byteIndex: number, byteCount: number, flush: boolean, charsUsed: any, bytesUsed: any, completed: any) : void;
			 Convert(chars: any, charCount: number, bytes: any, byteCount: number, flush: boolean, charsUsed: any, bytesUsed: any, completed: any) : void;
			 Convert(chars: any, bytes: any, flush: boolean, charsUsed: any, bytesUsed: any, completed: any) : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class EncoderFallback {
			MaxCharCount: number;
			 CreateFallbackBuffer() : System.Text.EncoderFallbackBuffer;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class EncoderFallbackBuffer {
			Remaining: number;
			 Fallback(charUnknown: number, index: number) : boolean;
			 Fallback(charUnknownHigh: number, charUnknownLow: number, index: number) : boolean;
			 GetNextChar() : number;
			 MovePrevious() : boolean;
			 Reset() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class Encoding {
			Preamble: any;
			BodyName: string;
			EncodingName: string;
			HeaderName: string;
			WebName: string;
			WindowsCodePage: number;
			IsBrowserDisplay: boolean;
			IsBrowserSave: boolean;
			IsMailNewsDisplay: boolean;
			IsMailNewsSave: boolean;
			IsSingleByte: boolean;
			EncoderFallback: System.Text.EncoderFallback;
			DecoderFallback: System.Text.DecoderFallback;
			IsReadOnly: boolean;
			CodePage: number;
			 static Convert(srcEncoding: System.Text.Encoding, dstEncoding: System.Text.Encoding, bytes: any) : any;
			 static Convert(srcEncoding: System.Text.Encoding, dstEncoding: System.Text.Encoding, bytes: any, index: number, count: number) : any;
			 static RegisterProvider(provider: System.Text.EncodingProvider) : void;
			 static GetEncoding(codepage: number) : System.Text.Encoding;
			 static GetEncoding(codepage: number, encoderFallback: System.Text.EncoderFallback, decoderFallback: System.Text.DecoderFallback) : System.Text.Encoding;
			 static GetEncoding(name: string) : System.Text.Encoding;
			 static GetEncoding(name: string, encoderFallback: System.Text.EncoderFallback, decoderFallback: System.Text.DecoderFallback) : System.Text.Encoding;
			 static GetEncodings() : any;
			 GetPreamble() : any;
			 Clone() : any;
			 GetByteCount(chars: number[]) : number;
			 GetByteCount(s: string) : number;
			 GetByteCount(chars: number[], index: number, count: number) : number;
			 GetByteCount(s: string, index: number, count: number) : number;
			 GetByteCount(chars: any, count: number) : number;
			 GetByteCount(chars: any) : number;
			 GetBytes(chars: number[]) : any;
			 GetBytes(chars: number[], index: number, count: number) : any;
			 GetBytes(chars: number[], charIndex: number, charCount: number, bytes: any, byteIndex: number) : number;
			 GetBytes(s: string) : any;
			 GetBytes(s: string, index: number, count: number) : any;
			 GetBytes(s: string, charIndex: number, charCount: number, bytes: any, byteIndex: number) : number;
			 GetBytes(chars: any, charCount: number, bytes: any, byteCount: number) : number;
			 GetBytes(chars: any, bytes: any) : number;
			 GetCharCount(bytes: any) : number;
			 GetCharCount(bytes: any, index: number, count: number) : number;
			 GetCharCount(bytes: any, count: number) : number;
			 GetCharCount(bytes: any) : number;
			 GetChars(bytes: any) : number[];
			 GetChars(bytes: any, index: number, count: number) : number[];
			 GetChars(bytes: any, byteIndex: number, byteCount: number, chars: number[], charIndex: number) : number;
			 GetChars(bytes: any, byteCount: number, chars: any, charCount: number) : number;
			 GetChars(bytes: any, chars: any) : number;
			 GetString(bytes: any, byteCount: number) : string;
			 GetString(bytes: any) : string;
			 IsAlwaysNormalized() : boolean;
			 IsAlwaysNormalized(form: System.Text.NormalizationForm) : boolean;
			 GetDecoder() : System.Text.Decoder;
			 GetEncoder() : System.Text.Encoder;
			 GetMaxByteCount(charCount: number) : number;
			 GetMaxCharCount(byteCount: number) : number;
			 GetString(bytes: any) : string;
			 GetString(bytes: any, index: number, count: number) : string;
			 Equals(value: any) : boolean;
			 GetHashCode() : number;
			 static CreateTranscodingStream(innerStream: System.IO.Stream, innerStreamEncoding: System.Text.Encoding, outerStreamEncoding: System.Text.Encoding, leaveOpen?: boolean) : System.IO.Stream;
			 GetType() : System.Type;
			 ToString() : string;
		}
		abstract class EncodingProvider {
			 constructor() ;
			 GetEncoding(name: string) : System.Text.Encoding;
			 GetEncoding(codepage: number) : System.Text.Encoding;
			 GetEncoding(name: string, encoderFallback: System.Text.EncoderFallback, decoderFallback: System.Text.DecoderFallback) : System.Text.Encoding;
			 GetEncoding(codepage: number, encoderFallback: System.Text.EncoderFallback, decoderFallback: System.Text.DecoderFallback) : System.Text.Encoding;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum NormalizationForm {
			FormC = 1,
			FormD = 2,
			FormKC = 5,
			FormKD = 6,
		}
		class Rune extends System.ValueType {
			IsAscii: boolean;
			IsBmp: boolean;
			Plane: number;
			Utf16SequenceLength: number;
			Utf8SequenceLength: number;
			Value: number;
			 constructor(ch: number) ;
			 constructor(highSurrogate: number, lowSurrogate: number) ;
			 constructor(value: number) ;
			 constructor(value: System.UInt32) ;
			 static op_Equality(left: System.Text.Rune, right: System.Text.Rune) : boolean;
			 static op_Inequality(left: System.Text.Rune, right: System.Text.Rune) : boolean;
			 static op_LessThan(left: System.Text.Rune, right: System.Text.Rune) : boolean;
			 static op_LessThanOrEqual(left: System.Text.Rune, right: System.Text.Rune) : boolean;
			 static op_GreaterThan(left: System.Text.Rune, right: System.Text.Rune) : boolean;
			 static op_GreaterThanOrEqual(left: System.Text.Rune, right: System.Text.Rune) : boolean;
			 static op_Explicit(ch: number) : System.Text.Rune;
			 static op_Explicit(value: System.UInt32) : System.Text.Rune;
			 static op_Explicit(value: number) : System.Text.Rune;
			 CompareTo(other: System.Text.Rune) : number;
			 static DecodeFromUtf16(source: any, result: any, charsConsumed: any) : System.Buffers.OperationStatus;
			 static DecodeFromUtf8(source: any, result: any, bytesConsumed: any) : System.Buffers.OperationStatus;
			 static DecodeLastFromUtf16(source: any, result: any, charsConsumed: any) : System.Buffers.OperationStatus;
			 static DecodeLastFromUtf8(source: any, value: any, bytesConsumed: any) : System.Buffers.OperationStatus;
			 EncodeToUtf16(destination: any) : number;
			 EncodeToUtf8(destination: any) : number;
			 Equals(obj: any) : boolean;
			 Equals(other: System.Text.Rune) : boolean;
			 GetHashCode() : number;
			 static GetRuneAt(input: string, index: number) : System.Text.Rune;
			 static IsValid(value: number) : boolean;
			 static IsValid(value: System.UInt32) : boolean;
			 ToString() : string;
			 static TryCreate(ch: number, result: any) : boolean;
			 static TryCreate(highSurrogate: number, lowSurrogate: number, result: any) : boolean;
			 static TryCreate(value: number, result: any) : boolean;
			 static TryCreate(value: System.UInt32, result: any) : boolean;
			 TryEncodeToUtf16(destination: any, charsWritten: any) : boolean;
			 TryEncodeToUtf8(destination: any, bytesWritten: any) : boolean;
			 static TryGetRuneAt(input: string, index: number, value: any) : boolean;
			 static GetNumericValue(value: System.Text.Rune) : System.Double;
			 static GetUnicodeCategory(value: System.Text.Rune) : System.Globalization.UnicodeCategory;
			 static IsControl(value: System.Text.Rune) : boolean;
			 static IsDigit(value: System.Text.Rune) : boolean;
			 static IsLetter(value: System.Text.Rune) : boolean;
			 static IsLetterOrDigit(value: System.Text.Rune) : boolean;
			 static IsLower(value: System.Text.Rune) : boolean;
			 static IsNumber(value: System.Text.Rune) : boolean;
			 static IsPunctuation(value: System.Text.Rune) : boolean;
			 static IsSeparator(value: System.Text.Rune) : boolean;
			 static IsSymbol(value: System.Text.Rune) : boolean;
			 static IsUpper(value: System.Text.Rune) : boolean;
			 static IsWhiteSpace(value: System.Text.Rune) : boolean;
			 static ToLower(value: System.Text.Rune, culture: System.Globalization.CultureInfo) : System.Text.Rune;
			 static ToLowerInvariant(value: System.Text.Rune) : System.Text.Rune;
			 static ToUpper(value: System.Text.Rune, culture: System.Globalization.CultureInfo) : System.Text.Rune;
			 static ToUpperInvariant(value: System.Text.Rune) : System.Text.Rune;
			 GetType() : System.Type;
		}
		class StringBuilder {
			Capacity: number;
			MaxCapacity: number;
			Length: number;
			Chars: number;
			 constructor() ;
			 constructor(capacity: number) ;
			 constructor(value: string) ;
			 constructor(value: string, capacity: number) ;
			 constructor(value: string, startIndex: number, length: number, capacity: number) ;
			 constructor(capacity: number, maxCapacity: number) ;
			 Insert(index: number, value: System.UInt32) : System.Text.StringBuilder;
			 Insert(index: number, value: System.UInt64) : System.Text.StringBuilder;
			 Insert(index: number, value: any) : System.Text.StringBuilder;
			 Insert(index: number, value: any) : System.Text.StringBuilder;
			 AppendFormat(format: string, arg0: any) : System.Text.StringBuilder;
			 AppendFormat(format: string, arg0: any, arg1: any) : System.Text.StringBuilder;
			 AppendFormat(format: string, arg0: any, arg1: any, arg2: any) : System.Text.StringBuilder;
			 AppendFormat(format: string, ...args: any) : System.Text.StringBuilder;
			 AppendFormat(provider: System.IFormatProvider, format: string, arg0: any) : System.Text.StringBuilder;
			 AppendFormat(provider: System.IFormatProvider, format: string, arg0: any, arg1: any) : System.Text.StringBuilder;
			 AppendFormat(provider: System.IFormatProvider, format: string, arg0: any, arg1: any, arg2: any) : System.Text.StringBuilder;
			 AppendFormat(provider: System.IFormatProvider, format: string, ...args: any) : System.Text.StringBuilder;
			 Replace(oldValue: string, newValue: string) : System.Text.StringBuilder;
			 Equals(sb: System.Text.StringBuilder) : boolean;
			 Equals(span: any) : boolean;
			 Replace(oldValue: string, newValue: string, startIndex: number, count: number) : System.Text.StringBuilder;
			 Replace(oldChar: number, newChar: number) : System.Text.StringBuilder;
			 Replace(oldChar: number, newChar: number, startIndex: number, count: number) : System.Text.StringBuilder;
			 Append(value: any, valueCount: number) : System.Text.StringBuilder;
			 EnsureCapacity(capacity: number) : number;
			 ToString() : string;
			 ToString(startIndex: number, length: number) : string;
			 Clear() : System.Text.StringBuilder;
			 GetChunks() : any;
			 Append(value: number, repeatCount: number) : System.Text.StringBuilder;
			 Append(value: number[], startIndex: number, charCount: number) : System.Text.StringBuilder;
			 Append(value: string) : System.Text.StringBuilder;
			 Append(value: string, startIndex: number, count: number) : System.Text.StringBuilder;
			 Append(value: System.Text.StringBuilder) : System.Text.StringBuilder;
			 Append(value: System.Text.StringBuilder, startIndex: number, count: number) : System.Text.StringBuilder;
			 AppendLine() : System.Text.StringBuilder;
			 AppendLine(value: string) : System.Text.StringBuilder;
			 CopyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number) : void;
			 CopyTo(sourceIndex: number, destination: any, count: number) : void;
			 Insert(index: number, value: string, count: number) : System.Text.StringBuilder;
			 Remove(startIndex: number, length: number) : System.Text.StringBuilder;
			 Append(value: boolean) : System.Text.StringBuilder;
			 Append(value: number) : System.Text.StringBuilder;
			 Append(value: System.SByte) : System.Text.StringBuilder;
			 Append(value: System.Byte) : System.Text.StringBuilder;
			 Append(value: number) : System.Text.StringBuilder;
			 Append(value: number) : System.Text.StringBuilder;
			 Append(value: number) : System.Text.StringBuilder;
			 Append(value: number) : System.Text.StringBuilder;
			 Append(value: System.Double) : System.Text.StringBuilder;
			 Append(value: number) : System.Text.StringBuilder;
			 Append(value: System.UInt16) : System.Text.StringBuilder;
			 Append(value: System.UInt32) : System.Text.StringBuilder;
			 Append(value: System.UInt64) : System.Text.StringBuilder;
			 Append(value: any) : System.Text.StringBuilder;
			 Append(value: number[]) : System.Text.StringBuilder;
			 Append(value: any) : System.Text.StringBuilder;
			 Append(value: any) : System.Text.StringBuilder;
			 AppendJoin(separator: string, ...values: any) : System.Text.StringBuilder;
			 AppendJoin(separator: string, values: any) : System.Text.StringBuilder;
			 AppendJoin(separator: string, ...values: string[]) : System.Text.StringBuilder;
			 AppendJoin(separator: number, ...values: any) : System.Text.StringBuilder;
			 AppendJoin(separator: number, values: any) : System.Text.StringBuilder;
			 AppendJoin(separator: number, ...values: string[]) : System.Text.StringBuilder;
			 Insert(index: number, value: string) : System.Text.StringBuilder;
			 Insert(index: number, value: boolean) : System.Text.StringBuilder;
			 Insert(index: number, value: System.SByte) : System.Text.StringBuilder;
			 Insert(index: number, value: System.Byte) : System.Text.StringBuilder;
			 Insert(index: number, value: number) : System.Text.StringBuilder;
			 Insert(index: number, value: number) : System.Text.StringBuilder;
			 Insert(index: number, value: number[]) : System.Text.StringBuilder;
			 Insert(index: number, value: number[], startIndex: number, charCount: number) : System.Text.StringBuilder;
			 Insert(index: number, value: number) : System.Text.StringBuilder;
			 Insert(index: number, value: number) : System.Text.StringBuilder;
			 Insert(index: number, value: number) : System.Text.StringBuilder;
			 Insert(index: number, value: System.Double) : System.Text.StringBuilder;
			 Insert(index: number, value: number) : System.Text.StringBuilder;
			 Insert(index: number, value: System.UInt16) : System.Text.StringBuilder;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class StringRuneEnumerator extends System.ValueType {
			Current: System.Text.Rune;
			 GetEnumerator() : System.Text.StringRuneEnumerator;
			 MoveNext() : boolean;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
	}
	module System.Buffers {
		enum OperationStatus {
			Done = 0,
			DestinationTooSmall = 1,
			NeedMoreData = 2,
			InvalidData = 3,
		}
	}
	module System.Configuration.Assemblies {
		enum AssemblyHashAlgorithm {
			None = 0,
			MD5 = 32771,
			SHA1 = 32772,
			SHA256 = 32780,
			SHA384 = 32781,
			SHA512 = 32782,
		}
		enum AssemblyVersionCompatibility {
			SameMachine = 1,
			SameProcess = 2,
			SameDomain = 3,
		}
	}
	module System.Runtime.Serialization {
		class DeserializationToken extends System.ValueType {
			 Dispose() : void;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class SerializationEntry extends System.ValueType {
			Value: any;
			Name: string;
			ObjectType: System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class SerializationInfo {
			FullTypeName: string;
			AssemblyName: string;
			IsFullTypeNameSetExplicit: boolean;
			IsAssemblyNameSetExplicit: boolean;
			MemberCount: number;
			ObjectType: System.Type;
			 constructor(type: System.Type, converter: any) ;
			 constructor(type: System.Type, converter: any, requireSameTokenInPartialTrust: boolean) ;
			 static ThrowIfDeserializationInProgress() : void;
			 static ThrowIfDeserializationInProgress(switchSuffix: string, cachedValue: any) : void;
			 static StartDeserialization() : System.Runtime.Serialization.DeserializationToken;
			 SetType(type: System.Type) : void;
			 GetEnumerator() : System.Runtime.Serialization.SerializationInfoEnumerator;
			 AddValue(name: string, value: any, type: System.Type) : void;
			 AddValue(name: string, value: any) : void;
			 AddValue(name: string, value: boolean) : void;
			 AddValue(name: string, value: number) : void;
			 AddValue(name: string, value: System.SByte) : void;
			 AddValue(name: string, value: System.Byte) : void;
			 AddValue(name: string, value: number) : void;
			 AddValue(name: string, value: System.UInt16) : void;
			 AddValue(name: string, value: number) : void;
			 AddValue(name: string, value: System.UInt32) : void;
			 AddValue(name: string, value: number) : void;
			 AddValue(name: string, value: System.UInt64) : void;
			 AddValue(name: string, value: number) : void;
			 AddValue(name: string, value: System.Double) : void;
			 AddValue(name: string, value: number) : void;
			 AddValue(name: string, value: System.DateTime) : void;
			 UpdateValue(name: string, value: any, type: System.Type) : void;
			 GetValue(name: string, type: System.Type) : any;
			 GetBoolean(name: string) : boolean;
			 GetChar(name: string) : number;
			 GetSByte(name: string) : System.SByte;
			 GetByte(name: string) : System.Byte;
			 GetInt16(name: string) : number;
			 GetUInt16(name: string) : System.UInt16;
			 GetInt32(name: string) : number;
			 GetUInt32(name: string) : System.UInt32;
			 GetInt64(name: string) : number;
			 GetUInt64(name: string) : System.UInt64;
			 GetSingle(name: string) : number;
			 GetDouble(name: string) : System.Double;
			 GetDecimal(name: string) : number;
			 GetDateTime(name: string) : System.DateTime;
			 GetString(name: string) : string;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class SerializationInfoEnumerator {
			Current: System.Runtime.Serialization.SerializationEntry;
			Name: string;
			Value: any;
			ObjectType: System.Type;
			 MoveNext() : boolean;
			 Reset() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class StreamingContext extends System.ValueType {
			State: System.Runtime.Serialization.StreamingContextStates;
			Context: any;
			 constructor(state: System.Runtime.Serialization.StreamingContextStates) ;
			 constructor(state: System.Runtime.Serialization.StreamingContextStates, additional: any) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		/** Flags */
		enum StreamingContextStates {
			CrossProcess = 1,
			CrossMachine = 2,
			File = 4,
			Persistence = 8,
			Remoting = 16,
			Other = 32,
			Clone = 64,
			CrossAppDomain = 128,
			All = 255,
		}
	}
	module System.IO {
		abstract class Directory {
			 static GetParent(path: string) : System.IO.DirectoryInfo;
			 static CreateDirectory(path: string) : System.IO.DirectoryInfo;
			 static Exists(path: string) : boolean;
			 static SetCreationTime(path: string, creationTime: System.DateTime) : void;
			 static SetCreationTimeUtc(path: string, creationTimeUtc: System.DateTime) : void;
			 static GetCreationTime(path: string) : System.DateTime;
			 static GetCreationTimeUtc(path: string) : System.DateTime;
			 static SetLastWriteTime(path: string, lastWriteTime: System.DateTime) : void;
			 static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: System.DateTime) : void;
			 static GetLastWriteTime(path: string) : System.DateTime;
			 static GetLastWriteTimeUtc(path: string) : System.DateTime;
			 static SetLastAccessTime(path: string, lastAccessTime: System.DateTime) : void;
			 static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: System.DateTime) : void;
			 static GetLastAccessTime(path: string) : System.DateTime;
			 static GetLastAccessTimeUtc(path: string) : System.DateTime;
			 static GetFiles(path: string) : string[];
			 static GetFiles(path: string, searchPattern: string) : string[];
			 static GetFiles(path: string, searchPattern: string, searchOption: System.IO.SearchOption) : string[];
			 static GetFiles(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : string[];
			 static GetDirectories(path: string) : string[];
			 static GetDirectories(path: string, searchPattern: string) : string[];
			 static GetDirectories(path: string, searchPattern: string, searchOption: System.IO.SearchOption) : string[];
			 static GetDirectories(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : string[];
			 static GetFileSystemEntries(path: string) : string[];
			 static GetFileSystemEntries(path: string, searchPattern: string) : string[];
			 static GetFileSystemEntries(path: string, searchPattern: string, searchOption: System.IO.SearchOption) : string[];
			 static GetFileSystemEntries(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : string[];
			 static EnumerateDirectories(path: string) : any;
			 static EnumerateDirectories(path: string, searchPattern: string) : any;
			 static EnumerateDirectories(path: string, searchPattern: string, searchOption: System.IO.SearchOption) : any;
			 static EnumerateDirectories(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : any;
			 static EnumerateFiles(path: string) : any;
			 static EnumerateFiles(path: string, searchPattern: string) : any;
			 static EnumerateFiles(path: string, searchPattern: string, searchOption: System.IO.SearchOption) : any;
			 static EnumerateFiles(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : any;
			 static EnumerateFileSystemEntries(path: string) : any;
			 static EnumerateFileSystemEntries(path: string, searchPattern: string) : any;
			 static EnumerateFileSystemEntries(path: string, searchPattern: string, searchOption: System.IO.SearchOption) : any;
			 static EnumerateFileSystemEntries(path: string, searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : any;
			 static GetDirectoryRoot(path: string) : string;
			 static GetCurrentDirectory() : string;
			 static SetCurrentDirectory(path: string) : void;
			 static Move(sourceDirName: string, destDirName: string) : void;
			 static Delete(path: string) : void;
			 static Delete(path: string, recursive: boolean) : void;
			 static GetLogicalDrives() : string[];
			 static GetType() : System.Type;
			 static ToString() : string;
			 static Equals(obj: any) : boolean;
			 static GetHashCode() : number;
		}
		class DirectoryInfo extends System.IO.FileSystemInfo {
			Parent: System.IO.DirectoryInfo;
			Root: System.IO.DirectoryInfo;
			 constructor(path: string) ;
			 CreateSubdirectory(path: string) : System.IO.DirectoryInfo;
			 Create() : void;
			 GetFiles() : any;
			 GetFiles(searchPattern: string) : any;
			 GetFiles(searchPattern: string, searchOption: System.IO.SearchOption) : any;
			 GetFiles(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : any;
			 GetFileSystemInfos() : any;
			 GetFileSystemInfos(searchPattern: string) : any;
			 GetFileSystemInfos(searchPattern: string, searchOption: System.IO.SearchOption) : any;
			 GetFileSystemInfos(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : any;
			 GetDirectories() : any;
			 GetDirectories(searchPattern: string) : any;
			 GetDirectories(searchPattern: string, searchOption: System.IO.SearchOption) : any;
			 GetDirectories(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : any;
			 EnumerateDirectories() : any;
			 EnumerateDirectories(searchPattern: string) : any;
			 EnumerateDirectories(searchPattern: string, searchOption: System.IO.SearchOption) : any;
			 EnumerateDirectories(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : any;
			 EnumerateFiles() : any;
			 EnumerateFiles(searchPattern: string) : any;
			 EnumerateFiles(searchPattern: string, searchOption: System.IO.SearchOption) : any;
			 EnumerateFiles(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : any;
			 EnumerateFileSystemInfos() : any;
			 EnumerateFileSystemInfos(searchPattern: string) : any;
			 EnumerateFileSystemInfos(searchPattern: string, searchOption: System.IO.SearchOption) : any;
			 EnumerateFileSystemInfos(searchPattern: string, enumerationOptions: System.IO.EnumerationOptions) : any;
			 MoveTo(destDirName: string) : void;
			 Delete() : void;
			 Delete(recursive: boolean) : void;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 ToString() : string;
			 Refresh() : void;
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class EnumerationOptions {
			RecurseSubdirectories: boolean;
			IgnoreInaccessible: boolean;
			BufferSize: number;
			AttributesToSkip: System.IO.FileAttributes;
			MatchType: System.IO.MatchType;
			MatchCasing: System.IO.MatchCasing;
			ReturnSpecialDirectories: boolean;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class File {
			 static OpenText(path: string) : System.IO.StreamReader;
			 static CreateText(path: string) : System.IO.StreamWriter;
			 static AppendText(path: string) : System.IO.StreamWriter;
			 static Copy(sourceFileName: string, destFileName: string) : void;
			 static Copy(sourceFileName: string, destFileName: string, overwrite: boolean) : void;
			 static Create(path: string) : System.IO.FileStream;
			 static Create(path: string, bufferSize: number) : System.IO.FileStream;
			 static Create(path: string, bufferSize: number, options: System.IO.FileOptions) : System.IO.FileStream;
			 static Delete(path: string) : void;
			 static Exists(path: string) : boolean;
			 static Open(path: string, mode: System.IO.FileMode) : System.IO.FileStream;
			 static Open(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess) : System.IO.FileStream;
			 static Open(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare) : System.IO.FileStream;
			 static SetCreationTime(path: string, creationTime: System.DateTime) : void;
			 static SetCreationTimeUtc(path: string, creationTimeUtc: System.DateTime) : void;
			 static GetCreationTime(path: string) : System.DateTime;
			 static GetCreationTimeUtc(path: string) : System.DateTime;
			 static SetLastAccessTime(path: string, lastAccessTime: System.DateTime) : void;
			 static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: System.DateTime) : void;
			 static GetLastAccessTime(path: string) : System.DateTime;
			 static GetLastAccessTimeUtc(path: string) : System.DateTime;
			 static SetLastWriteTime(path: string, lastWriteTime: System.DateTime) : void;
			 static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: System.DateTime) : void;
			 static GetLastWriteTime(path: string) : System.DateTime;
			 static GetLastWriteTimeUtc(path: string) : System.DateTime;
			 static GetAttributes(path: string) : System.IO.FileAttributes;
			 static SetAttributes(path: string, fileAttributes: System.IO.FileAttributes) : void;
			 static OpenRead(path: string) : System.IO.FileStream;
			 static OpenWrite(path: string) : System.IO.FileStream;
			 static ReadAllText(path: string) : string;
			 static ReadAllText(path: string, encoding: System.Text.Encoding) : string;
			 static WriteAllText(path: string, contents: string) : void;
			 static WriteAllText(path: string, contents: string, encoding: System.Text.Encoding) : void;
			 static ReadAllBytes(path: string) : any;
			 static WriteAllBytes(path: string, bytes: any) : void;
			 static ReadAllLines(path: string) : string[];
			 static ReadAllLines(path: string, encoding: System.Text.Encoding) : string[];
			 static ReadLines(path: string) : any;
			 static ReadLines(path: string, encoding: System.Text.Encoding) : any;
			 static WriteAllLines(path: string, contents: string[]) : void;
			 static WriteAllLines(path: string, contents: any) : void;
			 static WriteAllLines(path: string, contents: string[], encoding: System.Text.Encoding) : void;
			 static WriteAllLines(path: string, contents: any, encoding: System.Text.Encoding) : void;
			 static AppendAllText(path: string, contents: string) : void;
			 static AppendAllText(path: string, contents: string, encoding: System.Text.Encoding) : void;
			 static AppendAllLines(path: string, contents: any) : void;
			 static AppendAllLines(path: string, contents: any, encoding: System.Text.Encoding) : void;
			 static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string) : void;
			 static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean) : void;
			 static Move(sourceFileName: string, destFileName: string) : void;
			 static Move(sourceFileName: string, destFileName: string, overwrite: boolean) : void;
			 static Encrypt(path: string) : void;
			 static Decrypt(path: string) : void;
			 static ReadAllTextAsync(path: string, cancellationToken?: System.Threading.CancellationToken) : any;
			 static ReadAllTextAsync(path: string, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken) : any;
			 static WriteAllTextAsync(path: string, contents: string, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static WriteAllTextAsync(path: string, contents: string, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static ReadAllBytesAsync(path: string, cancellationToken?: System.Threading.CancellationToken) : any;
			 static WriteAllBytesAsync(path: string, bytes: any, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static ReadAllLinesAsync(path: string, cancellationToken?: System.Threading.CancellationToken) : any;
			 static ReadAllLinesAsync(path: string, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken) : any;
			 static WriteAllLinesAsync(path: string, contents: any, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static WriteAllLinesAsync(path: string, contents: any, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static AppendAllTextAsync(path: string, contents: string, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static AppendAllTextAsync(path: string, contents: string, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static AppendAllLinesAsync(path: string, contents: any, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static AppendAllLinesAsync(path: string, contents: any, encoding: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static GetType() : System.Type;
			 static ToString() : string;
			 static Equals(obj: any) : boolean;
			 static GetHashCode() : number;
		}
		/** Flags */
		enum FileAccess {
			Read = 1,
			Write = 2,
			ReadWrite = 3,
		}
		/** Flags */
		enum FileAttributes {
			ReadOnly = 1,
			Hidden = 2,
			System = 4,
			Directory = 16,
			Archive = 32,
			Device = 64,
			Normal = 128,
			Temporary = 256,
			SparseFile = 512,
			ReparsePoint = 1024,
			Compressed = 2048,
			Offline = 4096,
			NotContentIndexed = 8192,
			Encrypted = 16384,
			IntegrityStream = 32768,
			NoScrubData = 131072,
		}
		enum FileMode {
			CreateNew = 1,
			Create = 2,
			Open = 3,
			OpenOrCreate = 4,
			Truncate = 5,
			Append = 6,
		}
		class FileNotFoundException extends System.IO.IOException {
			Message: string;
			FileName: string;
			FusionLog: string;
			 constructor() ;
			 constructor(message: string) ;
			 constructor(message: string, innerException: System.Exception) ;
			 constructor(message: string, fileName: string) ;
			 constructor(message: string, fileName: string, innerException: System.Exception) ;
			 ToString() : string;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 GetBaseException() : System.Exception;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum FileOptions {
			None = 0,
			WriteThrough = -2147483648,
			Asynchronous = 1073741824,
			RandomAccess = 268435456,
			DeleteOnClose = 67108864,
			SequentialScan = 134217728,
			Encrypted = 16384,
		}
		/** Flags */
		enum FileShare {
			None = 0,
			Read = 1,
			Write = 2,
			ReadWrite = 3,
			Delete = 4,
			Inheritable = 16,
		}
		class FileStream extends System.IO.Stream {
			Handle: System.IntPtr;
			CanRead: boolean;
			CanWrite: boolean;
			SafeFileHandle: Microsoft.Win32.SafeHandles.SafeFileHandle;
			Name: string;
			IsAsync: boolean;
			Length: number;
			Position: number;
			CanSeek: boolean;
			 constructor(handle: System.IntPtr, access: System.IO.FileAccess) ;
			 constructor(handle: System.IntPtr, access: System.IO.FileAccess, ownsHandle: boolean) ;
			 constructor(handle: System.IntPtr, access: System.IO.FileAccess, ownsHandle: boolean, bufferSize: number) ;
			 constructor(handle: System.IntPtr, access: System.IO.FileAccess, ownsHandle: boolean, bufferSize: number, isAsync: boolean) ;
			 constructor(handle: Microsoft.Win32.SafeHandles.SafeFileHandle, access: System.IO.FileAccess) ;
			 constructor(handle: Microsoft.Win32.SafeHandles.SafeFileHandle, access: System.IO.FileAccess, bufferSize: number) ;
			 constructor(handle: Microsoft.Win32.SafeHandles.SafeFileHandle, access: System.IO.FileAccess, bufferSize: number, isAsync: boolean) ;
			 constructor(path: string, mode: System.IO.FileMode) ;
			 constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess) ;
			 constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare) ;
			 constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare, bufferSize: number) ;
			 constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare, bufferSize: number, useAsync: boolean) ;
			 constructor(path: string, mode: System.IO.FileMode, access: System.IO.FileAccess, share: System.IO.FileShare, bufferSize: number, options: System.IO.FileOptions) ;
			 Lock(position: number, length: number) : void;
			 Unlock(position: number, length: number) : void;
			 FlushAsync(cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 Read(array: any, offset: number, count: number) : number;
			 Read(buffer: any) : number;
			 ReadAsync(buffer: any, offset: number, count: number, cancellationToken: System.Threading.CancellationToken) : any;
			 ReadAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : any;
			 Write(array: any, offset: number, count: number) : void;
			 Write(buffer: any) : void;
			 WriteAsync(buffer: any, offset: number, count: number, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 WriteAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.ValueTask;
			 Flush() : void;
			 Flush(flushToDisk: boolean) : void;
			 SetLength(value: number) : void;
			 ReadByte() : number;
			 WriteByte(value: System.Byte) : void;
			 BeginRead(array: any, offset: number, numBytes: number, callback: System.AsyncCallback, state: any) : System.IAsyncResult;
			 BeginWrite(array: any, offset: number, numBytes: number, callback: System.AsyncCallback, state: any) : System.IAsyncResult;
			 EndRead(asyncResult: System.IAsyncResult) : number;
			 EndWrite(asyncResult: System.IAsyncResult) : void;
			 DisposeAsync() : System.Threading.Tasks.ValueTask;
			 Seek(offset: number, origin: System.IO.SeekOrigin) : number;
			 CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 CopyToAsync(destination: System.IO.Stream) : System.Threading.Tasks.Task;
			 CopyToAsync(destination: System.IO.Stream, bufferSize: number) : System.Threading.Tasks.Task;
			 CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 CopyTo(destination: System.IO.Stream) : void;
			 CopyTo(destination: System.IO.Stream, bufferSize: number) : void;
			 CopyTo(callback: any, state: any, bufferSize: number) : void;
			 CopyToAsync(callback: any, state: any, bufferSize: number, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 Close() : void;
			 Dispose() : void;
			 FlushAsync() : System.Threading.Tasks.Task;
			 ReadAsync(buffer: any, offset: number, count: number) : any;
			 WriteAsync(buffer: any, offset: number, count: number) : System.Threading.Tasks.Task;
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class FileSystemInfo extends System.MarshalByRefObject {
			FullName: string;
			Extension: string;
			Name: string;
			Exists: boolean;
			CreationTime: System.DateTime;
			CreationTimeUtc: System.DateTime;
			LastAccessTime: System.DateTime;
			LastAccessTimeUtc: System.DateTime;
			LastWriteTime: System.DateTime;
			LastWriteTimeUtc: System.DateTime;
			Attributes: System.IO.FileAttributes;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Delete() : void;
			 ToString() : string;
			 Refresh() : void;
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class IOException extends System.SystemException {
			 constructor() ;
			 constructor(message: string) ;
			 constructor(message: string, hresult: number) ;
			 constructor(message: string, innerException: System.Exception) ;
			 GetBaseException() : System.Exception;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 ToString() : string;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum MatchCasing {
			PlatformDefault = 0,
			CaseSensitive = 1,
			CaseInsensitive = 2,
		}
		enum MatchType {
			Simple = 0,
			Win32 = 1,
		}
		abstract class Path {
			 static ChangeExtension(path: string, extension: string) : string;
			 static GetDirectoryName(path: string) : string;
			 static GetDirectoryName(path: any) : any;
			 static GetExtension(path: string) : string;
			 static GetExtension(path: any) : any;
			 static GetFileName(path: string) : string;
			 static GetFileName(path: any) : any;
			 static GetFileNameWithoutExtension(path: string) : string;
			 static GetFileNameWithoutExtension(path: any) : any;
			 static GetRandomFileName() : string;
			 static IsPathFullyQualified(path: string) : boolean;
			 static IsPathFullyQualified(path: any) : boolean;
			 static HasExtension(path: string) : boolean;
			 static HasExtension(path: any) : boolean;
			 static Combine(path1: string, path2: string) : string;
			 static Combine(path1: string, path2: string, path3: string) : string;
			 static Combine(path1: string, path2: string, path3: string, path4: string) : string;
			 static Combine(...paths: string[]) : string;
			 static Join(path1: any, path2: any) : string;
			 static Join(path1: any, path2: any, path3: any) : string;
			 static Join(path1: any, path2: any, path3: any, path4: any) : string;
			 static Join(path1: string, path2: string) : string;
			 static Join(path1: string, path2: string, path3: string) : string;
			 static Join(path1: string, path2: string, path3: string, path4: string) : string;
			 static Join(...paths: string[]) : string;
			 static TryJoin(path1: any, path2: any, destination: any, charsWritten: any) : boolean;
			 static TryJoin(path1: any, path2: any, path3: any, destination: any, charsWritten: any) : boolean;
			 static GetRelativePath(relativeTo: string, path: string) : string;
			 static TrimEndingDirectorySeparator(path: string) : string;
			 static TrimEndingDirectorySeparator(path: any) : any;
			 static EndsInDirectorySeparator(path: any) : boolean;
			 static EndsInDirectorySeparator(path: string) : boolean;
			 static GetInvalidFileNameChars() : number[];
			 static GetInvalidPathChars() : number[];
			 static GetFullPath(path: string) : string;
			 static GetFullPath(path: string, basePath: string) : string;
			 static GetTempPath() : string;
			 static GetTempFileName() : string;
			 static IsPathRooted(path: string) : boolean;
			 static IsPathRooted(path: any) : boolean;
			 static GetPathRoot(path: string) : string;
			 static GetPathRoot(path: any) : any;
			 static GetType() : System.Type;
			 static ToString() : string;
			 static Equals(obj: any) : boolean;
			 static GetHashCode() : number;
		}
		enum SearchOption {
			TopDirectoryOnly = 0,
			AllDirectories = 1,
		}
		enum SeekOrigin {
			Begin = 0,
			Current = 1,
			End = 2,
		}
		abstract class Stream extends System.MarshalByRefObject {
			CanRead: boolean;
			CanSeek: boolean;
			CanTimeout: boolean;
			CanWrite: boolean;
			Length: number;
			Position: number;
			ReadTimeout: number;
			WriteTimeout: number;
			 CopyToAsync(destination: System.IO.Stream) : System.Threading.Tasks.Task;
			 CopyToAsync(destination: System.IO.Stream, bufferSize: number) : System.Threading.Tasks.Task;
			 CopyToAsync(destination: System.IO.Stream, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 CopyToAsync(destination: System.IO.Stream, bufferSize: number, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 CopyTo(destination: System.IO.Stream) : void;
			 CopyTo(destination: System.IO.Stream, bufferSize: number) : void;
			 CopyTo(callback: any, state: any, bufferSize: number) : void;
			 CopyToAsync(callback: any, state: any, bufferSize: number, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 Close() : void;
			 Dispose() : void;
			 DisposeAsync() : System.Threading.Tasks.ValueTask;
			 Flush() : void;
			 FlushAsync() : System.Threading.Tasks.Task;
			 FlushAsync(cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 BeginRead(buffer: any, offset: number, count: number, callback: System.AsyncCallback, state: any) : System.IAsyncResult;
			 EndRead(asyncResult: System.IAsyncResult) : number;
			 ReadAsync(buffer: any, offset: number, count: number) : any;
			 ReadAsync(buffer: any, offset: number, count: number, cancellationToken: System.Threading.CancellationToken) : any;
			 ReadAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : any;
			 BeginWrite(buffer: any, offset: number, count: number, callback: System.AsyncCallback, state: any) : System.IAsyncResult;
			 EndWrite(asyncResult: System.IAsyncResult) : void;
			 WriteAsync(buffer: any, offset: number, count: number) : System.Threading.Tasks.Task;
			 WriteAsync(buffer: any, offset: number, count: number, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 WriteAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.ValueTask;
			 Seek(offset: number, origin: System.IO.SeekOrigin) : number;
			 SetLength(value: number) : void;
			 Read(buffer: any, offset: number, count: number) : number;
			 Read(buffer: any) : number;
			 ReadByte() : number;
			 Write(buffer: any, offset: number, count: number) : void;
			 Write(buffer: any) : void;
			 WriteByte(value: System.Byte) : void;
			 static Synchronized(stream: System.IO.Stream) : System.IO.Stream;
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class StreamReader extends System.IO.TextReader {
			CurrentEncoding: System.Text.Encoding;
			BaseStream: System.IO.Stream;
			EndOfStream: boolean;
			 constructor(stream: System.IO.Stream) ;
			 constructor(stream: System.IO.Stream, detectEncodingFromByteOrderMarks: boolean) ;
			 constructor(stream: System.IO.Stream, encoding: System.Text.Encoding) ;
			 constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean) ;
			 constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: number) ;
			 constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: number, leaveOpen: boolean) ;
			 constructor(path: string) ;
			 constructor(path: string, detectEncodingFromByteOrderMarks: boolean) ;
			 constructor(path: string, encoding: System.Text.Encoding) ;
			 constructor(path: string, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean) ;
			 constructor(path: string, encoding: System.Text.Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: number) ;
			 Close() : void;
			 DiscardBufferedData() : void;
			 Peek() : number;
			 Read() : number;
			 Read(buffer: number[], index: number, count: number) : number;
			 Read(buffer: any) : number;
			 ReadToEnd() : string;
			 ReadBlock(buffer: number[], index: number, count: number) : number;
			 ReadBlock(buffer: any) : number;
			 ReadLine() : string;
			 ReadLineAsync() : any;
			 ReadToEndAsync() : any;
			 ReadAsync(buffer: number[], index: number, count: number) : any;
			 ReadAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : any;
			 ReadBlockAsync(buffer: number[], index: number, count: number) : any;
			 ReadBlockAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : any;
			 Dispose() : void;
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class StreamWriter extends System.IO.TextWriter {
			AutoFlush: boolean;
			BaseStream: System.IO.Stream;
			Encoding: System.Text.Encoding;
			 constructor(stream: System.IO.Stream) ;
			 constructor(stream: System.IO.Stream, encoding: System.Text.Encoding) ;
			 constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, bufferSize: number) ;
			 constructor(stream: System.IO.Stream, encoding: System.Text.Encoding, bufferSize: number, leaveOpen: boolean) ;
			 constructor(path: string) ;
			 constructor(path: string, append: boolean) ;
			 constructor(path: string, append: boolean, encoding: System.Text.Encoding) ;
			 constructor(path: string, append: boolean, encoding: System.Text.Encoding, bufferSize: number) ;
			 Close() : void;
			 DisposeAsync() : System.Threading.Tasks.ValueTask;
			 Flush() : void;
			 Write(value: number) : void;
			 Write(buffer: number[]) : void;
			 Write(buffer: number[], index: number, count: number) : void;
			 Write(buffer: any) : void;
			 Write(value: string) : void;
			 WriteLine(value: string) : void;
			 WriteLine(value: any) : void;
			 Write(format: string, arg0: any) : void;
			 Write(format: string, arg0: any, arg1: any) : void;
			 Write(format: string, arg0: any, arg1: any, arg2: any) : void;
			 Write(format: string, ...arg: any) : void;
			 WriteLine(format: string, arg0: any) : void;
			 WriteLine(format: string, arg0: any, arg1: any) : void;
			 WriteLine(format: string, arg0: any, arg1: any, arg2: any) : void;
			 WriteLine(format: string, ...arg: any) : void;
			 WriteAsync(value: number) : System.Threading.Tasks.Task;
			 WriteAsync(value: string) : System.Threading.Tasks.Task;
			 WriteAsync(buffer: number[], index: number, count: number) : System.Threading.Tasks.Task;
			 WriteAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 WriteLineAsync() : System.Threading.Tasks.Task;
			 WriteLineAsync(value: number) : System.Threading.Tasks.Task;
			 WriteLineAsync(value: string) : System.Threading.Tasks.Task;
			 WriteLineAsync(buffer: number[], index: number, count: number) : System.Threading.Tasks.Task;
			 WriteLineAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 FlushAsync() : System.Threading.Tasks.Task;
			 Dispose() : void;
			 Write(value: boolean) : void;
			 Write(value: number) : void;
			 Write(value: System.UInt32) : void;
			 Write(value: number) : void;
			 Write(value: System.UInt64) : void;
			 Write(value: number) : void;
			 Write(value: System.Double) : void;
			 Write(value: number) : void;
			 Write(value: any) : void;
			 Write(value: System.Text.StringBuilder) : void;
			 WriteLine() : void;
			 WriteLine(value: number) : void;
			 WriteLine(buffer: number[]) : void;
			 WriteLine(buffer: number[], index: number, count: number) : void;
			 WriteLine(value: boolean) : void;
			 WriteLine(value: number) : void;
			 WriteLine(value: System.UInt32) : void;
			 WriteLine(value: number) : void;
			 WriteLine(value: System.UInt64) : void;
			 WriteLine(value: number) : void;
			 WriteLine(value: System.Double) : void;
			 WriteLine(value: number) : void;
			 WriteLine(value: System.Text.StringBuilder) : void;
			 WriteLine(value: any) : void;
			 WriteAsync(value: System.Text.StringBuilder, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 WriteAsync(buffer: number[]) : System.Threading.Tasks.Task;
			 WriteLineAsync(value: System.Text.StringBuilder, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 WriteLineAsync(buffer: number[]) : System.Threading.Tasks.Task;
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class TextReader extends System.MarshalByRefObject {
			 Close() : void;
			 Dispose() : void;
			 Peek() : number;
			 Read() : number;
			 Read(buffer: number[], index: number, count: number) : number;
			 Read(buffer: any) : number;
			 ReadToEnd() : string;
			 ReadBlock(buffer: number[], index: number, count: number) : number;
			 ReadBlock(buffer: any) : number;
			 ReadLine() : string;
			 ReadLineAsync() : any;
			 ReadToEndAsync() : any;
			 ReadAsync(buffer: number[], index: number, count: number) : any;
			 ReadAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : any;
			 ReadBlockAsync(buffer: number[], index: number, count: number) : any;
			 ReadBlockAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : any;
			 static Synchronized(reader: System.IO.TextReader) : System.IO.TextReader;
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class TextWriter extends System.MarshalByRefObject {
			FormatProvider: System.IFormatProvider;
			Encoding: System.Text.Encoding;
			NewLine: string;
			 Close() : void;
			 Dispose() : void;
			 DisposeAsync() : System.Threading.Tasks.ValueTask;
			 Flush() : void;
			 Write(value: number) : void;
			 Write(buffer: number[]) : void;
			 Write(buffer: number[], index: number, count: number) : void;
			 Write(buffer: any) : void;
			 Write(value: boolean) : void;
			 Write(value: number) : void;
			 Write(value: System.UInt32) : void;
			 Write(value: number) : void;
			 Write(value: System.UInt64) : void;
			 Write(value: number) : void;
			 Write(value: System.Double) : void;
			 Write(value: number) : void;
			 Write(value: string) : void;
			 Write(value: any) : void;
			 Write(value: System.Text.StringBuilder) : void;
			 Write(format: string, arg0: any) : void;
			 Write(format: string, arg0: any, arg1: any) : void;
			 Write(format: string, arg0: any, arg1: any, arg2: any) : void;
			 Write(format: string, ...arg: any) : void;
			 WriteLine() : void;
			 WriteLine(value: number) : void;
			 WriteLine(buffer: number[]) : void;
			 WriteLine(buffer: number[], index: number, count: number) : void;
			 WriteLine(buffer: any) : void;
			 WriteLine(value: boolean) : void;
			 WriteLine(value: number) : void;
			 WriteLine(value: System.UInt32) : void;
			 WriteLine(value: number) : void;
			 WriteLine(value: System.UInt64) : void;
			 WriteLine(value: number) : void;
			 WriteLine(value: System.Double) : void;
			 WriteLine(value: number) : void;
			 WriteLine(value: string) : void;
			 WriteLine(value: System.Text.StringBuilder) : void;
			 WriteLine(value: any) : void;
			 WriteLine(format: string, arg0: any) : void;
			 WriteLine(format: string, arg0: any, arg1: any) : void;
			 WriteLine(format: string, arg0: any, arg1: any, arg2: any) : void;
			 WriteLine(format: string, ...arg: any) : void;
			 WriteAsync(value: number) : System.Threading.Tasks.Task;
			 WriteAsync(value: string) : System.Threading.Tasks.Task;
			 WriteAsync(value: System.Text.StringBuilder, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 WriteAsync(buffer: number[]) : System.Threading.Tasks.Task;
			 WriteAsync(buffer: number[], index: number, count: number) : System.Threading.Tasks.Task;
			 WriteAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 WriteLineAsync(value: number) : System.Threading.Tasks.Task;
			 WriteLineAsync(value: string) : System.Threading.Tasks.Task;
			 WriteLineAsync(value: System.Text.StringBuilder, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 WriteLineAsync(buffer: number[]) : System.Threading.Tasks.Task;
			 WriteLineAsync(buffer: number[], index: number, count: number) : System.Threading.Tasks.Task;
			 WriteLineAsync(buffer: any, cancellationToken?: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 WriteLineAsync() : System.Threading.Tasks.Task;
			 FlushAsync() : System.Threading.Tasks.Task;
			 static Synchronized(writer: System.IO.TextWriter) : System.IO.TextWriter;
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module System.Threading.Tasks {
		class Task {
			Id: number;
			Exception: System.AggregateException;
			Status: System.Threading.Tasks.TaskStatus;
			IsCanceled: boolean;
			IsCompleted: boolean;
			IsCompletedSuccessfully: boolean;
			CreationOptions: System.Threading.Tasks.TaskCreationOptions;
			AsyncState: any;
			IsFaulted: boolean;
			 constructor(action: System.Action) ;
			 constructor(action: System.Action, cancellationToken: System.Threading.CancellationToken) ;
			 constructor(action: System.Action, creationOptions: System.Threading.Tasks.TaskCreationOptions) ;
			 constructor(action: System.Action, cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions) ;
			 constructor(action: any, state: any) ;
			 constructor(action: any, state: any, cancellationToken: System.Threading.CancellationToken) ;
			 constructor(action: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) ;
			 constructor(action: any, state: any, cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions) ;
			 static WaitAny(...tasks: any) : number;
			 static WaitAny(tasks: any, timeout: System.TimeSpan) : number;
			 static WaitAny(tasks: any, cancellationToken: System.Threading.CancellationToken) : number;
			 static WaitAny(tasks: any, millisecondsTimeout: number) : number;
			 static WaitAny(tasks: any, millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken) : number;
			 static FromResult(result: any) : any;
			 static FromException(exception: System.Exception) : System.Threading.Tasks.Task;
			 static FromException(exception: System.Exception) : any;
			 static FromCanceled(cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static FromCanceled(cancellationToken: System.Threading.CancellationToken) : any;
			 static Run(action: System.Action) : System.Threading.Tasks.Task;
			 static Run(action: System.Action, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static Run(_function: any) : any;
			 static Run(_function: any, cancellationToken: System.Threading.CancellationToken) : any;
			 static Run(_function: any) : System.Threading.Tasks.Task;
			 static Run(_function: any, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static Run(_function: any) : any;
			 static Run(_function: any, cancellationToken: System.Threading.CancellationToken) : any;
			 static Delay(delay: System.TimeSpan) : System.Threading.Tasks.Task;
			 static Delay(delay: System.TimeSpan, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static Delay(millisecondsDelay: number) : System.Threading.Tasks.Task;
			 static Delay(millisecondsDelay: number, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 static WhenAll(tasks: any) : System.Threading.Tasks.Task;
			 static WhenAll(...tasks: any) : System.Threading.Tasks.Task;
			 static WhenAll(tasks: any) : any;
			 static WhenAll(...tasks: any) : any;
			 static WhenAny(...tasks: any) : any;
			 static WhenAny(tasks: any) : any;
			 static WhenAny(...tasks: any) : any;
			 static WhenAny(tasks: any) : any;
			 GetAwaiter() : System.Runtime.CompilerServices.TaskAwaiter;
			 ConfigureAwait(continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredTaskAwaitable;
			 static Yield() : System.Runtime.CompilerServices.YieldAwaitable;
			 Wait() : void;
			 Wait(timeout: System.TimeSpan) : boolean;
			 Wait(cancellationToken: System.Threading.CancellationToken) : void;
			 Wait(millisecondsTimeout: number) : boolean;
			 Wait(millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken) : boolean;
			 ContinueWith(continuationAction: any) : System.Threading.Tasks.Task;
			 ContinueWith(continuationAction: any, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 ContinueWith(continuationAction: any, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 ContinueWith(continuationAction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : System.Threading.Tasks.Task;
			 ContinueWith(continuationAction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 ContinueWith(continuationAction: any, state: any) : System.Threading.Tasks.Task;
			 ContinueWith(continuationAction: any, state: any, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 ContinueWith(continuationAction: any, state: any, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 ContinueWith(continuationAction: any, state: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : System.Threading.Tasks.Task;
			 ContinueWith(continuationAction: any, state: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 ContinueWith(continuationFunction: any) : any;
			 ContinueWith(continuationFunction: any, cancellationToken: System.Threading.CancellationToken) : any;
			 ContinueWith(continuationFunction: any, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 ContinueWith(continuationFunction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : any;
			 ContinueWith(continuationFunction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 ContinueWith(continuationFunction: any, state: any) : any;
			 ContinueWith(continuationFunction: any, state: any, cancellationToken: System.Threading.CancellationToken) : any;
			 ContinueWith(continuationFunction: any, state: any, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 ContinueWith(continuationFunction: any, state: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : any;
			 ContinueWith(continuationFunction: any, state: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 static WaitAll(...tasks: any) : void;
			 static WaitAll(tasks: any, timeout: System.TimeSpan) : boolean;
			 static WaitAll(tasks: any, millisecondsTimeout: number) : boolean;
			 static WaitAll(tasks: any, cancellationToken: System.Threading.CancellationToken) : void;
			 static WaitAll(tasks: any, millisecondsTimeout: number, cancellationToken: System.Threading.CancellationToken) : boolean;
			 Start() : void;
			 Start(scheduler: System.Threading.Tasks.TaskScheduler) : void;
			 RunSynchronously() : void;
			 RunSynchronously(scheduler: System.Threading.Tasks.TaskScheduler) : void;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum TaskContinuationOptions {
			None = 0,
			PreferFairness = 1,
			LongRunning = 2,
			AttachedToParent = 4,
			DenyChildAttach = 8,
			HideScheduler = 16,
			LazyCancellation = 32,
			RunContinuationsAsynchronously = 64,
			NotOnRanToCompletion = 65536,
			NotOnFaulted = 131072,
			NotOnCanceled = 262144,
			OnlyOnRanToCompletion = 393216,
			OnlyOnFaulted = 327680,
			OnlyOnCanceled = 196608,
			ExecuteSynchronously = 524288,
		}
		/** Flags */
		enum TaskCreationOptions {
			None = 0,
			PreferFairness = 1,
			LongRunning = 2,
			AttachedToParent = 4,
			DenyChildAttach = 8,
			HideScheduler = 16,
			RunContinuationsAsynchronously = 64,
		}
		class TaskFactory {
			CancellationToken: System.Threading.CancellationToken;
			Scheduler: System.Threading.Tasks.TaskScheduler;
			CreationOptions: System.Threading.Tasks.TaskCreationOptions;
			ContinuationOptions: System.Threading.Tasks.TaskContinuationOptions;
			 constructor() ;
			 constructor(cancellationToken: System.Threading.CancellationToken) ;
			 constructor(scheduler: System.Threading.Tasks.TaskScheduler) ;
			 constructor(creationOptions: System.Threading.Tasks.TaskCreationOptions, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) ;
			 constructor(cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) ;
			 ContinueWhenAll(tasks: any, continuationFunction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : any;
			 ContinueWhenAll(tasks: any, continuationFunction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 ContinueWhenAll(tasks: any, continuationFunction: any) : any;
			 ContinueWhenAll(tasks: any, continuationFunction: any, cancellationToken: System.Threading.CancellationToken) : any;
			 ContinueWhenAll(tasks: any, continuationFunction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : any;
			 ContinueWhenAll(tasks: any, continuationFunction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 ContinueWhenAny(tasks: any, continuationAction: any) : System.Threading.Tasks.Task;
			 ContinueWhenAny(tasks: any, continuationAction: any, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 ContinueWhenAny(tasks: any, continuationAction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : System.Threading.Tasks.Task;
			 ContinueWhenAny(tasks: any, continuationAction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 ContinueWhenAny(tasks: any, continuationFunction: any) : any;
			 ContinueWhenAny(tasks: any, continuationFunction: any, cancellationToken: System.Threading.CancellationToken) : any;
			 ContinueWhenAny(tasks: any, continuationFunction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : any;
			 ContinueWhenAny(tasks: any, continuationFunction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 ContinueWhenAny(tasks: any, continuationFunction: any) : any;
			 ContinueWhenAny(tasks: any, continuationFunction: any, cancellationToken: System.Threading.CancellationToken) : any;
			 ContinueWhenAny(tasks: any, continuationFunction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : any;
			 ContinueWhenAny(tasks: any, continuationFunction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 ContinueWhenAny(tasks: any, continuationAction: any) : System.Threading.Tasks.Task;
			 ContinueWhenAny(tasks: any, continuationAction: any, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 ContinueWhenAny(tasks: any, continuationAction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : System.Threading.Tasks.Task;
			 ContinueWhenAny(tasks: any, continuationAction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 StartNew(action: System.Action) : System.Threading.Tasks.Task;
			 StartNew(action: System.Action, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 StartNew(action: System.Action, creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task;
			 StartNew(action: System.Action, cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 StartNew(action: any, state: any) : System.Threading.Tasks.Task;
			 StartNew(action: any, state: any, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 StartNew(action: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task;
			 StartNew(action: any, state: any, cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 StartNew(_function: any) : any;
			 StartNew(_function: any, cancellationToken: System.Threading.CancellationToken) : any;
			 StartNew(_function: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : any;
			 StartNew(_function: any, cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 StartNew(_function: any, state: any) : any;
			 StartNew(_function: any, state: any, cancellationToken: System.Threading.CancellationToken) : any;
			 StartNew(_function: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : any;
			 StartNew(_function: any, state: any, cancellationToken: System.Threading.CancellationToken, creationOptions: System.Threading.Tasks.TaskCreationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 FromAsync(asyncResult: System.IAsyncResult, endMethod: any) : System.Threading.Tasks.Task;
			 FromAsync(asyncResult: System.IAsyncResult, endMethod: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task;
			 FromAsync(asyncResult: System.IAsyncResult, endMethod: any, creationOptions: System.Threading.Tasks.TaskCreationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 FromAsync(beginMethod: any, endMethod: any, state: any) : System.Threading.Tasks.Task;
			 FromAsync(beginMethod: any, endMethod: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, state: any) : System.Threading.Tasks.Task;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, arg2: any, state: any) : System.Threading.Tasks.Task;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, arg2: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, arg2: any, arg3: any, state: any) : System.Threading.Tasks.Task;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, arg2: any, arg3: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : System.Threading.Tasks.Task;
			 FromAsync(asyncResult: System.IAsyncResult, endMethod: any) : any;
			 FromAsync(asyncResult: System.IAsyncResult, endMethod: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : any;
			 FromAsync(asyncResult: System.IAsyncResult, endMethod: any, creationOptions: System.Threading.Tasks.TaskCreationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : any;
			 FromAsync(beginMethod: any, endMethod: any, state: any) : any;
			 FromAsync(beginMethod: any, endMethod: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : any;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, state: any) : any;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : any;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, arg2: any, state: any) : any;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, arg2: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : any;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, arg2: any, arg3: any, state: any) : any;
			 FromAsync(beginMethod: any, endMethod: any, arg1: any, arg2: any, arg3: any, state: any, creationOptions: System.Threading.Tasks.TaskCreationOptions) : any;
			 ContinueWhenAll(tasks: any, continuationAction: any) : System.Threading.Tasks.Task;
			 ContinueWhenAll(tasks: any, continuationAction: any, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 ContinueWhenAll(tasks: any, continuationAction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : System.Threading.Tasks.Task;
			 ContinueWhenAll(tasks: any, continuationAction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 ContinueWhenAll(tasks: any, continuationAction: any) : System.Threading.Tasks.Task;
			 ContinueWhenAll(tasks: any, continuationAction: any, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 ContinueWhenAll(tasks: any, continuationAction: any, continuationOptions: System.Threading.Tasks.TaskContinuationOptions) : System.Threading.Tasks.Task;
			 ContinueWhenAll(tasks: any, continuationAction: any, cancellationToken: System.Threading.CancellationToken, continuationOptions: System.Threading.Tasks.TaskContinuationOptions, scheduler: System.Threading.Tasks.TaskScheduler) : System.Threading.Tasks.Task;
			 ContinueWhenAll(tasks: any, continuationFunction: any) : any;
			 ContinueWhenAll(tasks: any, continuationFunction: any, cancellationToken: System.Threading.CancellationToken) : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class TaskScheduler {
			MaximumConcurrencyLevel: number;
			Id: number;
			 static FromCurrentSynchronizationContext() : System.Threading.Tasks.TaskScheduler;
			 static add_UnobservedTaskException(value: any) : void;
			 static remove_UnobservedTaskException(value: any) : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			static UnobservedTaskException: { connect: (callback: (sender: any, e: any) => void) => {disconnect: () => void} };
		}
		enum TaskStatus {
			Created = 0,
			WaitingForActivation = 1,
			WaitingToRun = 2,
			Running = 3,
			WaitingForChildrenToComplete = 4,
			RanToCompletion = 5,
			Canceled = 6,
			Faulted = 7,
		}
		class ValueTask extends System.ValueType {
			IsCompleted: boolean;
			IsCompletedSuccessfully: boolean;
			IsFaulted: boolean;
			IsCanceled: boolean;
			 constructor(task: System.Threading.Tasks.Task) ;
			 constructor(source: any, token: number) ;
			 GetHashCode() : number;
			 Equals(obj: any) : boolean;
			 Equals(other: System.Threading.Tasks.ValueTask) : boolean;
			 static op_Equality(left: System.Threading.Tasks.ValueTask, right: System.Threading.Tasks.ValueTask) : boolean;
			 static op_Inequality(left: System.Threading.Tasks.ValueTask, right: System.Threading.Tasks.ValueTask) : boolean;
			 AsTask() : System.Threading.Tasks.Task;
			 Preserve() : System.Threading.Tasks.ValueTask;
			 GetAwaiter() : System.Runtime.CompilerServices.ValueTaskAwaiter;
			 ConfigureAwait(continueOnCapturedContext: boolean) : System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable;
			 ToString() : string;
			 GetType() : System.Type;
		}
	}
	module System.Threading {
		class CancellationToken extends System.ValueType {
			IsCancellationRequested: boolean;
			CanBeCanceled: boolean;
			WaitHandle: System.Threading.WaitHandle;
			 constructor(canceled: boolean) ;
			 Register(callback: System.Action) : System.Threading.CancellationTokenRegistration;
			 Register(callback: System.Action, useSynchronizationContext: boolean) : System.Threading.CancellationTokenRegistration;
			 Register(callback: any, state: any) : System.Threading.CancellationTokenRegistration;
			 Register(callback: any, state: any, useSynchronizationContext: boolean) : System.Threading.CancellationTokenRegistration;
			 UnsafeRegister(callback: any, state: any) : System.Threading.CancellationTokenRegistration;
			 Equals(other: System.Threading.CancellationToken) : boolean;
			 Equals(other: any) : boolean;
			 GetHashCode() : number;
			 static op_Equality(left: System.Threading.CancellationToken, right: System.Threading.CancellationToken) : boolean;
			 static op_Inequality(left: System.Threading.CancellationToken, right: System.Threading.CancellationToken) : boolean;
			 ThrowIfCancellationRequested() : void;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class CancellationTokenRegistration extends System.ValueType {
			Token: System.Threading.CancellationToken;
			 Dispose() : void;
			 DisposeAsync() : System.Threading.Tasks.ValueTask;
			 Unregister() : boolean;
			 static op_Equality(left: System.Threading.CancellationTokenRegistration, right: System.Threading.CancellationTokenRegistration) : boolean;
			 static op_Inequality(left: System.Threading.CancellationTokenRegistration, right: System.Threading.CancellationTokenRegistration) : boolean;
			 Equals(obj: any) : boolean;
			 Equals(other: System.Threading.CancellationTokenRegistration) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		abstract class WaitHandle extends System.MarshalByRefObject {
			Handle: System.IntPtr;
			SafeWaitHandle: Microsoft.Win32.SafeHandles.SafeWaitHandle;
			 Close() : void;
			 Dispose() : void;
			 WaitOne(millisecondsTimeout: number) : boolean;
			 WaitOne(timeout: System.TimeSpan) : boolean;
			 WaitOne() : boolean;
			 WaitOne(millisecondsTimeout: number, exitContext: boolean) : boolean;
			 WaitOne(timeout: System.TimeSpan, exitContext: boolean) : boolean;
			 static WaitAll(waitHandles: any, millisecondsTimeout: number) : boolean;
			 static WaitAll(waitHandles: any, timeout: System.TimeSpan) : boolean;
			 static WaitAll(waitHandles: any) : boolean;
			 static WaitAll(waitHandles: any, millisecondsTimeout: number, exitContext: boolean) : boolean;
			 static WaitAll(waitHandles: any, timeout: System.TimeSpan, exitContext: boolean) : boolean;
			 static WaitAny(waitHandles: any, millisecondsTimeout: number) : number;
			 static WaitAny(waitHandles: any, timeout: System.TimeSpan) : number;
			 static WaitAny(waitHandles: any) : number;
			 static WaitAny(waitHandles: any, millisecondsTimeout: number, exitContext: boolean) : number;
			 static WaitAny(waitHandles: any, timeout: System.TimeSpan, exitContext: boolean) : number;
			 static SignalAndWait(toSignal: System.Threading.WaitHandle, toWaitOn: System.Threading.WaitHandle) : boolean;
			 static SignalAndWait(toSignal: System.Threading.WaitHandle, toWaitOn: System.Threading.WaitHandle, timeout: System.TimeSpan, exitContext: boolean) : boolean;
			 static SignalAndWait(toSignal: System.Threading.WaitHandle, toWaitOn: System.Threading.WaitHandle, millisecondsTimeout: number, exitContext: boolean) : boolean;
			 GetLifetimeService() : any;
			 InitializeLifetimeService() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module Microsoft.Win32.SafeHandles {
		class SafeFileHandle extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid {
			 constructor(preexistingHandle: System.IntPtr, ownsHandle: boolean) ;
			 DangerousGetHandle() : System.IntPtr;
			 Close() : void;
			 Dispose() : void;
			 SetHandleAsInvalid() : void;
			 DangerousAddRef(success: any) : void;
			 DangerousRelease() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class SafeHandleZeroOrMinusOneIsInvalid extends System.Runtime.InteropServices.SafeHandle {
			IsInvalid: boolean;
			 DangerousGetHandle() : System.IntPtr;
			 Close() : void;
			 Dispose() : void;
			 SetHandleAsInvalid() : void;
			 DangerousAddRef(success: any) : void;
			 DangerousRelease() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class SafeWaitHandle extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid {
			 constructor(existingHandle: System.IntPtr, ownsHandle: boolean) ;
			 DangerousGetHandle() : System.IntPtr;
			 Close() : void;
			 Dispose() : void;
			 SetHandleAsInvalid() : void;
			 DangerousAddRef(success: any) : void;
			 DangerousRelease() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module System.Runtime.InteropServices {
		enum LayoutKind {
			Sequential = 0,
			Explicit = 2,
			Auto = 3,
		}
		abstract class SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject {
			IsClosed: boolean;
			IsInvalid: boolean;
			 DangerousGetHandle() : System.IntPtr;
			 Close() : void;
			 Dispose() : void;
			 SetHandleAsInvalid() : void;
			 DangerousAddRef(success: any) : void;
			 DangerousRelease() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class StructLayoutAttribute extends System.Attribute {
			Pack: number;
			Size: number;
			CharSet: any;
			Value: System.Runtime.InteropServices.LayoutKind;
			 constructor(layoutKind: System.Runtime.InteropServices.LayoutKind) ;
			 constructor(layoutKind: number) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
	}
	module System.Runtime.ConstrainedExecution {
		abstract class CriticalFinalizerObject {
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module System.Runtime.CompilerServices {
		class ConfiguredTaskAwaitable extends System.ValueType {
			 GetAwaiter() : any;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class ConfiguredValueTaskAwaitable extends System.ValueType {
			 GetAwaiter() : any;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class TaskAwaiter extends System.ValueType {
			IsCompleted: boolean;
			 OnCompleted(continuation: System.Action) : void;
			 UnsafeOnCompleted(continuation: System.Action) : void;
			 GetResult() : void;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class ValueTaskAwaiter extends System.ValueType {
			IsCompleted: boolean;
			 GetResult() : void;
			 OnCompleted(continuation: System.Action) : void;
			 UnsafeOnCompleted(continuation: System.Action) : void;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class YieldAwaitable extends System.ValueType {
			 GetAwaiter() : any;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
	}
	module System.Collections {
		class DictionaryEntry extends System.ValueType {
			Key: any;
			Value: any;
			 constructor(key: any, value: any) ;
			 Deconstruct(key: any, value: any) : void;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		interface ICollection {
			Count: number;
			SyncRoot: any;
			IsSynchronized: boolean;
			 CopyTo(array: System.Array, index: number) : void;
		}
		interface IComparer {
			 Compare(x: any, y: any) : number;
		}
		interface IDictionary {
			Item: any;
			Keys: System.Collections.ICollection;
			Values: System.Collections.ICollection;
			IsReadOnly: boolean;
			IsFixedSize: boolean;
			 Contains(key: any) : boolean;
			 Add(key: any, value: any) : void;
			 Clear() : void;
			 GetEnumerator() : System.Collections.IDictionaryEnumerator;
			 Remove(key: any) : void;
		}
		interface IDictionaryEnumerator {
			Key: any;
			Value: any;
			Entry: System.Collections.DictionaryEntry;
		}
		interface IEnumerator {
			Current: any;
			 MoveNext() : boolean;
			 Reset() : void;
		}
	}
	module System.Security {
		class SecureString {
			Length: number;
			 constructor() ;
			 constructor(value: any, length: number) ;
			 AppendChar(c: number) : void;
			 Clear() : void;
			 Copy() : System.Security.SecureString;
			 Dispose() : void;
			 InsertAt(index: number, c: number) : void;
			 IsReadOnly() : boolean;
			 MakeReadOnly() : void;
			 RemoveAt(index: number) : void;
			 SetAt(index: number, c: number) : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum SecurityRuleSet {
			None = 0,
			Level1 = 1,
			Level2 = 2,
		}
	}
	module Mono.Cecil {
		class ArrayDimension extends System.ValueType {
			LowerBound: any;
			UpperBound: any;
			IsSized: boolean;
			 constructor(lowerBound: any, upperBound: any) ;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 GetType() : System.Type;
		}
		class ArrayMarshalInfo extends Mono.Cecil.MarshalInfo {
			ElementType: Mono.Cecil.NativeType;
			SizeParameterIndex: number;
			Size: number;
			SizeParameterMultiplier: number;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ArrayType extends Mono.Cecil.TypeSpecification {
			Dimensions: any;
			Rank: number;
			IsVector: boolean;
			IsValueType: boolean;
			Name: string;
			FullName: string;
			IsArray: boolean;
			 constructor(type: Mono.Cecil.TypeReference) ;
			 constructor(type: Mono.Cecil.TypeReference, rank: number) ;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum AssemblyAttributes {
			PublicKey = 1,
			SideBySideCompatible = 0,
			Retargetable = 256,
			WindowsRuntime = 512,
			DisableJITCompileOptimizer = 16384,
			EnableJITCompileTracking = 32768,
		}
		class AssemblyDefinition {
			Name: Mono.Cecil.AssemblyNameDefinition;
			FullName: string;
			MetadataToken: Mono.Cecil.MetadataToken;
			Modules: any;
			MainModule: Mono.Cecil.ModuleDefinition;
			EntryPoint: Mono.Cecil.MethodDefinition;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			HasSecurityDeclarations: boolean;
			SecurityDeclarations: any;
			 Dispose() : void;
			 static CreateAssembly(assemblyName: Mono.Cecil.AssemblyNameDefinition, moduleName: string, kind: Mono.Cecil.ModuleKind) : Mono.Cecil.AssemblyDefinition;
			 static CreateAssembly(assemblyName: Mono.Cecil.AssemblyNameDefinition, moduleName: string, parameters: Mono.Cecil.ModuleParameters) : Mono.Cecil.AssemblyDefinition;
			 static ReadAssembly(fileName: string) : Mono.Cecil.AssemblyDefinition;
			 static ReadAssembly(fileName: string, parameters: Mono.Cecil.ReaderParameters) : Mono.Cecil.AssemblyDefinition;
			 static ReadAssembly(stream: System.IO.Stream) : Mono.Cecil.AssemblyDefinition;
			 static ReadAssembly(stream: System.IO.Stream, parameters: Mono.Cecil.ReaderParameters) : Mono.Cecil.AssemblyDefinition;
			 Write(fileName: string) : void;
			 Write(fileName: string, parameters: Mono.Cecil.WriterParameters) : void;
			 Write() : void;
			 Write(parameters: Mono.Cecil.WriterParameters) : void;
			 Write(stream: System.IO.Stream) : void;
			 Write(stream: System.IO.Stream, parameters: Mono.Cecil.WriterParameters) : void;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum AssemblyHashAlgorithm {
			None = 0,
			Reserved = 32771,
			SHA1 = 32772,
		}
		class AssemblyLinkedResource extends Mono.Cecil.Resource {
			Assembly: Mono.Cecil.AssemblyNameReference;
			ResourceType: Mono.Cecil.ResourceType;
			 constructor(name: string, flags: Mono.Cecil.ManifestResourceAttributes) ;
			 constructor(name: string, flags: Mono.Cecil.ManifestResourceAttributes, reference: Mono.Cecil.AssemblyNameReference) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class AssemblyNameDefinition extends Mono.Cecil.AssemblyNameReference {
			Hash: any;
			 constructor(name: string, version: System.Version) ;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class AssemblyNameReference {
			Name: string;
			Culture: string;
			Version: System.Version;
			Attributes: Mono.Cecil.AssemblyAttributes;
			HasPublicKey: boolean;
			IsSideBySideCompatible: boolean;
			IsRetargetable: boolean;
			IsWindowsRuntime: boolean;
			PublicKey: any;
			PublicKeyToken: any;
			MetadataScopeType: Mono.Cecil.MetadataScopeType;
			FullName: string;
			HashAlgorithm: Mono.Cecil.AssemblyHashAlgorithm;
			Hash: any;
			MetadataToken: Mono.Cecil.MetadataToken;
			 constructor(name: string, version: System.Version) ;
			 static Parse(fullName: string) : Mono.Cecil.AssemblyNameReference;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class AssemblyResolutionException extends System.IO.FileNotFoundException {
			AssemblyReference: Mono.Cecil.AssemblyNameReference;
			 constructor(reference: Mono.Cecil.AssemblyNameReference) ;
			 constructor(reference: Mono.Cecil.AssemblyNameReference, innerException: System.Exception) ;
			 ToString() : string;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 GetBaseException() : System.Exception;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class AssemblyResolveEventArgs extends System.EventArgs {
			AssemblyReference: Mono.Cecil.AssemblyNameReference;
			 constructor(reference: Mono.Cecil.AssemblyNameReference) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class AssemblyResolveEventHandler extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(sender: any, reference: Mono.Cecil.AssemblyNameReference) : Mono.Cecil.AssemblyDefinition;
			 BeginInvoke(sender: any, reference: Mono.Cecil.AssemblyNameReference, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : Mono.Cecil.AssemblyDefinition;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		abstract class BaseAssemblyResolver {
			 AddSearchDirectory(directory: string) : void;
			 RemoveSearchDirectory(directory: string) : void;
			 GetSearchDirectories() : string[];
			 add_ResolveFailure(value: Mono.Cecil.AssemblyResolveEventHandler) : void;
			 remove_ResolveFailure(value: Mono.Cecil.AssemblyResolveEventHandler) : void;
			 Resolve(name: Mono.Cecil.AssemblyNameReference) : Mono.Cecil.AssemblyDefinition;
			 Resolve(name: Mono.Cecil.AssemblyNameReference, parameters: Mono.Cecil.ReaderParameters) : Mono.Cecil.AssemblyDefinition;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			ResolveFailure: { connect: (callback: (sender: any, reference: Mono.Cecil.AssemblyNameReference) => Mono.Cecil.AssemblyDefinition) => {disconnect: () => void} };
		}
		class ByReferenceType extends Mono.Cecil.TypeSpecification {
			Name: string;
			FullName: string;
			IsValueType: boolean;
			IsByReference: boolean;
			 constructor(type: Mono.Cecil.TypeReference) ;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class CallSite {
			HasThis: boolean;
			ExplicitThis: boolean;
			CallingConvention: Mono.Cecil.MethodCallingConvention;
			HasParameters: boolean;
			Parameters: any;
			ReturnType: Mono.Cecil.TypeReference;
			MethodReturnType: Mono.Cecil.MethodReturnType;
			Name: string;
			Namespace: string;
			Module: Mono.Cecil.ModuleDefinition;
			Scope: Mono.Cecil.IMetadataScope;
			MetadataToken: Mono.Cecil.MetadataToken;
			FullName: string;
			 constructor(returnType: Mono.Cecil.TypeReference) ;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class CustomAttribute {
			Constructor: Mono.Cecil.MethodReference;
			AttributeType: Mono.Cecil.TypeReference;
			IsResolved: boolean;
			HasConstructorArguments: boolean;
			ConstructorArguments: any;
			HasFields: boolean;
			Fields: any;
			HasProperties: boolean;
			Properties: any;
			 constructor(constructor: Mono.Cecil.MethodReference) ;
			 constructor(constructor: Mono.Cecil.MethodReference, blob: any) ;
			 GetBlob() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class CustomAttributeArgument extends System.ValueType {
			Type: Mono.Cecil.TypeReference;
			Value: any;
			 constructor(type: Mono.Cecil.TypeReference, value: any) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class CustomAttributeNamedArgument extends System.ValueType {
			Name: string;
			Argument: Mono.Cecil.CustomAttributeArgument;
			 constructor(name: string, argument: Mono.Cecil.CustomAttributeArgument) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class CustomMarshalInfo extends Mono.Cecil.MarshalInfo {
			Guid: System.Guid;
			UnmanagedType: string;
			ManagedType: Mono.Cecil.TypeReference;
			Cookie: string;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class DefaultAssemblyResolver extends Mono.Cecil.BaseAssemblyResolver {
			 constructor() ;
			 Resolve(name: Mono.Cecil.AssemblyNameReference) : Mono.Cecil.AssemblyDefinition;
			 AddSearchDirectory(directory: string) : void;
			 RemoveSearchDirectory(directory: string) : void;
			 GetSearchDirectories() : string[];
			 add_ResolveFailure(value: Mono.Cecil.AssemblyResolveEventHandler) : void;
			 remove_ResolveFailure(value: Mono.Cecil.AssemblyResolveEventHandler) : void;
			 Resolve(name: Mono.Cecil.AssemblyNameReference, parameters: Mono.Cecil.ReaderParameters) : Mono.Cecil.AssemblyDefinition;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			ResolveFailure: { connect: (callback: (sender: any, reference: Mono.Cecil.AssemblyNameReference) => Mono.Cecil.AssemblyDefinition) => {disconnect: () => void} };
		}
		class DefaultMetadataImporter {
			 constructor(module: Mono.Cecil.ModuleDefinition) ;
			 ImportReference(name: Mono.Cecil.AssemblyNameReference) : Mono.Cecil.AssemblyNameReference;
			 ImportReference(type: Mono.Cecil.TypeReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.TypeReference;
			 ImportReference(field: Mono.Cecil.FieldReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.FieldReference;
			 ImportReference(method: Mono.Cecil.MethodReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.MethodReference;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class DefaultReflectionImporter {
			 constructor(module: Mono.Cecil.ModuleDefinition) ;
			 ImportReference(name: System.Reflection.AssemblyName) : Mono.Cecil.AssemblyNameReference;
			 ImportReference(type: System.Type, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.TypeReference;
			 ImportReference(field: System.Reflection.FieldInfo, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.FieldReference;
			 ImportReference(method: System.Reflection.MethodBase, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.MethodReference;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class EmbeddedResource extends Mono.Cecil.Resource {
			ResourceType: Mono.Cecil.ResourceType;
			 constructor(name: string, attributes: Mono.Cecil.ManifestResourceAttributes, data: any) ;
			 constructor(name: string, attributes: Mono.Cecil.ManifestResourceAttributes, stream: System.IO.Stream) ;
			 GetResourceStream() : System.IO.Stream;
			 GetResourceData() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum EventAttributes {
			None = 0,
			SpecialName = 512,
			RTSpecialName = 1024,
		}
		class EventDefinition extends Mono.Cecil.EventReference {
			Attributes: Mono.Cecil.EventAttributes;
			AddMethod: Mono.Cecil.MethodDefinition;
			InvokeMethod: Mono.Cecil.MethodDefinition;
			RemoveMethod: Mono.Cecil.MethodDefinition;
			HasOtherMethods: boolean;
			OtherMethods: any;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			IsSpecialName: boolean;
			IsRuntimeSpecialName: boolean;
			DeclaringType: Mono.Cecil.TypeDefinition;
			IsDefinition: boolean;
			 constructor(name: string, attributes: Mono.Cecil.EventAttributes, eventType: Mono.Cecil.TypeReference) ;
			 Resolve() : Mono.Cecil.EventDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class EventReference extends Mono.Cecil.MemberReference {
			EventType: Mono.Cecil.TypeReference;
			FullName: string;
			 Resolve() : Mono.Cecil.EventDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ExportedType {
			Namespace: string;
			Name: string;
			Attributes: Mono.Cecil.TypeAttributes;
			Scope: Mono.Cecil.IMetadataScope;
			DeclaringType: Mono.Cecil.ExportedType;
			MetadataToken: Mono.Cecil.MetadataToken;
			Identifier: number;
			IsNotPublic: boolean;
			IsPublic: boolean;
			IsNestedPublic: boolean;
			IsNestedPrivate: boolean;
			IsNestedFamily: boolean;
			IsNestedAssembly: boolean;
			IsNestedFamilyAndAssembly: boolean;
			IsNestedFamilyOrAssembly: boolean;
			IsAutoLayout: boolean;
			IsSequentialLayout: boolean;
			IsExplicitLayout: boolean;
			IsClass: boolean;
			IsInterface: boolean;
			IsAbstract: boolean;
			IsSealed: boolean;
			IsSpecialName: boolean;
			IsImport: boolean;
			IsSerializable: boolean;
			IsAnsiClass: boolean;
			IsUnicodeClass: boolean;
			IsAutoClass: boolean;
			IsBeforeFieldInit: boolean;
			IsRuntimeSpecialName: boolean;
			HasSecurity: boolean;
			IsForwarder: boolean;
			FullName: string;
			 constructor(namespace: string, name: string, module: Mono.Cecil.ModuleDefinition, scope: Mono.Cecil.IMetadataScope) ;
			 ToString() : string;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum FieldAttributes {
			FieldAccessMask = 7,
			CompilerControlled = 0,
			Private = 1,
			FamANDAssem = 2,
			Assembly = 3,
			Family = 4,
			FamORAssem = 5,
			Public = 6,
			Static = 16,
			InitOnly = 32,
			Literal = 64,
			NotSerialized = 128,
			SpecialName = 512,
			PInvokeImpl = 8192,
			RTSpecialName = 1024,
			HasFieldMarshal = 4096,
			HasDefault = 32768,
			HasFieldRVA = 256,
		}
		class FieldDefinition extends Mono.Cecil.FieldReference {
			HasLayoutInfo: boolean;
			Offset: number;
			RVA: number;
			InitialValue: any;
			Attributes: Mono.Cecil.FieldAttributes;
			HasConstant: boolean;
			Constant: any;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			HasMarshalInfo: boolean;
			MarshalInfo: Mono.Cecil.MarshalInfo;
			IsCompilerControlled: boolean;
			IsPrivate: boolean;
			IsFamilyAndAssembly: boolean;
			IsAssembly: boolean;
			IsFamily: boolean;
			IsFamilyOrAssembly: boolean;
			IsPublic: boolean;
			IsStatic: boolean;
			IsInitOnly: boolean;
			IsLiteral: boolean;
			IsNotSerialized: boolean;
			IsSpecialName: boolean;
			IsPInvokeImpl: boolean;
			IsRuntimeSpecialName: boolean;
			HasDefault: boolean;
			IsDefinition: boolean;
			DeclaringType: Mono.Cecil.TypeDefinition;
			 constructor(name: string, attributes: Mono.Cecil.FieldAttributes, fieldType: Mono.Cecil.TypeReference) ;
			 Resolve() : Mono.Cecil.FieldDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class FieldReference extends Mono.Cecil.MemberReference {
			FieldType: Mono.Cecil.TypeReference;
			FullName: string;
			ContainsGenericParameter: boolean;
			 constructor(name: string, fieldType: Mono.Cecil.TypeReference) ;
			 constructor(name: string, fieldType: Mono.Cecil.TypeReference, declaringType: Mono.Cecil.TypeReference) ;
			 Resolve() : Mono.Cecil.FieldDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class FixedArrayMarshalInfo extends Mono.Cecil.MarshalInfo {
			ElementType: Mono.Cecil.NativeType;
			Size: number;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class FixedSysStringMarshalInfo extends Mono.Cecil.MarshalInfo {
			Size: number;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class FunctionPointerType extends Mono.Cecil.TypeSpecification {
			HasThis: boolean;
			ExplicitThis: boolean;
			CallingConvention: Mono.Cecil.MethodCallingConvention;
			HasParameters: boolean;
			Parameters: any;
			ReturnType: Mono.Cecil.TypeReference;
			MethodReturnType: Mono.Cecil.MethodReturnType;
			Name: string;
			Namespace: string;
			Module: Mono.Cecil.ModuleDefinition;
			Scope: Mono.Cecil.IMetadataScope;
			IsFunctionPointer: boolean;
			ContainsGenericParameter: boolean;
			FullName: string;
			 constructor() ;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class GenericInstanceMethod extends Mono.Cecil.MethodSpecification {
			HasGenericArguments: boolean;
			GenericArguments: any;
			IsGenericInstance: boolean;
			ContainsGenericParameter: boolean;
			FullName: string;
			 constructor(method: Mono.Cecil.MethodReference) ;
			 GetElementMethod() : Mono.Cecil.MethodReference;
			 Resolve() : Mono.Cecil.MethodDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class GenericInstanceType extends Mono.Cecil.TypeSpecification {
			HasGenericArguments: boolean;
			GenericArguments: any;
			DeclaringType: Mono.Cecil.TypeReference;
			FullName: string;
			IsGenericInstance: boolean;
			ContainsGenericParameter: boolean;
			 constructor(type: Mono.Cecil.TypeReference) ;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class GenericParameter extends Mono.Cecil.TypeReference {
			Attributes: Mono.Cecil.GenericParameterAttributes;
			Position: number;
			Type: Mono.Cecil.GenericParameterType;
			Owner: Mono.Cecil.IGenericParameterProvider;
			HasConstraints: boolean;
			Constraints: any;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			Scope: Mono.Cecil.IMetadataScope;
			DeclaringType: Mono.Cecil.TypeReference;
			DeclaringMethod: Mono.Cecil.MethodReference;
			Module: Mono.Cecil.ModuleDefinition;
			Name: string;
			Namespace: string;
			FullName: string;
			IsGenericParameter: boolean;
			ContainsGenericParameter: boolean;
			MetadataType: Mono.Cecil.MetadataType;
			IsNonVariant: boolean;
			IsCovariant: boolean;
			IsContravariant: boolean;
			HasReferenceTypeConstraint: boolean;
			HasNotNullableValueTypeConstraint: boolean;
			HasDefaultConstructorConstraint: boolean;
			 constructor(owner: Mono.Cecil.IGenericParameterProvider) ;
			 constructor(name: string, owner: Mono.Cecil.IGenericParameterProvider) ;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum GenericParameterAttributes {
			VarianceMask = 3,
			NonVariant = 0,
			Covariant = 1,
			Contravariant = 2,
			SpecialConstraintMask = 28,
			ReferenceTypeConstraint = 4,
			NotNullableValueTypeConstraint = 8,
			DefaultConstructorConstraint = 16,
		}
		class GenericParameterConstraint {
			ConstraintType: Mono.Cecil.TypeReference;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			MetadataToken: Mono.Cecil.MetadataToken;
			 constructor(constraintType: Mono.Cecil.TypeReference) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum GenericParameterType {
			Type = 0,
			Method = 1,
		}
		interface IAssemblyResolver {
			 Resolve(name: Mono.Cecil.AssemblyNameReference) : Mono.Cecil.AssemblyDefinition;
			 Resolve(name: Mono.Cecil.AssemblyNameReference, parameters: Mono.Cecil.ReaderParameters) : Mono.Cecil.AssemblyDefinition;
		}
		interface IConstantProvider {
			HasConstant: boolean;
			Constant: any;
		}
		interface ICustomAttribute {
			AttributeType: Mono.Cecil.TypeReference;
			HasFields: boolean;
			HasProperties: boolean;
			HasConstructorArguments: boolean;
			Fields: any;
			Properties: any;
			ConstructorArguments: any;
		}
		interface ICustomAttributeProvider {
			CustomAttributes: any;
			HasCustomAttributes: boolean;
		}
		interface IGenericInstance {
			HasGenericArguments: boolean;
			GenericArguments: any;
		}
		interface IGenericParameterProvider {
			HasGenericParameters: boolean;
			IsDefinition: boolean;
			Module: Mono.Cecil.ModuleDefinition;
			GenericParameters: any;
			GenericParameterType: Mono.Cecil.GenericParameterType;
		}
		interface IMarshalInfoProvider {
			HasMarshalInfo: boolean;
			MarshalInfo: Mono.Cecil.MarshalInfo;
		}
		interface IMemberDefinition {
			Name: string;
			FullName: string;
			IsSpecialName: boolean;
			IsRuntimeSpecialName: boolean;
			DeclaringType: Mono.Cecil.TypeDefinition;
		}
		interface IMetadataImporter {
			 ImportReference(reference: Mono.Cecil.AssemblyNameReference) : Mono.Cecil.AssemblyNameReference;
			 ImportReference(type: Mono.Cecil.TypeReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.TypeReference;
			 ImportReference(field: Mono.Cecil.FieldReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.FieldReference;
			 ImportReference(method: Mono.Cecil.MethodReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.MethodReference;
		}
		interface IMetadataImporterProvider {
			 GetMetadataImporter(module: Mono.Cecil.ModuleDefinition) : Mono.Cecil.IMetadataImporter;
		}
		interface IMetadataResolver {
			 Resolve(type: Mono.Cecil.TypeReference) : Mono.Cecil.TypeDefinition;
			 Resolve(field: Mono.Cecil.FieldReference) : Mono.Cecil.FieldDefinition;
			 Resolve(method: Mono.Cecil.MethodReference) : Mono.Cecil.MethodDefinition;
		}
		interface IMetadataScope {
			MetadataScopeType: Mono.Cecil.MetadataScopeType;
			Name: string;
		}
		interface IMetadataTokenProvider {
			MetadataToken: Mono.Cecil.MetadataToken;
		}
		interface IMethodSignature {
			HasThis: boolean;
			ExplicitThis: boolean;
			CallingConvention: Mono.Cecil.MethodCallingConvention;
			HasParameters: boolean;
			Parameters: any;
			ReturnType: Mono.Cecil.TypeReference;
			MethodReturnType: Mono.Cecil.MethodReturnType;
		}
		interface IModifierType {
			ModifierType: Mono.Cecil.TypeReference;
			ElementType: Mono.Cecil.TypeReference;
		}
		class InterfaceImplementation {
			InterfaceType: Mono.Cecil.TypeReference;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			MetadataToken: Mono.Cecil.MetadataToken;
			 constructor(interfaceType: Mono.Cecil.TypeReference) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		interface IReflectionImporter {
			 ImportReference(reference: System.Reflection.AssemblyName) : Mono.Cecil.AssemblyNameReference;
			 ImportReference(type: System.Type, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.TypeReference;
			 ImportReference(field: System.Reflection.FieldInfo, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.FieldReference;
			 ImportReference(method: System.Reflection.MethodBase, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.MethodReference;
		}
		interface IReflectionImporterProvider {
			 GetReflectionImporter(module: Mono.Cecil.ModuleDefinition) : Mono.Cecil.IReflectionImporter;
		}
		interface ISecurityDeclarationProvider {
			HasSecurityDeclarations: boolean;
			SecurityDeclarations: any;
		}
		class LinkedResource extends Mono.Cecil.Resource {
			Hash: any;
			File: string;
			ResourceType: Mono.Cecil.ResourceType;
			 constructor(name: string, flags: Mono.Cecil.ManifestResourceAttributes) ;
			 constructor(name: string, flags: Mono.Cecil.ManifestResourceAttributes, file: string) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum ManifestResourceAttributes {
			VisibilityMask = 7,
			Public = 1,
			Private = 2,
		}
		class MarshalInfo {
			NativeType: Mono.Cecil.NativeType;
			 constructor(native: Mono.Cecil.NativeType) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class MemberReference {
			Name: string;
			FullName: string;
			DeclaringType: Mono.Cecil.TypeReference;
			MetadataToken: Mono.Cecil.MetadataToken;
			IsWindowsRuntimeProjection: boolean;
			Module: Mono.Cecil.ModuleDefinition;
			IsDefinition: boolean;
			ContainsGenericParameter: boolean;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum MetadataKind {
			Ecma335 = 0,
			WindowsMetadata = 1,
			ManagedWindowsMetadata = 2,
		}
		class MetadataResolver {
			AssemblyResolver: Mono.Cecil.IAssemblyResolver;
			 constructor(assemblyResolver: Mono.Cecil.IAssemblyResolver) ;
			 Resolve(type: Mono.Cecil.TypeReference) : Mono.Cecil.TypeDefinition;
			 Resolve(field: Mono.Cecil.FieldReference) : Mono.Cecil.FieldDefinition;
			 Resolve(method: Mono.Cecil.MethodReference) : Mono.Cecil.MethodDefinition;
			 static GetMethod(methods: any, reference: Mono.Cecil.MethodReference) : Mono.Cecil.MethodDefinition;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum MetadataScopeType {
			AssemblyNameReference = 0,
			ModuleReference = 1,
			ModuleDefinition = 2,
		}
		class MetadataToken extends System.ValueType {
			RID: System.UInt32;
			TokenType: Mono.Cecil.TokenType;
			 constructor(token: System.UInt32) ;
			 constructor(type: Mono.Cecil.TokenType) ;
			 constructor(type: Mono.Cecil.TokenType, rid: System.UInt32) ;
			 constructor(type: Mono.Cecil.TokenType, rid: number) ;
			 ToInt32() : number;
			 ToUInt32() : System.UInt32;
			 GetHashCode() : number;
			 Equals(other: Mono.Cecil.MetadataToken) : boolean;
			 Equals(obj: any) : boolean;
			 static op_Equality(one: Mono.Cecil.MetadataToken, other: Mono.Cecil.MetadataToken) : boolean;
			 static op_Inequality(one: Mono.Cecil.MetadataToken, other: Mono.Cecil.MetadataToken) : boolean;
			 ToString() : string;
			 GetType() : System.Type;
		}
		enum MetadataType {
			Void = 1,
			Boolean = 2,
			Char = 3,
			SByte = 4,
			Byte = 5,
			Int16 = 6,
			UInt16 = 7,
			Int32 = 8,
			UInt32 = 9,
			Int64 = 10,
			UInt64 = 11,
			Single = 12,
			Double = 13,
			String = 14,
			Pointer = 15,
			ByReference = 16,
			ValueType = 17,
			Class = 18,
			Var = 19,
			Array = 20,
			GenericInstance = 21,
			TypedByReference = 22,
			IntPtr = 24,
			UIntPtr = 25,
			FunctionPointer = 27,
			Object = 28,
			MVar = 30,
			RequiredModifier = 31,
			OptionalModifier = 32,
			Sentinel = 65,
			Pinned = 69,
		}
		/** Flags */
		enum MethodAttributes {
			MemberAccessMask = 7,
			CompilerControlled = 0,
			Private = 1,
			FamANDAssem = 2,
			Assembly = 3,
			Family = 4,
			FamORAssem = 5,
			Public = 6,
			Static = 16,
			Final = 32,
			Virtual = 64,
			HideBySig = 128,
			VtableLayoutMask = 256,
			ReuseSlot = 0,
			NewSlot = 256,
			CheckAccessOnOverride = 512,
			Abstract = 1024,
			SpecialName = 2048,
			PInvokeImpl = 8192,
			UnmanagedExport = 8,
			RTSpecialName = 4096,
			HasSecurity = 16384,
			RequireSecObject = 32768,
		}
		enum MethodCallingConvention {
			Default = 0,
			C = 1,
			StdCall = 2,
			ThisCall = 3,
			FastCall = 4,
			VarArg = 5,
			Generic = 16,
		}
		class MethodDefinition extends Mono.Cecil.MethodReference {
			Name: string;
			Attributes: Mono.Cecil.MethodAttributes;
			ImplAttributes: Mono.Cecil.MethodImplAttributes;
			SemanticsAttributes: Mono.Cecil.MethodSemanticsAttributes;
			HasSecurityDeclarations: boolean;
			SecurityDeclarations: any;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			RVA: number;
			HasBody: boolean;
			Body: Mono.Cecil.Cil.MethodBody;
			DebugInformation: Mono.Cecil.Cil.MethodDebugInformation;
			HasPInvokeInfo: boolean;
			PInvokeInfo: Mono.Cecil.PInvokeInfo;
			HasOverrides: boolean;
			Overrides: any;
			HasGenericParameters: boolean;
			GenericParameters: any;
			HasCustomDebugInformations: boolean;
			CustomDebugInformations: any;
			IsCompilerControlled: boolean;
			IsPrivate: boolean;
			IsFamilyAndAssembly: boolean;
			IsAssembly: boolean;
			IsFamily: boolean;
			IsFamilyOrAssembly: boolean;
			IsPublic: boolean;
			IsStatic: boolean;
			IsFinal: boolean;
			IsVirtual: boolean;
			IsHideBySig: boolean;
			IsReuseSlot: boolean;
			IsNewSlot: boolean;
			IsCheckAccessOnOverride: boolean;
			IsAbstract: boolean;
			IsSpecialName: boolean;
			IsPInvokeImpl: boolean;
			IsUnmanagedExport: boolean;
			IsRuntimeSpecialName: boolean;
			HasSecurity: boolean;
			IsIL: boolean;
			IsNative: boolean;
			IsRuntime: boolean;
			IsUnmanaged: boolean;
			IsManaged: boolean;
			IsForwardRef: boolean;
			IsPreserveSig: boolean;
			IsInternalCall: boolean;
			IsSynchronized: boolean;
			NoInlining: boolean;
			NoOptimization: boolean;
			AggressiveInlining: boolean;
			IsSetter: boolean;
			IsGetter: boolean;
			IsOther: boolean;
			IsAddOn: boolean;
			IsRemoveOn: boolean;
			IsFire: boolean;
			DeclaringType: Mono.Cecil.TypeDefinition;
			IsConstructor: boolean;
			IsDefinition: boolean;
			 constructor(name: string, attributes: Mono.Cecil.MethodAttributes, returnType: Mono.Cecil.TypeReference) ;
			 Resolve() : Mono.Cecil.MethodDefinition;
			 GetElementMethod() : Mono.Cecil.MethodReference;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum MethodImplAttributes {
			CodeTypeMask = 3,
			IL = 0,
			Native = 1,
			OPTIL = 2,
			Runtime = 3,
			ManagedMask = 4,
			Unmanaged = 4,
			Managed = 0,
			ForwardRef = 16,
			PreserveSig = 128,
			InternalCall = 4096,
			Synchronized = 32,
			NoOptimization = 64,
			NoInlining = 8,
			AggressiveInlining = 256,
		}
		class MethodReference extends Mono.Cecil.MemberReference {
			HasThis: boolean;
			ExplicitThis: boolean;
			CallingConvention: Mono.Cecil.MethodCallingConvention;
			HasParameters: boolean;
			Parameters: any;
			HasGenericParameters: boolean;
			GenericParameters: any;
			ReturnType: Mono.Cecil.TypeReference;
			MethodReturnType: Mono.Cecil.MethodReturnType;
			FullName: string;
			IsGenericInstance: boolean;
			ContainsGenericParameter: boolean;
			 constructor(name: string, returnType: Mono.Cecil.TypeReference) ;
			 constructor(name: string, returnType: Mono.Cecil.TypeReference, declaringType: Mono.Cecil.TypeReference) ;
			 GetElementMethod() : Mono.Cecil.MethodReference;
			 Resolve() : Mono.Cecil.MethodDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class MethodReturnType {
			Method: Mono.Cecil.IMethodSignature;
			ReturnType: Mono.Cecil.TypeReference;
			MetadataToken: Mono.Cecil.MetadataToken;
			Attributes: Mono.Cecil.ParameterAttributes;
			Name: string;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			HasDefault: boolean;
			HasConstant: boolean;
			Constant: any;
			HasFieldMarshal: boolean;
			HasMarshalInfo: boolean;
			MarshalInfo: Mono.Cecil.MarshalInfo;
			 constructor(method: Mono.Cecil.IMethodSignature) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum MethodSemanticsAttributes {
			None = 0,
			Setter = 1,
			Getter = 2,
			Other = 4,
			AddOn = 8,
			RemoveOn = 16,
			Fire = 32,
		}
		abstract class MethodSpecification extends Mono.Cecil.MethodReference {
			ElementMethod: Mono.Cecil.MethodReference;
			Name: string;
			CallingConvention: Mono.Cecil.MethodCallingConvention;
			HasThis: boolean;
			ExplicitThis: boolean;
			MethodReturnType: Mono.Cecil.MethodReturnType;
			DeclaringType: Mono.Cecil.TypeReference;
			Module: Mono.Cecil.ModuleDefinition;
			HasParameters: boolean;
			Parameters: any;
			ContainsGenericParameter: boolean;
			 GetElementMethod() : Mono.Cecil.MethodReference;
			 Resolve() : Mono.Cecil.MethodDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum ModuleAttributes {
			ILOnly = 1,
			Required32Bit = 2,
			ILLibrary = 4,
			StrongNameSigned = 8,
			Preferred32Bit = 131072,
		}
		/** Flags */
		enum ModuleCharacteristics {
			HighEntropyVA = 32,
			DynamicBase = 64,
			NoSEH = 1024,
			NXCompat = 256,
			AppContainer = 4096,
			TerminalServerAware = 32768,
		}
		class ModuleDefinition extends Mono.Cecil.ModuleReference {
			IsMain: boolean;
			Kind: Mono.Cecil.ModuleKind;
			MetadataKind: Mono.Cecil.MetadataKind;
			Runtime: Mono.Cecil.TargetRuntime;
			RuntimeVersion: string;
			Architecture: Mono.Cecil.TargetArchitecture;
			Attributes: Mono.Cecil.ModuleAttributes;
			Characteristics: Mono.Cecil.ModuleCharacteristics;
			FullyQualifiedName: string;
			FileName: string;
			Mvid: System.Guid;
			HasSymbols: boolean;
			SymbolReader: Mono.Cecil.Cil.ISymbolReader;
			MetadataScopeType: Mono.Cecil.MetadataScopeType;
			Assembly: Mono.Cecil.AssemblyDefinition;
			AssemblyResolver: Mono.Cecil.IAssemblyResolver;
			MetadataResolver: Mono.Cecil.IMetadataResolver;
			TypeSystem: Mono.Cecil.TypeSystem;
			HasAssemblyReferences: boolean;
			AssemblyReferences: any;
			HasModuleReferences: boolean;
			ModuleReferences: any;
			HasResources: boolean;
			Resources: any;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			HasTypes: boolean;
			Types: any;
			HasExportedTypes: boolean;
			ExportedTypes: any;
			EntryPoint: Mono.Cecil.MethodDefinition;
			HasCustomDebugInformations: boolean;
			CustomDebugInformations: any;
			HasDebugHeader: boolean;
			 Import(method: Mono.Cecil.MethodReference) : Mono.Cecil.MethodReference;
			 Import(method: Mono.Cecil.MethodReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.MethodReference;
			 ImportReference(method: Mono.Cecil.MethodReference) : Mono.Cecil.MethodReference;
			 ImportReference(method: Mono.Cecil.MethodReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.MethodReference;
			 LookupToken(token: number) : Mono.Cecil.IMetadataTokenProvider;
			 LookupToken(token: Mono.Cecil.MetadataToken) : Mono.Cecil.IMetadataTokenProvider;
			 GetDebugHeader() : Mono.Cecil.Cil.ImageDebugHeader;
			 static CreateModule(name: string, kind: Mono.Cecil.ModuleKind) : Mono.Cecil.ModuleDefinition;
			 static CreateModule(name: string, parameters: Mono.Cecil.ModuleParameters) : Mono.Cecil.ModuleDefinition;
			 ReadSymbols() : void;
			 ReadSymbols(reader: Mono.Cecil.Cil.ISymbolReader) : void;
			 ReadSymbols(reader: Mono.Cecil.Cil.ISymbolReader, throwIfSymbolsAreNotMaching: boolean) : void;
			 static ReadModule(fileName: string) : Mono.Cecil.ModuleDefinition;
			 static ReadModule(fileName: string, parameters: Mono.Cecil.ReaderParameters) : Mono.Cecil.ModuleDefinition;
			 static ReadModule(stream: System.IO.Stream) : Mono.Cecil.ModuleDefinition;
			 static ReadModule(stream: System.IO.Stream, parameters: Mono.Cecil.ReaderParameters) : Mono.Cecil.ModuleDefinition;
			 Write(fileName: string) : void;
			 Write(fileName: string, parameters: Mono.Cecil.WriterParameters) : void;
			 Write() : void;
			 Write(parameters: Mono.Cecil.WriterParameters) : void;
			 Write(stream: System.IO.Stream) : void;
			 Write(stream: System.IO.Stream, parameters: Mono.Cecil.WriterParameters) : void;
			 Dispose() : void;
			 HasTypeReference(fullName: string) : boolean;
			 HasTypeReference(scope: string, fullName: string) : boolean;
			 TryGetTypeReference(fullName: string, type: any) : boolean;
			 TryGetTypeReference(scope: string, fullName: string, type: any) : boolean;
			 GetTypeReferences() : any;
			 GetMemberReferences() : any;
			 GetCustomAttributes() : any;
			 GetType(fullName: string, runtimeName: boolean) : Mono.Cecil.TypeReference;
			 GetType(fullName: string) : Mono.Cecil.TypeDefinition;
			 GetType(namespace: string, name: string) : Mono.Cecil.TypeDefinition;
			 GetTypes() : any;
			 Import(type: System.Type) : Mono.Cecil.TypeReference;
			 ImportReference(type: System.Type) : Mono.Cecil.TypeReference;
			 Import(type: System.Type, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.TypeReference;
			 ImportReference(type: System.Type, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.TypeReference;
			 Import(field: System.Reflection.FieldInfo) : Mono.Cecil.FieldReference;
			 Import(field: System.Reflection.FieldInfo, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.FieldReference;
			 ImportReference(field: System.Reflection.FieldInfo) : Mono.Cecil.FieldReference;
			 ImportReference(field: System.Reflection.FieldInfo, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.FieldReference;
			 Import(method: System.Reflection.MethodBase) : Mono.Cecil.MethodReference;
			 Import(method: System.Reflection.MethodBase, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.MethodReference;
			 ImportReference(method: System.Reflection.MethodBase) : Mono.Cecil.MethodReference;
			 ImportReference(method: System.Reflection.MethodBase, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.MethodReference;
			 Import(type: Mono.Cecil.TypeReference) : Mono.Cecil.TypeReference;
			 Import(type: Mono.Cecil.TypeReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.TypeReference;
			 ImportReference(type: Mono.Cecil.TypeReference) : Mono.Cecil.TypeReference;
			 ImportReference(type: Mono.Cecil.TypeReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.TypeReference;
			 Import(field: Mono.Cecil.FieldReference) : Mono.Cecil.FieldReference;
			 Import(field: Mono.Cecil.FieldReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.FieldReference;
			 ImportReference(field: Mono.Cecil.FieldReference) : Mono.Cecil.FieldReference;
			 ImportReference(field: Mono.Cecil.FieldReference, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.FieldReference;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum ModuleKind {
			Dll = 0,
			Console = 1,
			Windows = 2,
			NetModule = 3,
		}
		class ModuleParameters {
			Kind: Mono.Cecil.ModuleKind;
			Runtime: Mono.Cecil.TargetRuntime;
			Timestamp: any;
			Architecture: Mono.Cecil.TargetArchitecture;
			AssemblyResolver: Mono.Cecil.IAssemblyResolver;
			MetadataResolver: Mono.Cecil.IMetadataResolver;
			MetadataImporterProvider: Mono.Cecil.IMetadataImporterProvider;
			ReflectionImporterProvider: Mono.Cecil.IReflectionImporterProvider;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ModuleReference {
			Name: string;
			MetadataScopeType: Mono.Cecil.MetadataScopeType;
			MetadataToken: Mono.Cecil.MetadataToken;
			 constructor(name: string) ;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum NativeType {
			None = 102,
			Boolean = 2,
			I1 = 3,
			U1 = 4,
			I2 = 5,
			U2 = 6,
			I4 = 7,
			U4 = 8,
			I8 = 9,
			U8 = 10,
			R4 = 11,
			R8 = 12,
			LPStr = 20,
			Int = 31,
			UInt = 32,
			Func = 38,
			Array = 42,
			Currency = 15,
			BStr = 19,
			LPWStr = 21,
			LPTStr = 22,
			FixedSysString = 23,
			IUnknown = 25,
			IDispatch = 26,
			Struct = 27,
			IntF = 28,
			SafeArray = 29,
			FixedArray = 30,
			ByValStr = 34,
			ANSIBStr = 35,
			TBStr = 36,
			VariantBool = 37,
			ASAny = 40,
			LPStruct = 43,
			CustomMarshaler = 44,
			Error = 45,
			Max = 80,
		}
		class OptionalModifierType extends Mono.Cecil.TypeSpecification {
			ModifierType: Mono.Cecil.TypeReference;
			Name: string;
			FullName: string;
			IsValueType: boolean;
			IsOptionalModifier: boolean;
			ContainsGenericParameter: boolean;
			 constructor(modifierType: Mono.Cecil.TypeReference, type: Mono.Cecil.TypeReference) ;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum ParameterAttributes {
			None = 0,
			In = 1,
			Out = 2,
			Lcid = 4,
			Retval = 8,
			Optional = 16,
			HasDefault = 4096,
			HasFieldMarshal = 8192,
			Unused = 53216,
		}
		class ParameterDefinition extends Mono.Cecil.ParameterReference {
			Attributes: Mono.Cecil.ParameterAttributes;
			Method: Mono.Cecil.IMethodSignature;
			Sequence: number;
			HasConstant: boolean;
			Constant: any;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			HasMarshalInfo: boolean;
			MarshalInfo: Mono.Cecil.MarshalInfo;
			IsIn: boolean;
			IsOut: boolean;
			IsLcid: boolean;
			IsReturnValue: boolean;
			IsOptional: boolean;
			HasDefault: boolean;
			HasFieldMarshal: boolean;
			 constructor(parameterType: Mono.Cecil.TypeReference) ;
			 constructor(name: string, attributes: Mono.Cecil.ParameterAttributes, parameterType: Mono.Cecil.TypeReference) ;
			 Resolve() : Mono.Cecil.ParameterDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class ParameterReference {
			Name: string;
			Index: number;
			ParameterType: Mono.Cecil.TypeReference;
			MetadataToken: Mono.Cecil.MetadataToken;
			 ToString() : string;
			 Resolve() : Mono.Cecil.ParameterDefinition;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class PinnedType extends Mono.Cecil.TypeSpecification {
			IsValueType: boolean;
			IsPinned: boolean;
			 constructor(type: Mono.Cecil.TypeReference) ;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum PInvokeAttributes {
			NoMangle = 1,
			CharSetMask = 6,
			CharSetNotSpec = 0,
			CharSetAnsi = 2,
			CharSetUnicode = 4,
			CharSetAuto = 6,
			SupportsLastError = 64,
			CallConvMask = 1792,
			CallConvWinapi = 256,
			CallConvCdecl = 512,
			CallConvStdCall = 768,
			CallConvThiscall = 1024,
			CallConvFastcall = 1280,
			BestFitMask = 48,
			BestFitEnabled = 16,
			BestFitDisabled = 32,
			ThrowOnUnmappableCharMask = 12288,
			ThrowOnUnmappableCharEnabled = 4096,
			ThrowOnUnmappableCharDisabled = 8192,
		}
		class PInvokeInfo {
			Attributes: Mono.Cecil.PInvokeAttributes;
			EntryPoint: string;
			Module: Mono.Cecil.ModuleReference;
			IsNoMangle: boolean;
			IsCharSetNotSpec: boolean;
			IsCharSetAnsi: boolean;
			IsCharSetUnicode: boolean;
			IsCharSetAuto: boolean;
			SupportsLastError: boolean;
			IsCallConvWinapi: boolean;
			IsCallConvCdecl: boolean;
			IsCallConvStdCall: boolean;
			IsCallConvThiscall: boolean;
			IsCallConvFastcall: boolean;
			IsBestFitEnabled: boolean;
			IsBestFitDisabled: boolean;
			IsThrowOnUnmappableCharEnabled: boolean;
			IsThrowOnUnmappableCharDisabled: boolean;
			 constructor(attributes: Mono.Cecil.PInvokeAttributes, entryPoint: string, module: Mono.Cecil.ModuleReference) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class PointerType extends Mono.Cecil.TypeSpecification {
			Name: string;
			FullName: string;
			IsValueType: boolean;
			IsPointer: boolean;
			 constructor(type: Mono.Cecil.TypeReference) ;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum PropertyAttributes {
			None = 0,
			SpecialName = 512,
			RTSpecialName = 1024,
			HasDefault = 4096,
			Unused = 59903,
		}
		class PropertyDefinition extends Mono.Cecil.PropertyReference {
			Attributes: Mono.Cecil.PropertyAttributes;
			HasThis: boolean;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			GetMethod: Mono.Cecil.MethodDefinition;
			SetMethod: Mono.Cecil.MethodDefinition;
			HasOtherMethods: boolean;
			OtherMethods: any;
			HasParameters: boolean;
			Parameters: any;
			HasConstant: boolean;
			Constant: any;
			IsSpecialName: boolean;
			IsRuntimeSpecialName: boolean;
			HasDefault: boolean;
			DeclaringType: Mono.Cecil.TypeDefinition;
			IsDefinition: boolean;
			FullName: string;
			 constructor(name: string, attributes: Mono.Cecil.PropertyAttributes, propertyType: Mono.Cecil.TypeReference) ;
			 Resolve() : Mono.Cecil.PropertyDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class PropertyReference extends Mono.Cecil.MemberReference {
			PropertyType: Mono.Cecil.TypeReference;
			Parameters: any;
			 Resolve() : Mono.Cecil.PropertyDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ReaderParameters {
			ReadingMode: Mono.Cecil.ReadingMode;
			InMemory: boolean;
			AssemblyResolver: Mono.Cecil.IAssemblyResolver;
			MetadataResolver: Mono.Cecil.IMetadataResolver;
			MetadataImporterProvider: Mono.Cecil.IMetadataImporterProvider;
			ReflectionImporterProvider: Mono.Cecil.IReflectionImporterProvider;
			SymbolStream: System.IO.Stream;
			SymbolReaderProvider: Mono.Cecil.Cil.ISymbolReaderProvider;
			ReadSymbols: boolean;
			ThrowIfSymbolsAreNotMatching: boolean;
			ReadWrite: boolean;
			ApplyWindowsRuntimeProjections: boolean;
			 constructor() ;
			 constructor(readingMode: Mono.Cecil.ReadingMode) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum ReadingMode {
			Immediate = 1,
			Deferred = 2,
		}
		class RequiredModifierType extends Mono.Cecil.TypeSpecification {
			ModifierType: Mono.Cecil.TypeReference;
			Name: string;
			FullName: string;
			IsValueType: boolean;
			IsRequiredModifier: boolean;
			ContainsGenericParameter: boolean;
			 constructor(modifierType: Mono.Cecil.TypeReference, type: Mono.Cecil.TypeReference) ;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ResolutionException extends System.Exception {
			Member: Mono.Cecil.MemberReference;
			Scope: Mono.Cecil.IMetadataScope;
			 constructor(member: Mono.Cecil.MemberReference) ;
			 constructor(member: Mono.Cecil.MemberReference, innerException: System.Exception) ;
			 GetBaseException() : System.Exception;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 ToString() : string;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class Resource {
			Name: string;
			Attributes: Mono.Cecil.ManifestResourceAttributes;
			ResourceType: Mono.Cecil.ResourceType;
			IsPublic: boolean;
			IsPrivate: boolean;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum ResourceType {
			Linked = 0,
			Embedded = 1,
			AssemblyLinked = 2,
		}
		class SafeArrayMarshalInfo extends Mono.Cecil.MarshalInfo {
			ElementType: Mono.Cecil.VariantType;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum SecurityAction {
			Request = 1,
			Demand = 2,
			Assert = 3,
			Deny = 4,
			PermitOnly = 5,
			LinkDemand = 6,
			InheritDemand = 7,
			RequestMinimum = 8,
			RequestOptional = 9,
			RequestRefuse = 10,
			PreJitGrant = 11,
			PreJitDeny = 12,
			NonCasDemand = 13,
			NonCasLinkDemand = 14,
			NonCasInheritance = 15,
		}
		class SecurityAttribute {
			AttributeType: Mono.Cecil.TypeReference;
			HasFields: boolean;
			Fields: any;
			HasProperties: boolean;
			Properties: any;
			 constructor(attributeType: Mono.Cecil.TypeReference) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class SecurityDeclaration {
			Action: Mono.Cecil.SecurityAction;
			HasSecurityAttributes: boolean;
			SecurityAttributes: any;
			 constructor(action: Mono.Cecil.SecurityAction) ;
			 constructor(action: Mono.Cecil.SecurityAction, blob: any) ;
			 GetBlob() : any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class SentinelType extends Mono.Cecil.TypeSpecification {
			IsValueType: boolean;
			IsSentinel: boolean;
			 constructor(type: Mono.Cecil.TypeReference) ;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum TargetArchitecture {
			I386 = 332,
			AMD64 = 34404,
			IA64 = 512,
			ARM = 448,
			ARMv7 = 452,
			ARM64 = 43620,
		}
		enum TargetRuntime {
			Net_1_0 = 0,
			Net_1_1 = 1,
			Net_2_0 = 2,
			Net_4_0 = 3,
		}
		enum TokenType {
			Module = 0,
			TypeRef = 16777216,
			TypeDef = 33554432,
			Field = 67108864,
			Method = 100663296,
			Param = 134217728,
			InterfaceImpl = 150994944,
			MemberRef = 167772160,
			CustomAttribute = 201326592,
			Permission = 234881024,
			Signature = 285212672,
			Event = 335544320,
			Property = 385875968,
			ModuleRef = 436207616,
			TypeSpec = 452984832,
			Assembly = 536870912,
			AssemblyRef = 587202560,
			File = 637534208,
			ExportedType = 654311424,
			ManifestResource = 671088640,
			GenericParam = 704643072,
			MethodSpec = 721420288,
			GenericParamConstraint = 738197504,
			Document = 805306368,
			MethodDebugInformation = 822083584,
			LocalScope = 838860800,
			LocalVariable = 855638016,
			LocalConstant = 872415232,
			ImportScope = 889192448,
			StateMachineMethod = 905969664,
			CustomDebugInformation = 922746880,
			String = 1879048192,
		}
		/** Flags */
		enum TypeAttributes {
			VisibilityMask = 7,
			NotPublic = 0,
			Public = 1,
			NestedPublic = 2,
			NestedPrivate = 3,
			NestedFamily = 4,
			NestedAssembly = 5,
			NestedFamANDAssem = 6,
			NestedFamORAssem = 7,
			LayoutMask = 24,
			AutoLayout = 0,
			SequentialLayout = 8,
			ExplicitLayout = 16,
			ClassSemanticMask = 32,
			Class = 0,
			Interface = 32,
			Abstract = 128,
			Sealed = 256,
			SpecialName = 1024,
			Import = 4096,
			Serializable = 8192,
			WindowsRuntime = 16384,
			StringFormatMask = 196608,
			AnsiClass = 0,
			UnicodeClass = 65536,
			AutoClass = 131072,
			BeforeFieldInit = 1048576,
			RTSpecialName = 2048,
			HasSecurity = 262144,
			Forwarder = 2097152,
		}
		class TypeDefinition extends Mono.Cecil.TypeReference {
			Attributes: Mono.Cecil.TypeAttributes;
			BaseType: Mono.Cecil.TypeReference;
			Name: string;
			HasLayoutInfo: boolean;
			PackingSize: number;
			ClassSize: number;
			HasInterfaces: boolean;
			Interfaces: any;
			HasNestedTypes: boolean;
			NestedTypes: any;
			HasMethods: boolean;
			Methods: any;
			HasFields: boolean;
			Fields: any;
			HasEvents: boolean;
			Events: any;
			HasProperties: boolean;
			Properties: any;
			HasSecurityDeclarations: boolean;
			SecurityDeclarations: any;
			HasCustomAttributes: boolean;
			CustomAttributes: any;
			HasGenericParameters: boolean;
			GenericParameters: any;
			IsNotPublic: boolean;
			IsPublic: boolean;
			IsNestedPublic: boolean;
			IsNestedPrivate: boolean;
			IsNestedFamily: boolean;
			IsNestedAssembly: boolean;
			IsNestedFamilyAndAssembly: boolean;
			IsNestedFamilyOrAssembly: boolean;
			IsAutoLayout: boolean;
			IsSequentialLayout: boolean;
			IsExplicitLayout: boolean;
			IsClass: boolean;
			IsInterface: boolean;
			IsAbstract: boolean;
			IsSealed: boolean;
			IsSpecialName: boolean;
			IsImport: boolean;
			IsSerializable: boolean;
			IsWindowsRuntime: boolean;
			IsAnsiClass: boolean;
			IsUnicodeClass: boolean;
			IsAutoClass: boolean;
			IsBeforeFieldInit: boolean;
			IsRuntimeSpecialName: boolean;
			HasSecurity: boolean;
			IsEnum: boolean;
			IsValueType: boolean;
			IsPrimitive: boolean;
			MetadataType: Mono.Cecil.MetadataType;
			IsDefinition: boolean;
			DeclaringType: Mono.Cecil.TypeDefinition;
			 constructor(namespace: string, name: string, attributes: Mono.Cecil.TypeAttributes, baseType: Mono.Cecil.TypeReference) ;
			 constructor(namespace: string, name: string, attributes: Mono.Cecil.TypeAttributes) ;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class TypeReference extends Mono.Cecil.MemberReference {
			Name: string;
			Namespace: string;
			IsValueType: boolean;
			Module: Mono.Cecil.ModuleDefinition;
			HasGenericParameters: boolean;
			GenericParameters: any;
			Scope: Mono.Cecil.IMetadataScope;
			IsNested: boolean;
			DeclaringType: Mono.Cecil.TypeReference;
			FullName: string;
			IsByReference: boolean;
			IsPointer: boolean;
			IsSentinel: boolean;
			IsArray: boolean;
			IsGenericParameter: boolean;
			IsGenericInstance: boolean;
			IsRequiredModifier: boolean;
			IsOptionalModifier: boolean;
			IsPinned: boolean;
			IsFunctionPointer: boolean;
			IsPrimitive: boolean;
			MetadataType: Mono.Cecil.MetadataType;
			 constructor(namespace: string, name: string, module: Mono.Cecil.ModuleDefinition, scope: Mono.Cecil.IMetadataScope) ;
			 constructor(namespace: string, name: string, module: Mono.Cecil.ModuleDefinition, scope: Mono.Cecil.IMetadataScope, valueType: boolean) ;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class TypeSpecification extends Mono.Cecil.TypeReference {
			ElementType: Mono.Cecil.TypeReference;
			Name: string;
			Namespace: string;
			Scope: Mono.Cecil.IMetadataScope;
			Module: Mono.Cecil.ModuleDefinition;
			FullName: string;
			ContainsGenericParameter: boolean;
			MetadataType: Mono.Cecil.MetadataType;
			 GetElementType() : Mono.Cecil.TypeReference;
			 Resolve() : Mono.Cecil.TypeDefinition;
			 Resolve() : Mono.Cecil.IMemberDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class TypeSystem {
			Corlib: Mono.Cecil.IMetadataScope;
			CoreLibrary: Mono.Cecil.IMetadataScope;
			Object: Mono.Cecil.TypeReference;
			Void: Mono.Cecil.TypeReference;
			Boolean: Mono.Cecil.TypeReference;
			Char: Mono.Cecil.TypeReference;
			SByte: Mono.Cecil.TypeReference;
			Byte: Mono.Cecil.TypeReference;
			Int16: Mono.Cecil.TypeReference;
			UInt16: Mono.Cecil.TypeReference;
			Int32: Mono.Cecil.TypeReference;
			UInt32: Mono.Cecil.TypeReference;
			Int64: Mono.Cecil.TypeReference;
			UInt64: Mono.Cecil.TypeReference;
			Single: Mono.Cecil.TypeReference;
			Double: Mono.Cecil.TypeReference;
			IntPtr: Mono.Cecil.TypeReference;
			UIntPtr: Mono.Cecil.TypeReference;
			String: Mono.Cecil.TypeReference;
			TypedReference: Mono.Cecil.TypeReference;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum VariantType {
			None = 0,
			I2 = 2,
			I4 = 3,
			R4 = 4,
			R8 = 5,
			CY = 6,
			Date = 7,
			BStr = 8,
			Dispatch = 9,
			Error = 10,
			Bool = 11,
			Variant = 12,
			Unknown = 13,
			Decimal = 14,
			I1 = 16,
			UI1 = 17,
			UI2 = 18,
			UI4 = 19,
			I8 = 20,
			UI8 = 21,
			Int = 22,
			UInt = 23,
		}
		class WriterParameters {
			Timestamp: any;
			SymbolStream: System.IO.Stream;
			SymbolWriterProvider: Mono.Cecil.Cil.ISymbolWriterProvider;
			WriteSymbols: boolean;
			HasStrongNameKey: boolean;
			StrongNameKeyBlob: any;
			StrongNameKeyContainer: string;
			StrongNameKeyPair: System.Reflection.StrongNameKeyPair;
			DeterministicMvid: boolean;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module Mono.Cecil.Cil {
		class AsyncMethodBodyDebugInformation extends Mono.Cecil.Cil.CustomDebugInformation {
			CatchHandler: Mono.Cecil.Cil.InstructionOffset;
			Yields: any;
			Resumes: any;
			ResumeMethods: any;
			Kind: Mono.Cecil.Cil.CustomDebugInformationKind;
			 constructor(catchHandler: Mono.Cecil.Cil.Instruction) ;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class BinaryCustomDebugInformation extends Mono.Cecil.Cil.CustomDebugInformation {
			Data: any;
			Kind: Mono.Cecil.Cil.CustomDebugInformationKind;
			 constructor(identifier: System.Guid, data: any) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum Code {
			Nop = 0,
			Break = 1,
			Ldarg_0 = 2,
			Ldarg_1 = 3,
			Ldarg_2 = 4,
			Ldarg_3 = 5,
			Ldloc_0 = 6,
			Ldloc_1 = 7,
			Ldloc_2 = 8,
			Ldloc_3 = 9,
			Stloc_0 = 10,
			Stloc_1 = 11,
			Stloc_2 = 12,
			Stloc_3 = 13,
			Ldarg_S = 14,
			Ldarga_S = 15,
			Starg_S = 16,
			Ldloc_S = 17,
			Ldloca_S = 18,
			Stloc_S = 19,
			Ldnull = 20,
			Ldc_I4_M1 = 21,
			Ldc_I4_0 = 22,
			Ldc_I4_1 = 23,
			Ldc_I4_2 = 24,
			Ldc_I4_3 = 25,
			Ldc_I4_4 = 26,
			Ldc_I4_5 = 27,
			Ldc_I4_6 = 28,
			Ldc_I4_7 = 29,
			Ldc_I4_8 = 30,
			Ldc_I4_S = 31,
			Ldc_I4 = 32,
			Ldc_I8 = 33,
			Ldc_R4 = 34,
			Ldc_R8 = 35,
			Dup = 36,
			Pop = 37,
			Jmp = 38,
			Call = 39,
			Calli = 40,
			Ret = 41,
			Br_S = 42,
			Brfalse_S = 43,
			Brtrue_S = 44,
			Beq_S = 45,
			Bge_S = 46,
			Bgt_S = 47,
			Ble_S = 48,
			Blt_S = 49,
			Bne_Un_S = 50,
			Bge_Un_S = 51,
			Bgt_Un_S = 52,
			Ble_Un_S = 53,
			Blt_Un_S = 54,
			Br = 55,
			Brfalse = 56,
			Brtrue = 57,
			Beq = 58,
			Bge = 59,
			Bgt = 60,
			Ble = 61,
			Blt = 62,
			Bne_Un = 63,
			Bge_Un = 64,
			Bgt_Un = 65,
			Ble_Un = 66,
			Blt_Un = 67,
			Switch = 68,
			Ldind_I1 = 69,
			Ldind_U1 = 70,
			Ldind_I2 = 71,
			Ldind_U2 = 72,
			Ldind_I4 = 73,
			Ldind_U4 = 74,
			Ldind_I8 = 75,
			Ldind_I = 76,
			Ldind_R4 = 77,
			Ldind_R8 = 78,
			Ldind_Ref = 79,
			Stind_Ref = 80,
			Stind_I1 = 81,
			Stind_I2 = 82,
			Stind_I4 = 83,
			Stind_I8 = 84,
			Stind_R4 = 85,
			Stind_R8 = 86,
			Add = 87,
			Sub = 88,
			Mul = 89,
			Div = 90,
			Div_Un = 91,
			Rem = 92,
			Rem_Un = 93,
			And = 94,
			Or = 95,
			Xor = 96,
			Shl = 97,
			Shr = 98,
			Shr_Un = 99,
			Neg = 100,
			Not = 101,
			Conv_I1 = 102,
			Conv_I2 = 103,
			Conv_I4 = 104,
			Conv_I8 = 105,
			Conv_R4 = 106,
			Conv_R8 = 107,
			Conv_U4 = 108,
			Conv_U8 = 109,
			Callvirt = 110,
			Cpobj = 111,
			Ldobj = 112,
			Ldstr = 113,
			Newobj = 114,
			Castclass = 115,
			Isinst = 116,
			Conv_R_Un = 117,
			Unbox = 118,
			Throw = 119,
			Ldfld = 120,
			Ldflda = 121,
			Stfld = 122,
			Ldsfld = 123,
			Ldsflda = 124,
			Stsfld = 125,
			Stobj = 126,
			Conv_Ovf_I1_Un = 127,
			Conv_Ovf_I2_Un = 128,
			Conv_Ovf_I4_Un = 129,
			Conv_Ovf_I8_Un = 130,
			Conv_Ovf_U1_Un = 131,
			Conv_Ovf_U2_Un = 132,
			Conv_Ovf_U4_Un = 133,
			Conv_Ovf_U8_Un = 134,
			Conv_Ovf_I_Un = 135,
			Conv_Ovf_U_Un = 136,
			Box = 137,
			Newarr = 138,
			Ldlen = 139,
			Ldelema = 140,
			Ldelem_I1 = 141,
			Ldelem_U1 = 142,
			Ldelem_I2 = 143,
			Ldelem_U2 = 144,
			Ldelem_I4 = 145,
			Ldelem_U4 = 146,
			Ldelem_I8 = 147,
			Ldelem_I = 148,
			Ldelem_R4 = 149,
			Ldelem_R8 = 150,
			Ldelem_Ref = 151,
			Stelem_I = 152,
			Stelem_I1 = 153,
			Stelem_I2 = 154,
			Stelem_I4 = 155,
			Stelem_I8 = 156,
			Stelem_R4 = 157,
			Stelem_R8 = 158,
			Stelem_Ref = 159,
			Ldelem_Any = 160,
			Stelem_Any = 161,
			Unbox_Any = 162,
			Conv_Ovf_I1 = 163,
			Conv_Ovf_U1 = 164,
			Conv_Ovf_I2 = 165,
			Conv_Ovf_U2 = 166,
			Conv_Ovf_I4 = 167,
			Conv_Ovf_U4 = 168,
			Conv_Ovf_I8 = 169,
			Conv_Ovf_U8 = 170,
			Refanyval = 171,
			Ckfinite = 172,
			Mkrefany = 173,
			Ldtoken = 174,
			Conv_U2 = 175,
			Conv_U1 = 176,
			Conv_I = 177,
			Conv_Ovf_I = 178,
			Conv_Ovf_U = 179,
			Add_Ovf = 180,
			Add_Ovf_Un = 181,
			Mul_Ovf = 182,
			Mul_Ovf_Un = 183,
			Sub_Ovf = 184,
			Sub_Ovf_Un = 185,
			Endfinally = 186,
			Leave = 187,
			Leave_S = 188,
			Stind_I = 189,
			Conv_U = 190,
			Arglist = 191,
			Ceq = 192,
			Cgt = 193,
			Cgt_Un = 194,
			Clt = 195,
			Clt_Un = 196,
			Ldftn = 197,
			Ldvirtftn = 198,
			Ldarg = 199,
			Ldarga = 200,
			Starg = 201,
			Ldloc = 202,
			Ldloca = 203,
			Stloc = 204,
			Localloc = 205,
			Endfilter = 206,
			Unaligned = 207,
			Volatile = 208,
			Tail = 209,
			Initobj = 210,
			Constrained = 211,
			Cpblk = 212,
			Initblk = 213,
			No = 214,
			Rethrow = 215,
			Sizeof = 216,
			Refanytype = 217,
			Readonly = 218,
		}
		class ConstantDebugInformation extends Mono.Cecil.Cil.DebugInformation {
			Name: string;
			ConstantType: Mono.Cecil.TypeReference;
			Value: any;
			 constructor(name: string, constant_type: Mono.Cecil.TypeReference, value: any) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class CustomDebugInformation extends Mono.Cecil.Cil.DebugInformation {
			Identifier: System.Guid;
			Kind: Mono.Cecil.Cil.CustomDebugInformationKind;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum CustomDebugInformationKind {
			Binary = 0,
			StateMachineScope = 1,
			DynamicVariable = 2,
			DefaultNamespace = 3,
			AsyncMethodBody = 4,
			EmbeddedSource = 5,
			SourceLink = 6,
		}
		abstract class DebugInformation {
			MetadataToken: Mono.Cecil.MetadataToken;
			HasCustomDebugInformations: boolean;
			CustomDebugInformations: any;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class DefaultSymbolReaderProvider {
			 constructor() ;
			 constructor(throwIfNoSymbol: boolean) ;
			 GetSymbolReader(module: Mono.Cecil.ModuleDefinition, fileName: string) : Mono.Cecil.Cil.ISymbolReader;
			 GetSymbolReader(module: Mono.Cecil.ModuleDefinition, symbolStream: System.IO.Stream) : Mono.Cecil.Cil.ISymbolReader;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class DefaultSymbolWriterProvider {
			 constructor() ;
			 GetSymbolWriter(module: Mono.Cecil.ModuleDefinition, fileName: string) : Mono.Cecil.Cil.ISymbolWriter;
			 GetSymbolWriter(module: Mono.Cecil.ModuleDefinition, symbolStream: System.IO.Stream) : Mono.Cecil.Cil.ISymbolWriter;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class Document extends Mono.Cecil.Cil.DebugInformation {
			Url: string;
			Type: Mono.Cecil.Cil.DocumentType;
			TypeGuid: System.Guid;
			HashAlgorithm: Mono.Cecil.Cil.DocumentHashAlgorithm;
			HashAlgorithmGuid: System.Guid;
			Language: Mono.Cecil.Cil.DocumentLanguage;
			LanguageGuid: System.Guid;
			LanguageVendor: Mono.Cecil.Cil.DocumentLanguageVendor;
			LanguageVendorGuid: System.Guid;
			Hash: any;
			EmbeddedSource: any;
			 constructor(url: string) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum DocumentHashAlgorithm {
			None = 0,
			MD5 = 1,
			SHA1 = 2,
			SHA256 = 3,
		}
		enum DocumentLanguage {
			Other = 0,
			C = 1,
			Cpp = 2,
			CSharp = 3,
			Basic = 4,
			Java = 5,
			Cobol = 6,
			Pascal = 7,
			Cil = 8,
			JScript = 9,
			Smc = 10,
			MCpp = 11,
			FSharp = 12,
		}
		enum DocumentLanguageVendor {
			Other = 0,
			Microsoft = 1,
		}
		enum DocumentType {
			Other = 0,
			Text = 1,
		}
		class EmbeddedPortablePdbReader {
			 GetWriterProvider() : Mono.Cecil.Cil.ISymbolWriterProvider;
			 ProcessDebugHeader(header: Mono.Cecil.Cil.ImageDebugHeader) : boolean;
			 Read(method: Mono.Cecil.MethodDefinition) : Mono.Cecil.Cil.MethodDebugInformation;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class EmbeddedPortablePdbReaderProvider {
			 constructor() ;
			 GetSymbolReader(module: Mono.Cecil.ModuleDefinition, fileName: string) : Mono.Cecil.Cil.ISymbolReader;
			 GetSymbolReader(module: Mono.Cecil.ModuleDefinition, symbolStream: System.IO.Stream) : Mono.Cecil.Cil.ISymbolReader;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class EmbeddedPortablePdbWriter {
			 GetReaderProvider() : Mono.Cecil.Cil.ISymbolReaderProvider;
			 GetDebugHeader() : Mono.Cecil.Cil.ImageDebugHeader;
			 Write(info: Mono.Cecil.Cil.MethodDebugInformation) : void;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class EmbeddedPortablePdbWriterProvider {
			 constructor() ;
			 GetSymbolWriter(module: Mono.Cecil.ModuleDefinition, fileName: string) : Mono.Cecil.Cil.ISymbolWriter;
			 GetSymbolWriter(module: Mono.Cecil.ModuleDefinition, symbolStream: System.IO.Stream) : Mono.Cecil.Cil.ISymbolWriter;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class EmbeddedSourceDebugInformation extends Mono.Cecil.Cil.CustomDebugInformation {
			Content: any;
			Compress: boolean;
			Kind: Mono.Cecil.Cil.CustomDebugInformationKind;
			 constructor(content: any, compress: boolean) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ExceptionHandler {
			TryStart: Mono.Cecil.Cil.Instruction;
			TryEnd: Mono.Cecil.Cil.Instruction;
			FilterStart: Mono.Cecil.Cil.Instruction;
			HandlerStart: Mono.Cecil.Cil.Instruction;
			HandlerEnd: Mono.Cecil.Cil.Instruction;
			CatchType: Mono.Cecil.TypeReference;
			HandlerType: Mono.Cecil.Cil.ExceptionHandlerType;
			 constructor(handlerType: Mono.Cecil.Cil.ExceptionHandlerType) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum ExceptionHandlerType {
			Catch = 0,
			Filter = 1,
			Finally = 2,
			Fault = 4,
		}
		enum FlowControl {
			Branch = 0,
			Break = 1,
			Call = 2,
			Cond_Branch = 3,
			Meta = 4,
			Next = 5,
			Phi = 6,
			Return = 7,
			Throw = 8,
		}
		interface ICustomDebugInformationProvider {
			HasCustomDebugInformations: boolean;
			CustomDebugInformations: any;
		}
		class ILProcessor {
			Body: Mono.Cecil.Cil.MethodBody;
			 Create(opcode: Mono.Cecil.Cil.OpCode) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, type: Mono.Cecil.TypeReference) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, site: Mono.Cecil.CallSite) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, method: Mono.Cecil.MethodReference) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, field: Mono.Cecil.FieldReference) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, value: string) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, value: System.SByte) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, value: System.Byte) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, value: number) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, value: number) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, value: number) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, value: System.Double) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, target: Mono.Cecil.Cil.Instruction) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, targets: any) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, variable: Mono.Cecil.Cil.VariableDefinition) : Mono.Cecil.Cil.Instruction;
			 Create(opcode: Mono.Cecil.Cil.OpCode, parameter: Mono.Cecil.ParameterDefinition) : Mono.Cecil.Cil.Instruction;
			 Emit(opcode: Mono.Cecil.Cil.OpCode) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, type: Mono.Cecil.TypeReference) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, method: Mono.Cecil.MethodReference) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, site: Mono.Cecil.CallSite) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, field: Mono.Cecil.FieldReference) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, value: string) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, value: System.Byte) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, value: System.SByte) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, value: number) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, value: number) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, value: number) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, value: System.Double) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, target: Mono.Cecil.Cil.Instruction) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, targets: any) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, variable: Mono.Cecil.Cil.VariableDefinition) : void;
			 Emit(opcode: Mono.Cecil.Cil.OpCode, parameter: Mono.Cecil.ParameterDefinition) : void;
			 InsertBefore(target: Mono.Cecil.Cil.Instruction, instruction: Mono.Cecil.Cil.Instruction) : void;
			 InsertAfter(target: Mono.Cecil.Cil.Instruction, instruction: Mono.Cecil.Cil.Instruction) : void;
			 InsertAfter(index: number, instruction: Mono.Cecil.Cil.Instruction) : void;
			 Append(instruction: Mono.Cecil.Cil.Instruction) : void;
			 Replace(target: Mono.Cecil.Cil.Instruction, instruction: Mono.Cecil.Cil.Instruction) : void;
			 Replace(index: number, instruction: Mono.Cecil.Cil.Instruction) : void;
			 Remove(instruction: Mono.Cecil.Cil.Instruction) : void;
			 RemoveAt(index: number) : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ImageDebugDirectory extends System.ValueType {
			Characteristics: number;
			TimeDateStamp: number;
			MajorVersion: number;
			MinorVersion: number;
			Type: Mono.Cecil.Cil.ImageDebugType;
			SizeOfData: number;
			AddressOfRawData: number;
			PointerToRawData: number;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		class ImageDebugHeader {
			HasEntries: boolean;
			Entries: any;
			 constructor(entries: any) ;
			 constructor() ;
			 constructor(entry: Mono.Cecil.Cil.ImageDebugHeaderEntry) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ImageDebugHeaderEntry {
			Directory: Mono.Cecil.Cil.ImageDebugDirectory;
			Data: any;
			 constructor(directory: Mono.Cecil.Cil.ImageDebugDirectory, data: any) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum ImageDebugType {
			CodeView = 2,
			Deterministic = 16,
			EmbeddedPortablePdb = 17,
		}
		class ImportDebugInformation extends Mono.Cecil.Cil.DebugInformation {
			HasTargets: boolean;
			Targets: any;
			Parent: Mono.Cecil.Cil.ImportDebugInformation;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ImportTarget {
			Namespace: string;
			Type: Mono.Cecil.TypeReference;
			AssemblyReference: Mono.Cecil.AssemblyNameReference;
			Alias: string;
			Kind: Mono.Cecil.Cil.ImportTargetKind;
			 constructor(kind: Mono.Cecil.Cil.ImportTargetKind) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum ImportTargetKind {
			ImportNamespace = 1,
			ImportNamespaceInAssembly = 2,
			ImportType = 3,
			ImportXmlNamespaceWithAlias = 4,
			ImportAlias = 5,
			DefineAssemblyAlias = 6,
			DefineNamespaceAlias = 7,
			DefineNamespaceInAssemblyAlias = 8,
			DefineTypeAlias = 9,
		}
		class Instruction {
			Offset: number;
			OpCode: Mono.Cecil.Cil.OpCode;
			Operand: any;
			Previous: Mono.Cecil.Cil.Instruction;
			Next: Mono.Cecil.Cil.Instruction;
			 GetSize() : number;
			 ToString() : string;
			 static Create(opcode: Mono.Cecil.Cil.OpCode) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, type: Mono.Cecil.TypeReference) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, site: Mono.Cecil.CallSite) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, method: Mono.Cecil.MethodReference) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, field: Mono.Cecil.FieldReference) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, value: string) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, value: System.SByte) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, value: System.Byte) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, value: number) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, value: number) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, value: number) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, value: System.Double) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, target: Mono.Cecil.Cil.Instruction) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, targets: any) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, variable: Mono.Cecil.Cil.VariableDefinition) : Mono.Cecil.Cil.Instruction;
			 static Create(opcode: Mono.Cecil.Cil.OpCode, parameter: Mono.Cecil.ParameterDefinition) : Mono.Cecil.Cil.Instruction;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class InstructionOffset extends System.ValueType {
			Offset: number;
			IsEndOfMethod: boolean;
			 constructor(instruction: Mono.Cecil.Cil.Instruction) ;
			 constructor(offset: number) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		interface ISymbolReader {
			 GetWriterProvider() : Mono.Cecil.Cil.ISymbolWriterProvider;
			 ProcessDebugHeader(header: Mono.Cecil.Cil.ImageDebugHeader) : boolean;
			 Read(method: Mono.Cecil.MethodDefinition) : Mono.Cecil.Cil.MethodDebugInformation;
		}
		interface ISymbolReaderProvider {
			 GetSymbolReader(module: Mono.Cecil.ModuleDefinition, fileName: string) : Mono.Cecil.Cil.ISymbolReader;
			 GetSymbolReader(module: Mono.Cecil.ModuleDefinition, symbolStream: System.IO.Stream) : Mono.Cecil.Cil.ISymbolReader;
		}
		interface ISymbolWriter {
			 GetReaderProvider() : Mono.Cecil.Cil.ISymbolReaderProvider;
			 GetDebugHeader() : Mono.Cecil.Cil.ImageDebugHeader;
			 Write(info: Mono.Cecil.Cil.MethodDebugInformation) : void;
		}
		interface ISymbolWriterProvider {
			 GetSymbolWriter(module: Mono.Cecil.ModuleDefinition, fileName: string) : Mono.Cecil.Cil.ISymbolWriter;
			 GetSymbolWriter(module: Mono.Cecil.ModuleDefinition, symbolStream: System.IO.Stream) : Mono.Cecil.Cil.ISymbolWriter;
		}
		class MethodBody {
			Method: Mono.Cecil.MethodDefinition;
			MaxStackSize: number;
			CodeSize: number;
			InitLocals: boolean;
			LocalVarToken: Mono.Cecil.MetadataToken;
			Instructions: any;
			HasExceptionHandlers: boolean;
			ExceptionHandlers: any;
			HasVariables: boolean;
			Variables: any;
			ThisParameter: Mono.Cecil.ParameterDefinition;
			 constructor(method: Mono.Cecil.MethodDefinition) ;
			 GetILProcessor() : Mono.Cecil.Cil.ILProcessor;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class MethodDebugInformation extends Mono.Cecil.Cil.DebugInformation {
			Method: Mono.Cecil.MethodDefinition;
			HasSequencePoints: boolean;
			SequencePoints: any;
			Scope: Mono.Cecil.Cil.ScopeDebugInformation;
			StateMachineKickOffMethod: Mono.Cecil.MethodDefinition;
			 GetSequencePoint(instruction: Mono.Cecil.Cil.Instruction) : Mono.Cecil.Cil.SequencePoint;
			 GetSequencePointMapping() : any;
			 GetScopes() : any;
			 TryGetName(variable: Mono.Cecil.Cil.VariableDefinition, name: any) : boolean;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class OpCode extends System.ValueType {
			Name: string;
			Size: number;
			Op1: System.Byte;
			Op2: System.Byte;
			Value: number;
			Code: Mono.Cecil.Cil.Code;
			FlowControl: Mono.Cecil.Cil.FlowControl;
			OpCodeType: Mono.Cecil.Cil.OpCodeType;
			OperandType: Mono.Cecil.Cil.OperandType;
			StackBehaviourPop: Mono.Cecil.Cil.StackBehaviour;
			StackBehaviourPush: Mono.Cecil.Cil.StackBehaviour;
			 GetHashCode() : number;
			 Equals(obj: any) : boolean;
			 Equals(opcode: Mono.Cecil.Cil.OpCode) : boolean;
			 static op_Equality(one: Mono.Cecil.Cil.OpCode, other: Mono.Cecil.Cil.OpCode) : boolean;
			 static op_Inequality(one: Mono.Cecil.Cil.OpCode, other: Mono.Cecil.Cil.OpCode) : boolean;
			 ToString() : string;
			 GetType() : System.Type;
		}
		abstract class OpCodes {
			 static GetType() : System.Type;
			 static ToString() : string;
			 static Equals(obj: any) : boolean;
			 static GetHashCode() : number;
		}
		enum OpCodeType {
			Annotation = 0,
			Macro = 1,
			Nternal = 2,
			Objmodel = 3,
			Prefix = 4,
			Primitive = 5,
		}
		enum OperandType {
			InlineBrTarget = 0,
			InlineField = 1,
			InlineI = 2,
			InlineI8 = 3,
			InlineMethod = 4,
			InlineNone = 5,
			InlinePhi = 6,
			InlineR = 7,
			InlineSig = 8,
			InlineString = 9,
			InlineSwitch = 10,
			InlineTok = 11,
			InlineType = 12,
			InlineVar = 13,
			InlineArg = 14,
			ShortInlineBrTarget = 15,
			ShortInlineI = 16,
			ShortInlineR = 17,
			ShortInlineVar = 18,
			ShortInlineArg = 19,
		}
		class PortablePdbReader {
			 GetWriterProvider() : Mono.Cecil.Cil.ISymbolWriterProvider;
			 ProcessDebugHeader(header: Mono.Cecil.Cil.ImageDebugHeader) : boolean;
			 Read(method: Mono.Cecil.MethodDefinition) : Mono.Cecil.Cil.MethodDebugInformation;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class PortablePdbReaderProvider {
			 constructor() ;
			 GetSymbolReader(module: Mono.Cecil.ModuleDefinition, fileName: string) : Mono.Cecil.Cil.ISymbolReader;
			 GetSymbolReader(module: Mono.Cecil.ModuleDefinition, symbolStream: System.IO.Stream) : Mono.Cecil.Cil.ISymbolReader;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class PortablePdbWriter {
			 GetReaderProvider() : Mono.Cecil.Cil.ISymbolReaderProvider;
			 GetDebugHeader() : Mono.Cecil.Cil.ImageDebugHeader;
			 Write(info: Mono.Cecil.Cil.MethodDebugInformation) : void;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class PortablePdbWriterProvider {
			 constructor() ;
			 GetSymbolWriter(module: Mono.Cecil.ModuleDefinition, fileName: string) : Mono.Cecil.Cil.ISymbolWriter;
			 GetSymbolWriter(module: Mono.Cecil.ModuleDefinition, symbolStream: System.IO.Stream) : Mono.Cecil.Cil.ISymbolWriter;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ScopeDebugInformation extends Mono.Cecil.Cil.DebugInformation {
			Start: Mono.Cecil.Cil.InstructionOffset;
			End: Mono.Cecil.Cil.InstructionOffset;
			Import: Mono.Cecil.Cil.ImportDebugInformation;
			HasScopes: boolean;
			Scopes: any;
			HasVariables: boolean;
			Variables: any;
			HasConstants: boolean;
			Constants: any;
			 constructor(start: Mono.Cecil.Cil.Instruction, end: Mono.Cecil.Cil.Instruction) ;
			 TryGetName(variable: Mono.Cecil.Cil.VariableDefinition, name: any) : boolean;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class SequencePoint {
			Offset: number;
			StartLine: number;
			StartColumn: number;
			EndLine: number;
			EndColumn: number;
			IsHidden: boolean;
			Document: Mono.Cecil.Cil.Document;
			 constructor(instruction: Mono.Cecil.Cil.Instruction, document: Mono.Cecil.Cil.Document) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class SourceLinkDebugInformation extends Mono.Cecil.Cil.CustomDebugInformation {
			Content: string;
			Kind: Mono.Cecil.Cil.CustomDebugInformationKind;
			 constructor(content: string) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum StackBehaviour {
			Pop0 = 0,
			Pop1 = 1,
			Pop1_pop1 = 2,
			Popi = 3,
			Popi_pop1 = 4,
			Popi_popi = 5,
			Popi_popi8 = 6,
			Popi_popi_popi = 7,
			Popi_popr4 = 8,
			Popi_popr8 = 9,
			Popref = 10,
			Popref_pop1 = 11,
			Popref_popi = 12,
			Popref_popi_popi = 13,
			Popref_popi_popi8 = 14,
			Popref_popi_popr4 = 15,
			Popref_popi_popr8 = 16,
			Popref_popi_popref = 17,
			PopAll = 18,
			Push0 = 19,
			Push1 = 20,
			Push1_push1 = 21,
			Pushi = 22,
			Pushi8 = 23,
			Pushr4 = 24,
			Pushr8 = 25,
			Pushref = 26,
			Varpop = 27,
			Varpush = 28,
		}
		class StateMachineScope {
			Start: Mono.Cecil.Cil.InstructionOffset;
			End: Mono.Cecil.Cil.InstructionOffset;
			 constructor(start: Mono.Cecil.Cil.Instruction, end: Mono.Cecil.Cil.Instruction) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class StateMachineScopeDebugInformation extends Mono.Cecil.Cil.CustomDebugInformation {
			Scopes: any;
			Kind: Mono.Cecil.Cil.CustomDebugInformationKind;
			 constructor() ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class SymbolsNotFoundException extends System.IO.FileNotFoundException {
			 constructor(message: string) ;
			 ToString() : string;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 GetBaseException() : System.Exception;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class SymbolsNotMatchingException extends System.InvalidOperationException {
			 constructor(message: string) ;
			 GetBaseException() : System.Exception;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 ToString() : string;
			 GetType() : System.Type;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		/** Flags */
		enum VariableAttributes {
			None = 0,
			DebuggerHidden = 1,
		}
		class VariableDebugInformation extends Mono.Cecil.Cil.DebugInformation {
			Index: number;
			Name: string;
			Attributes: Mono.Cecil.Cil.VariableAttributes;
			IsDebuggerHidden: boolean;
			 constructor(variable: Mono.Cecil.Cil.VariableDefinition, name: string) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class VariableDefinition extends Mono.Cecil.Cil.VariableReference {
			IsPinned: boolean;
			 constructor(variableType: Mono.Cecil.TypeReference) ;
			 Resolve() : Mono.Cecil.Cil.VariableDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class VariableIndex extends System.ValueType {
			Index: number;
			 constructor(variable: Mono.Cecil.Cil.VariableDefinition) ;
			 constructor(index: number) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 GetType() : System.Type;
		}
		abstract class VariableReference {
			VariableType: Mono.Cecil.TypeReference;
			Index: number;
			 Resolve() : Mono.Cecil.Cil.VariableDefinition;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module MonoMod {
		enum DebugSymbolFormat {
			Auto = 0,
			MDB = 1,
			PDB = 2,
		}
		class MethodBodyRewriter extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(modder: MonoMod.MonoModder, body: Mono.Cecil.Cil.MethodBody, instr: Mono.Cecil.Cil.Instruction, instri: number) : void;
			 BeginInvoke(modder: MonoMod.MonoModder, body: Mono.Cecil.Cil.MethodBody, instr: Mono.Cecil.Cil.Instruction, instri: number, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : void;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MethodParser extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(modder: MonoMod.MonoModder, body: Mono.Cecil.Cil.MethodBody, instr: Mono.Cecil.Cil.Instruction, instri: any) : boolean;
			 BeginInvoke(modder: MonoMod.MonoModder, body: Mono.Cecil.Cil.MethodBody, instr: Mono.Cecil.Cil.Instruction, instri: any, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(instri: any, result: System.IAsyncResult) : boolean;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MethodRewriter extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(modder: MonoMod.MonoModder, method: Mono.Cecil.MethodDefinition) : void;
			 BeginInvoke(modder: MonoMod.MonoModder, method: Mono.Cecil.MethodDefinition, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : void;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MissingDependencyResolver extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(modder: MonoMod.MonoModder, main: Mono.Cecil.ModuleDefinition, name: string, fullName: string) : Mono.Cecil.ModuleDefinition;
			 BeginInvoke(modder: MonoMod.MonoModder, main: Mono.Cecil.ModuleDefinition, name: string, fullName: string, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : Mono.Cecil.ModuleDefinition;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class ModReadEventHandler extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(modder: MonoMod.MonoModder, mod: Mono.Cecil.ModuleDefinition) : void;
			 BeginInvoke(modder: MonoMod.MonoModder, mod: Mono.Cecil.ModuleDefinition, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : void;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModAdded extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModConstructor extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModCustomAttributeAttribute extends System.Attribute {
			 constructor(h: string) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModCustomMethodAttributeAttribute extends System.Attribute {
			 constructor(h: string) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModder {
			SharedData: any;
			RelinkMap: any;
			RelinkModuleMap: any;
			SkipList: any;
			RelinkMapCache: any;
			RelinkModuleMapCache: any;
			ForceCallMap: any;
			OnReadMod: MonoMod.ModReadEventHandler;
			PostProcessors: MonoMod.PostProcessor;
			CustomAttributeHandlers: any;
			CustomMethodAttributeHandlers: any;
			MissingDependencyResolver: MonoMod.MissingDependencyResolver;
			MethodParser: MonoMod.MethodParser;
			MethodRewriter: MonoMod.MethodRewriter;
			MethodBodyRewriter: MonoMod.MethodBodyRewriter;
			Input: System.IO.Stream;
			InputPath: string;
			Output: System.IO.Stream;
			OutputPath: string;
			DependencyDirs: any;
			Module: Mono.Cecil.ModuleDefinition;
			DependencyMap: any;
			DependencyCache: any;
			ShouldCleanupAttrib: any;
			LogVerboseEnabled: boolean;
			CleanupEnabled: boolean;
			PublicEverything: boolean;
			Mods: any;
			Strict: boolean;
			MissingDependencyThrow: boolean;
			RemovePatchReferences: boolean;
			PreventInline: boolean;
			UpgradeMSCORLIB: any;
			ReadingMode: Mono.Cecil.ReadingMode;
			DebugSymbolOutputFormat: MonoMod.DebugSymbolFormat;
			CurrentRID: number;
			AssemblyResolver: Mono.Cecil.IAssemblyResolver;
			ReaderParameters: Mono.Cecil.ReaderParameters;
			WriterParameters: Mono.Cecil.WriterParameters;
			GACPaths: string[];
			 constructor() ;
			 ClearCaches(all?: boolean, shareable?: boolean, moduleSpecific?: boolean) : void;
			 Dispose() : void;
			 Log(value: any) : void;
			 Log(text: string) : void;
			 LogVerbose(value: any) : void;
			 LogVerbose(text: string) : void;
			 Read() : void;
			 MapDependencies() : void;
			 MapDependencies(main: Mono.Cecil.ModuleDefinition) : void;
			 MapDependency(main: Mono.Cecil.ModuleDefinition, depRef: Mono.Cecil.AssemblyNameReference) : void;
			 MapDependency(main: Mono.Cecil.ModuleDefinition, name: string, fullName?: string, depRef?: Mono.Cecil.AssemblyNameReference) : void;
			 DefaultMissingDependencyResolver(mod: MonoMod.MonoModder, main: Mono.Cecil.ModuleDefinition, name: string, fullName: string) : Mono.Cecil.ModuleDefinition;
			 Write(output?: System.IO.Stream, outputPath?: string) : void;
			 GenReaderParameters(mainModule: boolean, path?: string) : Mono.Cecil.ReaderParameters;
			 ReadMod(path: string) : void;
			 ReadMod(stream: System.IO.Stream) : void;
			 ParseRules(mod: Mono.Cecil.ModuleDefinition) : void;
			 ParseRulesInType(type: Mono.Cecil.TypeDefinition, rulesTypeMMILRT?: System.Type) : void;
			 ParseLinkFrom(target: Mono.Cecil.MemberReference, hook: Mono.Cecil.CustomAttribute) : void;
			 ParseLinkTo(from: Mono.Cecil.MemberReference, hook: Mono.Cecil.CustomAttribute) : void;
			 RunCustomAttributeHandlers(cap: Mono.Cecil.ICustomAttributeProvider) : void;
			 AutoPatch() : void;
			 Relinker(mtp: Mono.Cecil.IMetadataTokenProvider, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.IMetadataTokenProvider;
			 MainRelinker(mtp: Mono.Cecil.IMetadataTokenProvider, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.IMetadataTokenProvider;
			 PostRelinker(mtp: Mono.Cecil.IMetadataTokenProvider, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.IMetadataTokenProvider;
			 ResolveRelinkTarget(mtp: Mono.Cecil.IMetadataTokenProvider, relink?: boolean, relinkModule?: boolean) : Mono.Cecil.IMetadataTokenProvider;
			 DefaultParser(mod: MonoMod.MonoModder, body: Mono.Cecil.Cil.MethodBody, instr: Mono.Cecil.Cil.Instruction, instri: any) : boolean;
			 FindType(name: string) : Mono.Cecil.TypeReference;
			 FindType(name: string, runtimeName: boolean) : Mono.Cecil.TypeReference;
			 FindTypeDeep(name: string) : Mono.Cecil.TypeReference;
			 PrePatchModule(mod: Mono.Cecil.ModuleDefinition) : void;
			 PrePatchType(type: Mono.Cecil.TypeDefinition, forceAdd?: boolean) : void;
			 PatchModule(mod: Mono.Cecil.ModuleDefinition) : void;
			 PatchType(type: Mono.Cecil.TypeDefinition) : void;
			 PatchProperty(targetType: Mono.Cecil.TypeDefinition, prop: Mono.Cecil.PropertyDefinition, propMethods?: any) : void;
			 PatchEvent(targetType: Mono.Cecil.TypeDefinition, srcEvent: Mono.Cecil.EventDefinition, propMethods?: any) : void;
			 PatchField(targetType: Mono.Cecil.TypeDefinition, field: Mono.Cecil.FieldDefinition) : void;
			 PatchMethod(targetType: Mono.Cecil.TypeDefinition, method: Mono.Cecil.MethodDefinition) : Mono.Cecil.MethodDefinition;
			 PatchRefs() : void;
			 PatchRefs(mod: Mono.Cecil.ModuleDefinition) : void;
			 PatchRefsInType(type: Mono.Cecil.TypeDefinition) : void;
			 PatchRefsInMethod(method: Mono.Cecil.MethodDefinition) : void;
			 Cleanup(all?: boolean) : void;
			 CleanupType(type: Mono.Cecil.TypeDefinition, all?: boolean) : void;
			 Cleanup(cap: Mono.Cecil.ICustomAttributeProvider, all?: boolean) : void;
			 DefaultPostProcessor(modder: MonoMod.MonoModder) : void;
			 DefaultPostProcessType(type: Mono.Cecil.TypeDefinition) : void;
			 PatchWasHere() : Mono.Cecil.TypeDefinition;
			 GetMonoModOriginalCtor() : Mono.Cecil.MethodReference;
			 GetMonoModOriginalNameCtor() : Mono.Cecil.MethodReference;
			 GetMonoModAddedCtor() : Mono.Cecil.MethodReference;
			 GetMonoModPatchCtor() : Mono.Cecil.MethodReference;
			 GetMetadataToken(type: Mono.Cecil.TokenType) : Mono.Cecil.MetadataToken;
			 AllowedSpecialName(method: Mono.Cecil.MethodDefinition, targetType?: Mono.Cecil.TypeDefinition) : boolean;
			 MatchingConditionals(cap: Mono.Cecil.ICustomAttributeProvider, module: Mono.Cecil.ModuleDefinition) : boolean;
			 MatchingConditionals(cap: Mono.Cecil.ICustomAttributeProvider, asmName?: Mono.Cecil.AssemblyNameReference) : boolean;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class MonoModEnumReplace extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModForceCall extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModForceCallvirt extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModHook extends System.Attribute {
			FindableID: string;
			Type: System.Type;
			 constructor(findableID: string) ;
			 constructor(type: System.Type) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModIfFlag extends System.Attribute {
			 constructor(key: string) ;
			 constructor(key: string, fallback: boolean) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModIgnore extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModLinkFrom extends System.Attribute {
			FindableID: string;
			Type: System.Type;
			 constructor(findableID: string) ;
			 constructor(type: System.Type) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModLinkTo extends System.Attribute {
			 constructor(t: string) ;
			 constructor(t: System.Type) ;
			 constructor(t: string, n: string) ;
			 constructor(t: System.Type, n: string) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModNoNew extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModOnPlatform extends System.Attribute {
			 constructor(p: any) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModOriginal extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModOriginalName extends System.Attribute {
			 constructor(n: string) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModPatch extends System.Attribute {
			 constructor(name: string) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModPublic extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModRemove extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModReplace extends System.Attribute {
			 constructor() ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class MonoModTargetModule extends System.Attribute {
			 constructor(name: string) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 Match(obj: any) : boolean;
			 IsDefaultAttribute() : boolean;
			 GetType() : System.Type;
			 ToString() : string;
		}
		abstract class PatcherExtensions {
			 static SetPublic(mtp: Mono.Cecil.IMetadataTokenProvider, p: boolean) : void;
			 static SetPublic(o: Mono.Cecil.FieldDefinition, p: boolean) : void;
			 static SetPublic(o: Mono.Cecil.MethodDefinition, p: boolean) : void;
			 static SetPublic(o: Mono.Cecil.PropertyDefinition, p: boolean) : void;
			 static SetPublic(o: Mono.Cecil.EventDefinition, p: boolean) : void;
			 static SetPublic(o: Mono.Cecil.TypeDefinition, p: boolean) : void;
			 static GetOriginalName(method: Mono.Cecil.MethodDefinition) : string;
			 static GetType() : System.Type;
			 static ToString() : string;
			 static Equals(obj: any) : boolean;
			 static GetHashCode() : number;
		}
		class PostProcessor extends System.MulticastDelegate {
			 constructor(object: any, method: System.IntPtr) ;
			 Invoke(modder: MonoMod.MonoModder) : void;
			 BeginInvoke(modder: MonoMod.MonoModder, callback: System.AsyncCallback, object: any) : System.IAsyncResult;
			 EndInvoke(result: System.IAsyncResult) : void;
			 GetObjectData(info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) : void;
			 Equals(obj: any) : boolean;
			 GetInvocationList() : any;
			 GetHashCode() : number;
			 Clone() : any;
			 DynamicInvoke(...args: any) : any;
			 GetType() : System.Type;
			 ToString() : string;
		}
		class RelinkMapEntry {
			Type: string;
			FindableID: string;
			 constructor() ;
			 constructor(type: string, findableID: string) ;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module MonoMod.InlineRT {
		abstract class MonoModRule {
			 static RelinkModule(from: string, toName: string) : void;
			 static RelinkType(from: string, to: string) : void;
			 static RelinkMember(from: string, toType: string, toMember: string) : void;
			 static Patch(id: string, patch: boolean) : void;
			 static RegisterCustomAttribute(attribName: string, handlerName: string) : void;
			 static RegisterCustomMethodAttribute(attribName: string, handlerName: string) : void;
			 static GetType() : System.Type;
			 static ToString() : string;
			 static Equals(obj: any) : boolean;
			 static GetHashCode() : number;
		}
		abstract class MonoModRulesManager {
			 static Register(self: MonoMod.MonoModder) : void;
			 static GetId(self: MonoMod.MonoModder) : number;
			 static GetModder(asmName: string) : MonoMod.MonoModder;
			 static ExecuteRules(self: MonoMod.MonoModder, orig: Mono.Cecil.TypeDefinition) : System.Type;
			 static GetType() : System.Type;
			 static ToString() : string;
			 static Equals(obj: any) : boolean;
			 static GetHashCode() : number;
		}
	}
	module System.Net.Http {
		class HttpClient extends System.Net.Http.HttpMessageInvoker {
			DefaultRequestHeaders: System.Net.Http.Headers.HttpRequestHeaders;
			DefaultRequestVersion: System.Version;
			BaseAddress: System.Uri;
			Timeout: System.TimeSpan;
			MaxResponseContentBufferSize: number;
			 constructor() ;
			 constructor(handler: any) ;
			 constructor(handler: any, disposeHandler: boolean) ;
			 GetStringAsync(requestUri: string) : any;
			 GetStringAsync(requestUri: System.Uri) : any;
			 GetStringAsync(requestUri: string, cancellationToken: System.Threading.CancellationToken) : any;
			 GetStringAsync(requestUri: System.Uri, cancellationToken: System.Threading.CancellationToken) : any;
			 GetByteArrayAsync(requestUri: string) : any;
			 GetByteArrayAsync(requestUri: System.Uri) : any;
			 GetByteArrayAsync(requestUri: string, cancellationToken: System.Threading.CancellationToken) : any;
			 GetByteArrayAsync(requestUri: System.Uri, cancellationToken: System.Threading.CancellationToken) : any;
			 GetStreamAsync(requestUri: string) : any;
			 GetStreamAsync(requestUri: string, cancellationToken: System.Threading.CancellationToken) : any;
			 GetStreamAsync(requestUri: System.Uri) : any;
			 GetStreamAsync(requestUri: System.Uri, cancellationToken: System.Threading.CancellationToken) : any;
			 GetAsync(requestUri: string) : any;
			 GetAsync(requestUri: System.Uri) : any;
			 GetAsync(requestUri: string, completionOption: System.Net.Http.HttpCompletionOption) : any;
			 GetAsync(requestUri: System.Uri, completionOption: System.Net.Http.HttpCompletionOption) : any;
			 GetAsync(requestUri: string, cancellationToken: System.Threading.CancellationToken) : any;
			 GetAsync(requestUri: System.Uri, cancellationToken: System.Threading.CancellationToken) : any;
			 GetAsync(requestUri: string, completionOption: System.Net.Http.HttpCompletionOption, cancellationToken: System.Threading.CancellationToken) : any;
			 GetAsync(requestUri: System.Uri, completionOption: System.Net.Http.HttpCompletionOption, cancellationToken: System.Threading.CancellationToken) : any;
			 PostAsync(requestUri: string, content: System.Net.Http.HttpContent) : any;
			 PostAsync(requestUri: System.Uri, content: System.Net.Http.HttpContent) : any;
			 PostAsync(requestUri: string, content: System.Net.Http.HttpContent, cancellationToken: System.Threading.CancellationToken) : any;
			 PostAsync(requestUri: System.Uri, content: System.Net.Http.HttpContent, cancellationToken: System.Threading.CancellationToken) : any;
			 PutAsync(requestUri: string, content: System.Net.Http.HttpContent) : any;
			 PutAsync(requestUri: System.Uri, content: System.Net.Http.HttpContent) : any;
			 PutAsync(requestUri: string, content: System.Net.Http.HttpContent, cancellationToken: System.Threading.CancellationToken) : any;
			 PutAsync(requestUri: System.Uri, content: System.Net.Http.HttpContent, cancellationToken: System.Threading.CancellationToken) : any;
			 PatchAsync(requestUri: string, content: System.Net.Http.HttpContent) : any;
			 PatchAsync(requestUri: System.Uri, content: System.Net.Http.HttpContent) : any;
			 PatchAsync(requestUri: string, content: System.Net.Http.HttpContent, cancellationToken: System.Threading.CancellationToken) : any;
			 PatchAsync(requestUri: System.Uri, content: System.Net.Http.HttpContent, cancellationToken: System.Threading.CancellationToken) : any;
			 DeleteAsync(requestUri: string) : any;
			 DeleteAsync(requestUri: System.Uri) : any;
			 DeleteAsync(requestUri: string, cancellationToken: System.Threading.CancellationToken) : any;
			 DeleteAsync(requestUri: System.Uri, cancellationToken: System.Threading.CancellationToken) : any;
			 SendAsync(request: System.Net.Http.HttpRequestMessage) : any;
			 SendAsync(request: System.Net.Http.HttpRequestMessage, cancellationToken: System.Threading.CancellationToken) : any;
			 SendAsync(request: System.Net.Http.HttpRequestMessage, completionOption: System.Net.Http.HttpCompletionOption) : any;
			 SendAsync(request: System.Net.Http.HttpRequestMessage, completionOption: System.Net.Http.HttpCompletionOption, cancellationToken: System.Threading.CancellationToken) : any;
			 CancelPendingRequests() : void;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum HttpCompletionOption {
			ResponseContentRead = 0,
			ResponseHeadersRead = 1,
		}
		abstract class HttpContent {
			Headers: System.Net.Http.Headers.HttpContentHeaders;
			 ReadAsStringAsync() : any;
			 ReadAsStringAsync(cancellationToken: System.Threading.CancellationToken) : any;
			 ReadAsByteArrayAsync() : any;
			 ReadAsByteArrayAsync(cancellationToken: System.Threading.CancellationToken) : any;
			 ReadAsStreamAsync() : any;
			 ReadAsStreamAsync(cancellationToken: System.Threading.CancellationToken) : any;
			 CopyToAsync(stream: System.IO.Stream) : System.Threading.Tasks.Task;
			 CopyToAsync(stream: System.IO.Stream, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 CopyToAsync(stream: System.IO.Stream, context: System.Net.TransportContext) : System.Threading.Tasks.Task;
			 CopyToAsync(stream: System.IO.Stream, context: System.Net.TransportContext, cancellationToken: System.Threading.CancellationToken) : System.Threading.Tasks.Task;
			 LoadIntoBufferAsync() : System.Threading.Tasks.Task;
			 LoadIntoBufferAsync(maxBufferSize: number) : System.Threading.Tasks.Task;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class HttpMessageInvoker {
			 constructor(handler: any) ;
			 constructor(handler: any, disposeHandler: boolean) ;
			 SendAsync(request: System.Net.Http.HttpRequestMessage, cancellationToken: System.Threading.CancellationToken) : any;
			 Dispose() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class HttpMethod {
			Method: string;
			 constructor(method: string) ;
			 Equals(other: System.Net.Http.HttpMethod) : boolean;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 static op_Equality(left: System.Net.Http.HttpMethod, right: System.Net.Http.HttpMethod) : boolean;
			 static op_Inequality(left: System.Net.Http.HttpMethod, right: System.Net.Http.HttpMethod) : boolean;
			 GetType() : System.Type;
		}
		class HttpRequestMessage {
			Version: System.Version;
			Content: System.Net.Http.HttpContent;
			Method: System.Net.Http.HttpMethod;
			RequestUri: System.Uri;
			Headers: System.Net.Http.Headers.HttpRequestHeaders;
			Properties: any;
			 constructor() ;
			 constructor(method: System.Net.Http.HttpMethod, requestUri: System.Uri) ;
			 constructor(method: System.Net.Http.HttpMethod, requestUri: string) ;
			 ToString() : string;
			 Dispose() : void;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module System.Net {
		interface ICredentials {
			 GetCredential(uri: System.Uri, authType: string) : System.Net.NetworkCredential;
		}
		interface IWebProxy {
			Credentials: System.Net.ICredentials;
			 GetProxy(destination: System.Uri) : System.Uri;
			 IsBypassed(host: System.Uri) : boolean;
		}
		class NetworkCredential {
			UserName: string;
			Password: string;
			SecurePassword: System.Security.SecureString;
			Domain: string;
			 constructor() ;
			 constructor(userName: string, password: string) ;
			 constructor(userName: string, password: string, domain: string) ;
			 constructor(userName: string, password: System.Security.SecureString) ;
			 constructor(userName: string, password: System.Security.SecureString, domain: string) ;
			 GetCredential(uri: System.Uri, authenticationType: string) : System.Net.NetworkCredential;
			 GetCredential(host: string, port: number, authenticationType: string) : System.Net.NetworkCredential;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class TransportContext {
			 GetChannelBinding(kind: System.Security.Authentication.ExtendedProtection.ChannelBindingKind) : System.Security.Authentication.ExtendedProtection.ChannelBinding;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
	module System.Net.Http.Headers {
		class AuthenticationHeaderValue {
			Scheme: string;
			Parameter: string;
			 constructor(scheme: string) ;
			 constructor(scheme: string, parameter: string) ;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static Parse(input: string) : System.Net.Http.Headers.AuthenticationHeaderValue;
			 static TryParse(input: string, parsedValue: any) : boolean;
			 GetType() : System.Type;
		}
		class CacheControlHeaderValue {
			NoCache: boolean;
			NoCacheHeaders: any;
			NoStore: boolean;
			MaxAge: any;
			SharedMaxAge: any;
			MaxStale: boolean;
			MaxStaleLimit: any;
			MinFresh: any;
			NoTransform: boolean;
			OnlyIfCached: boolean;
			Public: boolean;
			Private: boolean;
			PrivateHeaders: any;
			MustRevalidate: boolean;
			ProxyRevalidate: boolean;
			Extensions: any;
			 constructor() ;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static Parse(input: string) : System.Net.Http.Headers.CacheControlHeaderValue;
			 static TryParse(input: string, parsedValue: any) : boolean;
			 GetType() : System.Type;
		}
		class ContentDispositionHeaderValue {
			DispositionType: string;
			Parameters: any;
			Name: string;
			FileName: string;
			FileNameStar: string;
			CreationDate: any;
			ModificationDate: any;
			ReadDate: any;
			Size: any;
			 constructor(dispositionType: string) ;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static Parse(input: string) : System.Net.Http.Headers.ContentDispositionHeaderValue;
			 static TryParse(input: string, parsedValue: any) : boolean;
			 GetType() : System.Type;
		}
		class ContentRangeHeaderValue {
			Unit: string;
			From: any;
			To: any;
			Length: any;
			HasLength: boolean;
			HasRange: boolean;
			 constructor(from: number, to: number, length: number) ;
			 constructor(length: number) ;
			 constructor(from: number, to: number) ;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 ToString() : string;
			 static Parse(input: string) : System.Net.Http.Headers.ContentRangeHeaderValue;
			 static TryParse(input: string, parsedValue: any) : boolean;
			 GetType() : System.Type;
		}
		class EntityTagHeaderValue {
			Tag: string;
			IsWeak: boolean;
			 constructor(tag: string) ;
			 constructor(tag: string, isWeak: boolean) ;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static Parse(input: string) : System.Net.Http.Headers.EntityTagHeaderValue;
			 static TryParse(input: string, parsedValue: any) : boolean;
			 GetType() : System.Type;
		}
		class HttpContentHeaders extends System.Net.Http.Headers.HttpHeaders {
			Allow: any;
			ContentDisposition: System.Net.Http.Headers.ContentDispositionHeaderValue;
			ContentEncoding: any;
			ContentLanguage: any;
			ContentLength: any;
			ContentLocation: System.Uri;
			ContentMD5: any;
			ContentRange: System.Net.Http.Headers.ContentRangeHeaderValue;
			ContentType: System.Net.Http.Headers.MediaTypeHeaderValue;
			Expires: any;
			LastModified: any;
			 Add(name: string, value: string) : void;
			 Add(name: string, values: any) : void;
			 TryAddWithoutValidation(name: string, value: string) : boolean;
			 TryAddWithoutValidation(name: string, values: any) : boolean;
			 Clear() : void;
			 GetValues(name: string) : any;
			 TryGetValues(name: string, values: any) : boolean;
			 Contains(name: string) : boolean;
			 ToString() : string;
			 GetEnumerator() : any;
			 Remove(name: string) : boolean;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		abstract class HttpHeaders {
			 Add(name: string, value: string) : void;
			 Add(name: string, values: any) : void;
			 TryAddWithoutValidation(name: string, value: string) : boolean;
			 TryAddWithoutValidation(name: string, values: any) : boolean;
			 Clear() : void;
			 GetValues(name: string) : any;
			 TryGetValues(name: string, values: any) : boolean;
			 Contains(name: string) : boolean;
			 ToString() : string;
			 GetEnumerator() : any;
			 Remove(name: string) : boolean;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class HttpRequestHeaders extends System.Net.Http.Headers.HttpHeaders {
			Accept: any;
			AcceptCharset: any;
			AcceptEncoding: any;
			AcceptLanguage: any;
			Authorization: System.Net.Http.Headers.AuthenticationHeaderValue;
			Expect: any;
			ExpectContinue: any;
			From: string;
			Host: string;
			IfMatch: any;
			IfModifiedSince: any;
			IfNoneMatch: any;
			IfRange: System.Net.Http.Headers.RangeConditionHeaderValue;
			IfUnmodifiedSince: any;
			MaxForwards: any;
			ProxyAuthorization: System.Net.Http.Headers.AuthenticationHeaderValue;
			Range: System.Net.Http.Headers.RangeHeaderValue;
			Referrer: System.Uri;
			TE: any;
			UserAgent: any;
			CacheControl: System.Net.Http.Headers.CacheControlHeaderValue;
			Connection: any;
			ConnectionClose: any;
			Date: any;
			Pragma: any;
			Trailer: any;
			TransferEncoding: any;
			TransferEncodingChunked: any;
			Upgrade: any;
			Via: any;
			Warning: any;
			 Add(name: string, value: string) : void;
			 Add(name: string, values: any) : void;
			 TryAddWithoutValidation(name: string, value: string) : boolean;
			 TryAddWithoutValidation(name: string, values: any) : boolean;
			 Clear() : void;
			 GetValues(name: string) : any;
			 TryGetValues(name: string, values: any) : boolean;
			 Contains(name: string) : boolean;
			 ToString() : string;
			 GetEnumerator() : any;
			 Remove(name: string) : boolean;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class MediaTypeHeaderValue {
			CharSet: string;
			Parameters: any;
			MediaType: string;
			 constructor(mediaType: string) ;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static Parse(input: string) : System.Net.Http.Headers.MediaTypeHeaderValue;
			 static TryParse(input: string, parsedValue: any) : boolean;
			 GetType() : System.Type;
		}
		class RangeConditionHeaderValue {
			Date: any;
			EntityTag: System.Net.Http.Headers.EntityTagHeaderValue;
			 constructor(date: System.DateTimeOffset) ;
			 constructor(entityTag: System.Net.Http.Headers.EntityTagHeaderValue) ;
			 constructor(entityTag: string) ;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static Parse(input: string) : System.Net.Http.Headers.RangeConditionHeaderValue;
			 static TryParse(input: string, parsedValue: any) : boolean;
			 GetType() : System.Type;
		}
		class RangeHeaderValue {
			Unit: string;
			Ranges: any;
			 constructor() ;
			 constructor(from: any, to: any) ;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
			 static Parse(input: string) : System.Net.Http.Headers.RangeHeaderValue;
			 static TryParse(input: string, parsedValue: any) : boolean;
			 GetType() : System.Type;
		}
	}
	module System.Security.Authentication.ExtendedProtection {
		abstract class ChannelBinding extends Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid {
			Size: number;
			 DangerousGetHandle() : System.IntPtr;
			 Close() : void;
			 Dispose() : void;
			 SetHandleAsInvalid() : void;
			 DangerousAddRef(success: any) : void;
			 DangerousRelease() : void;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum ChannelBindingKind {
			Unknown = 0,
			Unique = 25,
			Endpoint = 26,
		}
	}
	module System.IO.Compression {
		enum CompressionLevel {
			Optimal = 0,
			Fastest = 1,
			NoCompression = 2,
		}
		class ZipArchive {
			Entries: any;
			Mode: System.IO.Compression.ZipArchiveMode;
			 constructor(stream: System.IO.Stream) ;
			 constructor(stream: System.IO.Stream, mode: System.IO.Compression.ZipArchiveMode) ;
			 constructor(stream: System.IO.Stream, mode: System.IO.Compression.ZipArchiveMode, leaveOpen: boolean) ;
			 constructor(stream: System.IO.Stream, mode: System.IO.Compression.ZipArchiveMode, leaveOpen: boolean, entryNameEncoding: System.Text.Encoding) ;
			 CreateEntry(entryName: string) : System.IO.Compression.ZipArchiveEntry;
			 CreateEntry(entryName: string, compressionLevel: System.IO.Compression.CompressionLevel) : System.IO.Compression.ZipArchiveEntry;
			 Dispose() : void;
			 GetEntry(entryName: string) : System.IO.Compression.ZipArchiveEntry;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ZipArchiveEntry {
			Archive: System.IO.Compression.ZipArchive;
			Crc32: System.UInt32;
			CompressedLength: number;
			ExternalAttributes: number;
			FullName: string;
			LastWriteTime: System.DateTimeOffset;
			Length: number;
			Name: string;
			 Delete() : void;
			 Open() : System.IO.Stream;
			 ToString() : string;
			 GetType() : System.Type;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		enum ZipArchiveMode {
			Read = 0,
			Create = 1,
			Update = 2,
		}
		abstract class ZipFile {
			 static OpenRead(archiveFileName: string) : System.IO.Compression.ZipArchive;
			 static Open(archiveFileName: string, mode: System.IO.Compression.ZipArchiveMode) : System.IO.Compression.ZipArchive;
			 static Open(archiveFileName: string, mode: System.IO.Compression.ZipArchiveMode, entryNameEncoding: System.Text.Encoding) : System.IO.Compression.ZipArchive;
			 static CreateFromDirectory(sourceDirectoryName: string, destinationArchiveFileName: string) : void;
			 static CreateFromDirectory(sourceDirectoryName: string, destinationArchiveFileName: string, compressionLevel: System.IO.Compression.CompressionLevel, includeBaseDirectory: boolean) : void;
			 static CreateFromDirectory(sourceDirectoryName: string, destinationArchiveFileName: string, compressionLevel: System.IO.Compression.CompressionLevel, includeBaseDirectory: boolean, entryNameEncoding: System.Text.Encoding) : void;
			 static ExtractToDirectory(sourceArchiveFileName: string, destinationDirectoryName: string) : void;
			 static ExtractToDirectory(sourceArchiveFileName: string, destinationDirectoryName: string, overwriteFiles: boolean) : void;
			 static ExtractToDirectory(sourceArchiveFileName: string, destinationDirectoryName: string, entryNameEncoding: System.Text.Encoding) : void;
			 static ExtractToDirectory(sourceArchiveFileName: string, destinationDirectoryName: string, entryNameEncoding: System.Text.Encoding, overwriteFiles: boolean) : void;
			 static GetType() : System.Type;
			 static ToString() : string;
			 static Equals(obj: any) : boolean;
			 static GetHashCode() : number;
		}
	}
	module Mono.Cecil.Js {
		class JsModder extends MonoMod.MonoModder {
			DefaultAssemblyResolver: Mono.Cecil.DefaultAssemblyResolver;
			 constructor() ;
			 ClearCaches(all?: boolean, shareable?: boolean, moduleSpecific?: boolean) : void;
			 Dispose() : void;
			 Log(value: any) : void;
			 Log(text: string) : void;
			 LogVerbose(value: any) : void;
			 LogVerbose(text: string) : void;
			 Read() : void;
			 MapDependencies() : void;
			 MapDependencies(main: Mono.Cecil.ModuleDefinition) : void;
			 MapDependency(main: Mono.Cecil.ModuleDefinition, depRef: Mono.Cecil.AssemblyNameReference) : void;
			 MapDependency(main: Mono.Cecil.ModuleDefinition, name: string, fullName?: string, depRef?: Mono.Cecil.AssemblyNameReference) : void;
			 DefaultMissingDependencyResolver(mod: MonoMod.MonoModder, main: Mono.Cecil.ModuleDefinition, name: string, fullName: string) : Mono.Cecil.ModuleDefinition;
			 Write(output?: System.IO.Stream, outputPath?: string) : void;
			 GenReaderParameters(mainModule: boolean, path?: string) : Mono.Cecil.ReaderParameters;
			 ReadMod(path: string) : void;
			 ReadMod(stream: System.IO.Stream) : void;
			 ParseRules(mod: Mono.Cecil.ModuleDefinition) : void;
			 ParseRulesInType(type: Mono.Cecil.TypeDefinition, rulesTypeMMILRT?: System.Type) : void;
			 ParseLinkFrom(target: Mono.Cecil.MemberReference, hook: Mono.Cecil.CustomAttribute) : void;
			 ParseLinkTo(from: Mono.Cecil.MemberReference, hook: Mono.Cecil.CustomAttribute) : void;
			 RunCustomAttributeHandlers(cap: Mono.Cecil.ICustomAttributeProvider) : void;
			 AutoPatch() : void;
			 Relinker(mtp: Mono.Cecil.IMetadataTokenProvider, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.IMetadataTokenProvider;
			 MainRelinker(mtp: Mono.Cecil.IMetadataTokenProvider, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.IMetadataTokenProvider;
			 PostRelinker(mtp: Mono.Cecil.IMetadataTokenProvider, context: Mono.Cecil.IGenericParameterProvider) : Mono.Cecil.IMetadataTokenProvider;
			 ResolveRelinkTarget(mtp: Mono.Cecil.IMetadataTokenProvider, relink?: boolean, relinkModule?: boolean) : Mono.Cecil.IMetadataTokenProvider;
			 DefaultParser(mod: MonoMod.MonoModder, body: Mono.Cecil.Cil.MethodBody, instr: Mono.Cecil.Cil.Instruction, instri: any) : boolean;
			 FindType(name: string) : Mono.Cecil.TypeReference;
			 FindType(name: string, runtimeName: boolean) : Mono.Cecil.TypeReference;
			 FindTypeDeep(name: string) : Mono.Cecil.TypeReference;
			 PrePatchModule(mod: Mono.Cecil.ModuleDefinition) : void;
			 PrePatchType(type: Mono.Cecil.TypeDefinition, forceAdd?: boolean) : void;
			 PatchModule(mod: Mono.Cecil.ModuleDefinition) : void;
			 PatchType(type: Mono.Cecil.TypeDefinition) : void;
			 PatchProperty(targetType: Mono.Cecil.TypeDefinition, prop: Mono.Cecil.PropertyDefinition, propMethods?: any) : void;
			 PatchEvent(targetType: Mono.Cecil.TypeDefinition, srcEvent: Mono.Cecil.EventDefinition, propMethods?: any) : void;
			 PatchField(targetType: Mono.Cecil.TypeDefinition, field: Mono.Cecil.FieldDefinition) : void;
			 PatchMethod(targetType: Mono.Cecil.TypeDefinition, method: Mono.Cecil.MethodDefinition) : Mono.Cecil.MethodDefinition;
			 PatchRefs() : void;
			 PatchRefs(mod: Mono.Cecil.ModuleDefinition) : void;
			 PatchRefsInType(type: Mono.Cecil.TypeDefinition) : void;
			 PatchRefsInMethod(method: Mono.Cecil.MethodDefinition) : void;
			 Cleanup(all?: boolean) : void;
			 CleanupType(type: Mono.Cecil.TypeDefinition, all?: boolean) : void;
			 Cleanup(cap: Mono.Cecil.ICustomAttributeProvider, all?: boolean) : void;
			 DefaultPostProcessor(modder: MonoMod.MonoModder) : void;
			 DefaultPostProcessType(type: Mono.Cecil.TypeDefinition) : void;
			 PatchWasHere() : Mono.Cecil.TypeDefinition;
			 GetMonoModOriginalCtor() : Mono.Cecil.MethodReference;
			 GetMonoModOriginalNameCtor() : Mono.Cecil.MethodReference;
			 GetMonoModAddedCtor() : Mono.Cecil.MethodReference;
			 GetMonoModPatchCtor() : Mono.Cecil.MethodReference;
			 GetMetadataToken(type: Mono.Cecil.TokenType) : Mono.Cecil.MetadataToken;
			 AllowedSpecialName(method: Mono.Cecil.MethodDefinition, targetType?: Mono.Cecil.TypeDefinition) : boolean;
			 MatchingConditionals(cap: Mono.Cecil.ICustomAttributeProvider, module: Mono.Cecil.ModuleDefinition) : boolean;
			 MatchingConditionals(cap: Mono.Cecil.ICustomAttributeProvider, asmName?: Mono.Cecil.AssemblyNameReference) : boolean;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
		class ResourceExtractor {
			 constructor() ;
			 Extract(inputFile: string) : string;
			 GetType() : System.Type;
			 ToString() : string;
			 Equals(obj: any) : boolean;
			 GetHashCode() : number;
		}
	}
}
